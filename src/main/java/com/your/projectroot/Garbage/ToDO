

The files are -
ActionUtil-
// Copyright 2000-2022 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package com.intellij.openapi.actionSystem.ex;

import com.intellij.diagnostic.PluginException;
import com.intellij.ide.DataManager;
import com.intellij.ide.IdeBundle;
import com.intellij.ide.actions.ActionsCollector;
import com.intellij.ide.lightEdit.LightEdit;
import com.intellij.ide.lightEdit.LightEditCompatible;
import com.intellij.ide.ui.IdeUiService;
import com.intellij.openapi.actionSystem.*;
import com.intellij.openapi.application.AccessToken;
import com.intellij.openapi.application.ApplicationManager;
import com.intellij.openapi.application.ApplicationNamesInfo;
import com.intellij.openapi.diagnostic.Logger;
import com.intellij.openapi.keymap.KeymapUtil;
import com.intellij.openapi.progress.ProcessCanceledException;
import com.intellij.openapi.progress.ProgressManager;
import com.intellij.openapi.project.DumbService;
import com.intellij.openapi.project.IndexNotReadyException;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.project.ProjectManager;
import com.intellij.openapi.ui.popup.JBPopup;
import com.intellij.openapi.ui.popup.JBPopupFactory;
import com.intellij.openapi.ui.popup.ListPopup;
import com.intellij.openapi.util.*;
import com.intellij.openapi.util.registry.Registry;
import com.intellij.openapi.util.text.StringUtil;
import com.intellij.psi.PsiDocumentManager;
import com.intellij.ui.ClientProperty;
import com.intellij.ui.CommonActionsPanel;
import com.intellij.util.ObjectUtils;
import com.intellij.util.SlowOperations;
import com.intellij.util.containers.ContainerUtil;
import com.intellij.util.ui.UIUtil;
import org.jetbrains.annotations.ApiStatus;
import org.jetbrains.annotations.NonNls;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionListener;
import java.awt.event.InputEvent;
import java.util.List;
import java.util.*;
import java.util.concurrent.TimeUnit;
import java.util.function.Consumer;
import java.util.function.Predicate;

public final class ActionUtil {
  private static final Logger LOG = Logger.getInstance(ActionUtil.class);

  public static final Key<Boolean> ALLOW_PlAIN_LETTER_SHORTCUTS = Key.create("ALLOW_PlAIN_LETTER_SHORTCUTS");
  @ApiStatus.Internal
  public static final Key<Boolean> ALLOW_ACTION_PERFORM_WHEN_HIDDEN = Key.create("ALLOW_ACTION_PERFORM_WHEN_HIDDEN");

  private static final Key<Boolean> WAS_ENABLED_BEFORE_DUMB = Key.create("WAS_ENABLED_BEFORE_DUMB");
  @ApiStatus.Internal
  public static final Key<Boolean> WOULD_BE_ENABLED_IF_NOT_DUMB_MODE = Key.create("WOULD_BE_ENABLED_IF_NOT_DUMB_MODE");
  private static final Key<Boolean> WOULD_BE_VISIBLE_IF_NOT_DUMB_MODE = Key.create("WOULD_BE_VISIBLE_IF_NOT_DUMB_MODE");

  private ActionUtil() {
  }

  public static void showDumbModeWarning(@Nullable Project project, AnActionEvent @NotNull ... events) {
    List<String> actionNames = new ArrayList<>();
    for (AnActionEvent event : events) {
      String s = event.getPresentation().getText();
      if (StringUtil.isNotEmpty(s)) {
        actionNames.add(s);
      }
    }
    if (LOG.isDebugEnabled()) {
      LOG.debug("Showing dumb mode warning for " + Arrays.asList(events), new Throwable());
    }
    if (project == null) return;
    DumbService.getInstance(project).showDumbModeNotification(getActionUnavailableMessage(actionNames));
  }

  private static @NotNull @NlsContexts.PopupContent String getActionUnavailableMessage(@NotNull List<String> actionNames) {
    String message;
    if (actionNames.isEmpty()) {
      message = getUnavailableMessage("This action", false);
    }
    else if (actionNames.size() == 1) {
      message = getUnavailableMessage("'" + actionNames.get(0) + "'", false);
    }
    else {
      message = getUnavailableMessage("None of the following actions", true) +
                ": " + StringUtil.join(actionNames, ", ");
    }
    return message;
  }

  public static @NotNull @NlsContexts.PopupContent String getUnavailableMessage(@NotNull String action, boolean plural) {
    if (plural) {
      return IdeBundle.message("popup.content.actions.not.available.while.updating.indices", action,
                               ApplicationNamesInfo.getInstance().getProductName());
    }
    return IdeBundle.message("popup.content.action.not.available.while.updating.indices", action,
                             ApplicationNamesInfo.getInstance().getProductName());
  }

  /**
   * @deprecated Use {@link #performDumbAwareUpdate(AnAction, AnActionEvent, boolean)} instead
   */
  @Deprecated(forRemoval = true)
  public static boolean performDumbAwareUpdate(boolean isInModalContext,
                                               @NotNull AnAction action,
                                               @NotNull AnActionEvent e,
                                               boolean beforeActionPerformed) {
    return performDumbAwareUpdate(action, e, beforeActionPerformed);
  }

  /**
   * Calls {@link AnAction#update(AnActionEvent)} or {@link AnAction#beforeActionPerformedUpdate(AnActionEvent)}
   * depending on {@code beforeActionPerformed} value with all the required extra logic around it.
   *
   * @return true if update tried to access indices in dumb mode
   */
  public static boolean performDumbAwareUpdate(@NotNull AnAction action, @NotNull AnActionEvent e, boolean beforeActionPerformed) {
    Presentation presentation = e.getPresentation();
    if (LightEdit.owns(e.getProject()) && !isActionLightEditCompatible(action)) {
      presentation.setEnabledAndVisible(false);
      presentation.putClientProperty(WOULD_BE_ENABLED_IF_NOT_DUMB_MODE, false);
      presentation.putClientProperty(WOULD_BE_VISIBLE_IF_NOT_DUMB_MODE, false);
      return false;
    }

    Boolean wasEnabledBefore = presentation.getClientProperty(WAS_ENABLED_BEFORE_DUMB);
    boolean dumbMode = isDumbMode(e.getProject());
    if (wasEnabledBefore != null && !dumbMode) {
      presentation.putClientProperty(WAS_ENABLED_BEFORE_DUMB, null);
      presentation.setEnabled(wasEnabledBefore.booleanValue());
      presentation.setVisible(true);
    }
    boolean enabledBeforeUpdate = presentation.isEnabled();
    boolean allowed = !dumbMode || action.isDumbAware();

    action.applyTextOverride(e);
    try {
      if (beforeActionPerformed && e.getUpdateSession() == UpdateSession.EMPTY) {
        IdeUiService.getInstance().initUpdateSession(e);
      }
      Runnable runnable = () -> {
        // init group flags from deprecated methods
        boolean isGroup = action instanceof ActionGroup;
        boolean wasPopup = isGroup && ((ActionGroup)action).isPopup(e.getPlace());
        boolean wasHideIfEmpty = isGroup && ((ActionGroup)action).hideIfNoVisibleChildren();
        boolean wasDisableIfEmpty = isGroup && ((ActionGroup)action).disableIfNoVisibleChildren();
        presentation.setPopupGroup(isGroup && (presentation.isPopupGroup() || wasPopup));

        e.setInjectedContext(action.isInInjectedContext());
        if (beforeActionPerformed) {
          action.beforeActionPerformedUpdate(e);
        }
        else {
          action.update(e);
        }
        if (!e.getPresentation().isEnabled() && e.isInInjectedContext()) {
          e.setInjectedContext(false);
          if (beforeActionPerformed) {
            action.beforeActionPerformedUpdate(e);
          }
          else {
            action.update(e);
          }
        }
        //to be removed when ActionGroup#canBePerformed is dropped
        e.getPresentation().setPerformGroup(
          isGroup && e.getPresentation().isPopupGroup() &&
          (e.getPresentation().isPerformGroup() || ((ActionGroup)action).canBePerformed(e.getDataContext())));
        if (isGroup) {
          assertDeprecatedActionGroupFlagsNotChanged((ActionGroup)action, e, wasPopup, wasHideIfEmpty, wasDisableIfEmpty);
        }
      };
      boolean isLikeUpdate = !beforeActionPerformed && Registry.is("actionSystem.update.actions.async");
      try (AccessToken ignore = SlowOperations.startSection(isLikeUpdate ? SlowOperations.ACTION_UPDATE
                                                                         : SlowOperations.ACTION_PERFORM)) {
        long startTime = System.nanoTime();
        runnable.run();
        long duration = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startTime);
        ActionsCollector.getInstance().recordUpdate(action, e, duration);
      }
      presentation.putClientProperty(WOULD_BE_ENABLED_IF_NOT_DUMB_MODE, !allowed && presentation.isEnabled());
      presentation.putClientProperty(WOULD_BE_VISIBLE_IF_NOT_DUMB_MODE, !allowed && presentation.isVisible());
    }
    catch (IndexNotReadyException e1) {
      if (!allowed) {
        return true;
      }
      throw e1;
    }
    finally {
      if (!allowed) {
        if (wasEnabledBefore == null) {
          presentation.putClientProperty(WAS_ENABLED_BEFORE_DUMB, enabledBeforeUpdate);
        }
        presentation.setEnabled(false);
      }
    }

    return false;
  }

  private static boolean isActionLightEditCompatible(@NotNull AnAction action) {
    if (action instanceof AnActionWrapper wrapper) return isActionLightEditCompatible(wrapper.getDelegate());
    return (action instanceof ActionGroup) && action.isDumbAware() || action instanceof LightEditCompatible;
  }

  private static void assertDeprecatedActionGroupFlagsNotChanged(@NotNull ActionGroup group, @NotNull AnActionEvent event,
                                                                 boolean wasPopup, boolean wasHideIfEmpty, boolean wasDisableIfEmpty) {
    boolean warnPopup = wasPopup != group.isPopup(event.getPlace());
    boolean warnHide = wasHideIfEmpty != group.hideIfNoVisibleChildren();
    boolean warnDisable = wasDisableIfEmpty != group.disableIfNoVisibleChildren();
    if (!(warnPopup || warnHide || warnDisable)) return;
    String operationName = group.getClass().getSimpleName() + "#update (" + group.getClass().getName() + ")";
    if (warnPopup) {
      event.getPresentation().setPopupGroup(!wasPopup); // keep the old logic for a while
      String message = "Calling `setPopup()` in " + operationName + ". " +
                       "Please use `event.getPresentation().setPopupGroup()` instead.";
      LOG.error(PluginException.createByClass(message, null, group.getClass()));
    }
    if (warnHide) {
      event.getPresentation().setHideGroupIfEmpty(!wasHideIfEmpty); // keep the old logic for a while
      String message = "Changing `hideIfNoVisibleChildren()` result in " + operationName + ". " +
                       "Please use `event.getPresentation().setHideGroupIfEmpty()` instead.";
      LOG.error(PluginException.createByClass(message, null, group.getClass()));
    }
    if (warnHide) {
      event.getPresentation().setDisableGroupIfEmpty(!wasDisableIfEmpty); // keep the old logic for a while
      String message = "Changing `disableIfNoVisibleChildren()` result in " + operationName + ". " +
                       "Please use `event.getPresentation().setHideGroupIfEmpty()` instead.";
      LOG.error(PluginException.createByClass(message, null, group.getClass()));
    }
  }


  /**
   * Show a cancellable modal progress running the given computation under read action with the same {@link DumbService#isAlternativeResolveEnabled()}
   * as the caller. To be used in actions which need to perform potentially long-running computations synchronously without freezing UI.
   *
   * @throws ProcessCanceledException if the user has canceled the progress. If the action can be safely stopped at this point
   *                                  without leaving inconsistent data behind, this exception doesn't need to be caught and processed.
   */
  public static <T> T underModalProgress(@NotNull Project project,
                                         @NotNull @NlsContexts.ProgressTitle String progressTitle,
                                         @NotNull Computable<T> computable) throws ProcessCanceledException {
    DumbService dumbService = DumbService.getInstance(project);
    boolean useAlternativeResolve = dumbService.isAlternativeResolveEnabled();
    ThrowableComputable<T, RuntimeException> inReadAction = () -> ApplicationManager.getApplication().runReadAction(computable);
    ThrowableComputable<T, RuntimeException> prioritizedRunnable = () -> ProgressManager.getInstance().computePrioritized(inReadAction);
    ThrowableComputable<T, RuntimeException> process = useAlternativeResolve
                                                       ? () -> dumbService.computeWithAlternativeResolveEnabled(prioritizedRunnable)
                                                       : prioritizedRunnable;
    return ProgressManager.getInstance().runProcessWithProgressSynchronously(process, progressTitle, true, project);
  }

  /**
   * @return whether a dumb mode is in progress for the passed project or, if the argument is null, for any open project.
   * @see DumbService
   */
  public static boolean isDumbMode(@Nullable Project project) {
    if (project != null) {
      return DumbService.getInstance(project).isDumb();
    }
    for (Project openProject : ProjectManager.getInstance().getOpenProjects()) {
      if (DumbService.getInstance(openProject).isDumb()) {
        return true;
      }
    }
    return false;
  }

  public static boolean lastUpdateAndCheckDumb(@NotNull AnAction action, @NotNull AnActionEvent e, boolean visibilityMatters) {
    Project project = e.getProject();
    if (project != null && PerformWithDocumentsCommitted.isPerformWithDocumentsCommitted(action)) {
      try (AccessToken ignore = SlowOperations.startSection(SlowOperations.ACTION_PERFORM)) {
        PsiDocumentManager.getInstance(project).commitAllDocuments();
      }
    }
    performDumbAwareUpdate(action, e, true);

    if (project != null && DumbService.getInstance(project).isDumb() && !action.isDumbAware()) {
      if (Boolean.FALSE.equals(e.getPresentation().getClientProperty(WOULD_BE_ENABLED_IF_NOT_DUMB_MODE))) {
        return false;
      }
      if (visibilityMatters && Boolean.FALSE.equals(e.getPresentation().getClientProperty(WOULD_BE_VISIBLE_IF_NOT_DUMB_MODE))) {
        return false;
      }

      showDumbModeWarning(project, e);
      return false;
    }

    if (!e.getPresentation().isEnabled()) {
      return false;
    }
    return !visibilityMatters || e.getPresentation().isVisible();
  }

  /**
   * @deprecated use {@link #performActionDumbAwareWithCallbacks(AnAction, AnActionEvent)}
   */
  @Deprecated(forRemoval = true)
  public static void performActionDumbAwareWithCallbacks(@NotNull AnAction action, @NotNull AnActionEvent e, @NotNull DataContext context) {
    LOG.assertTrue(e.getDataContext() == context, "event context does not match the argument");
    performActionDumbAwareWithCallbacks(action, e);
  }

  public static void performActionDumbAwareWithCallbacks(@NotNull AnAction action, @NotNull AnActionEvent e) {
    performDumbAwareWithCallbacks(action, e, () -> doPerformActionOrShowPopup(action, e, null));
  }

  @ApiStatus.Internal
  public static void doPerformActionOrShowPopup(@NotNull AnAction action,
                                                @NotNull AnActionEvent e,
                                                @Nullable Consumer<? super JBPopup> popupShow) {
    if (action instanceof ActionGroup group && !e.getPresentation().isPerformGroup()) {
      DataContext dataContext = e.getDataContext();
      String place = ActionPlaces.getActionGroupPopupPlace(e.getPlace());
      ListPopup popup = JBPopupFactory.getInstance().createActionGroupPopup(
        e.getPresentation().getText(), group, dataContext,
        JBPopupFactory.ActionSelectionAid.SPEEDSEARCH,
        false, null, -1, null, place);
      var toolbarPopupLocation = CommonActionsPanel.getPreferredPopupPoint(action, dataContext.getData(PlatformCoreDataKeys.CONTEXT_COMPONENT));
      if (toolbarPopupLocation != null) {
        popup.show(toolbarPopupLocation);
      }
      else if (popupShow != null) {
        popupShow.accept(popup);
      }
      else {
        popup.showInBestPositionFor(dataContext);
      }
    }
    else {
      action.actionPerformed(e);
    }
  }

  public static void performDumbAwareWithCallbacks(@NotNull AnAction action,
                                                   @NotNull AnActionEvent event,
                                                   @NotNull Runnable performRunnable) {
    Project project = event.getProject();
    IndexNotReadyException indexError = null;
    ActionManagerEx manager = ActionManagerEx.getInstanceEx();
    manager.fireBeforeActionPerformed(action, event);
    Component component = event.getData(PlatformCoreDataKeys.CONTEXT_COMPONENT);
    if (component != null && !UIUtil.isShowing(component) &&
        !ActionPlaces.TOUCHBAR_GENERAL.equals(event.getPlace()) &&
        !Boolean.TRUE.equals(ClientProperty.get(component, ALLOW_ACTION_PERFORM_WHEN_HIDDEN))) {
      String id = StringUtil.notNullize(event.getActionManager().getId(action), action.getClass().getName());
      LOG.warn("Action is not performed because target component is not showing: " +
               "action=" + id + ", component=" + component.getClass().getName());
      manager.fireAfterActionPerformed(action, event, AnActionResult.IGNORED);
      return;
    }
    AnActionResult result = null;
    try (AccessToken ignore = SlowOperations.startSection(SlowOperations.ACTION_PERFORM)) {
      performRunnable.run();
      result = AnActionResult.PERFORMED;
    }
    catch (IndexNotReadyException ex) {
      indexError = ex;
      result = AnActionResult.failed(ex);
    }
    catch (RuntimeException | Error ex) {
      result = AnActionResult.failed(ex);
      throw ex;
    }
    finally {
      if (result == null) result = AnActionResult.failed(new Throwable());
      manager.fireAfterActionPerformed(action, event, result);
    }
    if (indexError != null) {
      LOG.info(indexError);
      showDumbModeWarning(project, event);
    }
  }

  /**
   * @deprecated use {@link #performActionDumbAwareWithCallbacks(AnAction, AnActionEvent)} or
   * {@link AnAction#actionPerformed(AnActionEvent)} instead
   */
  @Deprecated(forRemoval = true)
  public static void performActionDumbAware(@NotNull AnAction action, @NotNull AnActionEvent event) {
    Project project = event.getProject();
    try {
      doPerformActionOrShowPopup(action, event, null);
    }
    catch (IndexNotReadyException ex) {
      LOG.info(ex);
      showDumbModeWarning(project, event);
    }
  }

  public static @NotNull AnActionEvent createEmptyEvent() {
    return AnActionEvent.createFromDataContext(ActionPlaces.UNKNOWN, null, dataId -> null);
  }

  public static void sortAlphabetically(@NotNull List<? extends AnAction> list) {
    list.sort((o1, o2) -> Comparing.compare(o1.getTemplateText(), o2.getTemplateText()));
  }

  /**
   * Tries to find an 'action' and 'target action' by text and put the 'action' just before of after the 'target action'
   */
  public static void moveActionTo(@NotNull List<AnAction> list,
                                  @NotNull String actionText,
                                  @NotNull String targetActionText,
                                  boolean before) {
    if (Objects.equals(actionText, targetActionText)) {
      return;
    }

    int actionIndex = -1;
    int targetIndex = -1;
    for (int i = 0; i < list.size(); i++) {
      AnAction action = list.get(i);
      if (actionIndex == -1 && Objects.equals(actionText, action.getTemplateText())) actionIndex = i;
      if (targetIndex == -1 && Objects.equals(targetActionText, action.getTemplateText())) targetIndex = i;
      if (actionIndex != -1 && targetIndex != -1) {
        if (actionIndex < targetIndex) targetIndex--;
        AnAction anAction = list.remove(actionIndex);
        list.add(before ? targetIndex : targetIndex + 1, anAction);
        return;
      }
    }
  }

  public static @NotNull List<AnAction> getActions(@NotNull JComponent component) {
    return ContainerUtil.notNullize(ClientProperty.get(component, AnAction.ACTIONS_KEY));
  }

  public static void clearActions(@NotNull JComponent component) {
    ClientProperty.put(component, AnAction.ACTIONS_KEY, null);
  }

  public static void copyRegisteredShortcuts(@NotNull JComponent to, @NotNull JComponent from) {
    for (AnAction anAction : getActions(from)) {
      anAction.registerCustomShortcutSet(anAction.getShortcutSet(), to);
    }
  }

  public static void registerForEveryKeyboardShortcut(@NotNull JComponent component,
                                                      @NotNull ActionListener action,
                                                      @NotNull ShortcutSet shortcuts) {
    for (Shortcut shortcut : shortcuts.getShortcuts()) {
      if (shortcut instanceof KeyboardShortcut ks) {
        KeyStroke first = ks.getFirstKeyStroke();
        KeyStroke second = ks.getSecondKeyStroke();
        if (second == null) {
          component.registerKeyboardAction(action, first, JComponent.WHEN_IN_FOCUSED_WINDOW);
        }
      }
    }
  }

  public static boolean recursiveContainsAction(@NotNull ActionGroup group, @NotNull AnAction action) {
    return anyActionFromGroupMatches(group, true, Predicate.isEqual(action));
  }

  public static boolean anyActionFromGroupMatches(@NotNull ActionGroup group, boolean processPopupSubGroups,
                                                  @NotNull Predicate<? super AnAction> condition) {
    for (AnAction child : group.getChildren(null)) {
      if (condition.test(child)) return true;
      if (child instanceof ActionGroup childGroup) {
        if ((processPopupSubGroups || !childGroup.isPopup()) && anyActionFromGroupMatches(childGroup, processPopupSubGroups, condition)) {
          return true;
        }
      }
    }
    return false;
  }

  /**
   * Convenience method for copying properties from a registered action
   *
   * @param actionId action id
   */
  public static AnAction copyFrom(@NotNull AnAction action, @NotNull @NonNls String actionId) {
    AnAction from = ActionManager.getInstance().getAction(actionId);
    if (from != null) {
      action.copyFrom(from);
    }
    ActionsCollector.getInstance().onActionConfiguredByActionId(action, actionId);
    return action;
  }

  /**
   * Convenience method for merging non-null properties from a registered action
   *
   * @param action   action to merge to
   * @param actionId action id to merge from
   */
  public static AnAction mergeFrom(@NotNull AnAction action, @NotNull String actionId) {
    //noinspection UnnecessaryLocalVariable
    AnAction a1 = action;
    AnAction a2 = ActionManager.getInstance().getAction(actionId);
    Presentation p1 = a1.getTemplatePresentation();
    Presentation p2 = a2.getTemplatePresentation();
    p1.setIcon(ObjectUtils.chooseNotNull(p1.getIcon(), p2.getIcon()));
    p1.setDisabledIcon(ObjectUtils.chooseNotNull(p1.getDisabledIcon(), p2.getDisabledIcon()));
    p1.setSelectedIcon(ObjectUtils.chooseNotNull(p1.getSelectedIcon(), p2.getSelectedIcon()));
    p1.setHoveredIcon(ObjectUtils.chooseNotNull(p1.getHoveredIcon(), p2.getHoveredIcon()));
    if (StringUtil.isEmpty(p1.getText())) {
      p1.setTextWithMnemonic(p2.getTextWithPossibleMnemonic());
    }
    p1.setDescription(ObjectUtils.chooseNotNull(p1.getDescription(), p2.getDescription()));
    ShortcutSet ss1 = a1.getShortcutSet();
    if (ss1 == CustomShortcutSet.EMPTY) {
      a1.copyShortcutFrom(a2);
    }
    ActionsCollector.getInstance().onActionConfiguredByActionId(action, actionId);
    return a1;
  }

  public static void invokeAction(@NotNull AnAction action,
                                  @NotNull Component component,
                                  @NotNull String place,
                                  @Nullable InputEvent inputEvent,
                                  @Nullable Runnable onDone) {
    invokeAction(action, DataManager.getInstance().getDataContext(component), place, inputEvent, onDone);
  }

  public static void invokeAction(@NotNull AnAction action,
                                  @NotNull DataContext dataContext,
                                  @NotNull String place,
                                  @Nullable InputEvent inputEvent,
                                  @Nullable Runnable onDone) {
    Presentation presentation = action.getTemplatePresentation().clone();
    AnActionEvent event = AnActionEvent.createFromInputEvent(inputEvent, place, presentation, dataContext);
    event.setInjectedContext(action.isInInjectedContext());
    if (lastUpdateAndCheckDumb(action, event, false)) {
      try {
        performActionDumbAwareWithCallbacks(action, event);
      }
      finally {
        if (onDone != null) {
          onDone.run();
        }
      }
    }
  }

  public static @NotNull ActionListener createActionListener(@NotNull String actionId,
                                                             @NotNull Component component,
                                                             @NotNull String place) {
    return e -> {
      AnAction action = getAction(actionId);
      if (action == null) {
        return;
      }
      invokeAction(action, component, place, null, null);
    };
  }

  public static @Nullable ShortcutSet getMnemonicAsShortcut(@NotNull AnAction action) {
    return KeymapUtil.getShortcutsForMnemonicCode(action.getTemplatePresentation().getMnemonic());
  }

  @ApiStatus.Experimental
  public static @NotNull ShortcutSet getShortcutSet(@NotNull @NonNls String id) {
    AnAction action = getAction(id);
    return action == null ? CustomShortcutSet.EMPTY : action.getShortcutSet();
  }

  @ApiStatus.Experimental
  public static @Nullable AnAction getAction(@NotNull @NonNls String id) {
    AnAction action = ActionManager.getInstance().getAction(id);
    if (action == null) LOG.warn("Can not find action by id " + id);
    return action;
  }

  @ApiStatus.Experimental
  public static @Nullable ActionGroup getActionGroup(@NotNull @NonNls String id) {
    AnAction action = getAction(id);
    if (action instanceof ActionGroup) return (ActionGroup)action;
    return action == null ? null : new DefaultActionGroup(Collections.singletonList(action));
  }

  @ApiStatus.Experimental
  public static @Nullable ActionGroup getActionGroup(@NonNls String @NotNull ... ids) {
    if (ids.length == 1) return getActionGroup(ids[0]);
    List<AnAction> actions = ContainerUtil.mapNotNull(ids, ActionUtil::getAction);
    return actions.isEmpty() ? null : new DefaultActionGroup(actions);
  }

  public static @NotNull Object getDelegateChainRoot(@NotNull AnAction action) {
    Object delegate = action;
    while (delegate instanceof ActionWithDelegate<?>) {
      delegate = ((ActionWithDelegate<?>)delegate).getDelegate();
    }
    return delegate;
  }

  public static @NotNull AnAction getDelegateChainRootAction(@NotNull AnAction action) {
    while (action instanceof ActionWithDelegate<?>) {
      Object delegate = ((ActionWithDelegate<?>)action).getDelegate();
      if (delegate instanceof AnAction) {
        action = (AnAction)delegate;
      }
      else {
        return action;
      }
    }
    return action;
  }

  @ApiStatus.Experimental
  public static @NotNull JComponent createToolbarComponent(@NotNull JComponent target,
                                                           @NotNull @NonNls String place,
                                                           @NotNull ActionGroup group,
                                                           boolean horizontal) {
    ActionToolbar toolbar = ActionManager.getInstance().createActionToolbar(place, group, horizontal);
    toolbar.setTargetComponent(target);
    return toolbar.getComponent();
  }
}



ActionMenuItem-
// Copyright 2000-2023 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package com.intellij.openapi.actionSystem.impl;

import com.intellij.featureStatistics.FeatureUsageTracker;
import com.intellij.ide.IdeEventQueue;
import com.intellij.ide.ui.UISettings;
import com.intellij.internal.statistic.collectors.fus.actions.persistence.MainMenuCollector;
import com.intellij.openapi.actionSystem.*;
import com.intellij.openapi.actionSystem.ex.ActionUtil;
import com.intellij.openapi.actionSystem.impl.actionholder.ActionRef;
import com.intellij.openapi.application.Application;
import com.intellij.openapi.application.ApplicationManager;
import com.intellij.openapi.application.TransactionGuard;
import com.intellij.openapi.application.TransactionGuardImpl;
import com.intellij.openapi.keymap.KeymapUtil;
import com.intellij.openapi.util.IconLoader;
import com.intellij.openapi.util.NlsSafe;
import com.intellij.openapi.util.SystemInfo;
import com.intellij.openapi.wm.IdeFocusManager;
import com.intellij.ui.components.JBCheckBoxMenuItem;
import com.intellij.ui.icons.IconUtilKt;
import com.intellij.ui.mac.screenmenu.Menu;
import com.intellij.ui.mac.screenmenu.MenuItem;
import com.intellij.ui.plaf.beg.BegMenuItemUI;
import com.intellij.ui.popup.KeepingPopupOpenAction;
import com.intellij.util.ui.EmptyIcon;
import com.intellij.util.ui.LafIconLookup;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.InputEvent;
import java.awt.event.KeyEvent;

import static com.intellij.openapi.keymap.KeymapUtil.getActiveKeymapShortcuts;

public final class ActionMenuItem extends JBCheckBoxMenuItem {
  static final Icon EMPTY_ICON = EmptyIcon.create(16, 1);

  private final ActionRef<AnAction> myAction;
  private final String myPlace;
  private final boolean myInsideCheckedGroup;
  private final boolean myEnableMnemonics;
  private final boolean myToggleable;
  private final DataContext myContext;
  private final boolean myUseDarkIcons;
  private final @Nullable MenuItem myScreenMenuItemPeer;

  private String myDescription;
  private boolean myToggled;
  private boolean myKeepMenuOpen;

  ActionMenuItem(@NotNull AnAction action,
                 @NotNull String place,
                 @NotNull DataContext context,
                 boolean enableMnemonics,
                 boolean insideCheckedGroup,
                 boolean useDarkIcons) {
    myAction = ActionRef.fromAction(action);
    myPlace = place;
    myContext = context;
    myEnableMnemonics = enableMnemonics;
    myToggleable = action instanceof Toggleable;
    myInsideCheckedGroup = insideCheckedGroup;
    myUseDarkIcons = useDarkIcons;
    addActionListener(e -> performAction(e.getModifiers()));
    setBorderPainted(false);

    if (Menu.isJbScreenMenuEnabled() && ActionPlaces.MAIN_MENU.equals(myPlace)) {
      myScreenMenuItemPeer = new MenuItem();
      myScreenMenuItemPeer.setActionDelegate(() -> {
        // Called on AppKit when user activates menu item
        if (isToggleable()) {
          myToggled = !myToggled;
          myScreenMenuItemPeer.setState(myToggled);
        }
        SwingUtilities.invokeLater(() -> {
          if (myAction.getAction().isEnabledInModalContext() ||
              !Boolean.TRUE.equals(myContext.getData(PlatformCoreDataKeys.IS_MODAL_CONTEXT))) {
            ((TransactionGuardImpl)TransactionGuard.getInstance()).performUserActivity(() -> performAction(0));
          }
        });
      });
    }
    else {
      myScreenMenuItemPeer = null;
    }

    updateUI();
    updateAccelerator();
  }

  public @NotNull AnAction getAnAction() {
    return myAction.getAction();
  }

  public @NotNull String getPlace() {
    return myPlace;
  }

  public @Nullable MenuItem getScreenMenuItemPeer() { return myScreenMenuItemPeer; }

  private static boolean isEnterKeyStroke(KeyStroke keyStroke) {
    return keyStroke.getKeyCode() == KeyEvent.VK_ENTER && keyStroke.getModifiers() == 0;
  }

  @Override
  public void fireActionPerformed(ActionEvent event) {
    Application app = ApplicationManager.getApplication();
    if (!app.isDisposed() && ActionPlaces.MAIN_MENU.equals(myPlace)) {
      MainMenuCollector.getInstance().record(myAction.getAction());
    }
    ((TransactionGuardImpl)TransactionGuard.getInstance()).performUserActivity(() -> super.fireActionPerformed(event));
  }

  private void updateAccelerator() {
    AnAction action = myAction.getAction();
    String id = ActionManager.getInstance().getId(action);
    if (id != null) {
      setAcceleratorFromShortcuts(getActiveKeymapShortcuts(id).getShortcuts());
    }
    else {
      ShortcutSet shortcutSet = action.getShortcutSet();
      setAcceleratorFromShortcuts(shortcutSet.getShortcuts());
    }
  }

  void updateFromPresentation(@NotNull Presentation presentation) {
    // all items must be visible at this point
    //setVisible(presentation.isVisible());
    setEnabled(presentation.isEnabled());
    setText(presentation.getText(myEnableMnemonics));
    setMnemonic(presentation.getMnemonic());
    setDisplayedMnemonicIndex(presentation.getDisplayedMnemonicIndex());
    updateIcon(presentation);
    myDescription = presentation.getDescription();
    myKeepMenuOpen = myKeepMenuOpen || presentation.isMultiChoice() || myAction.getAction() instanceof KeepingPopupOpenAction;

    if (myScreenMenuItemPeer != null) {
      myScreenMenuItemPeer.setLabel(getText(), getAccelerator());
      myScreenMenuItemPeer.setEnabled(isEnabled());
    }
  }

  @Override
  public void setDisplayedMnemonicIndex(int index) throws IllegalArgumentException {
    super.setDisplayedMnemonicIndex(myEnableMnemonics ? index : -1);
  }

  @Override
  public void setMnemonic(int mnemonic) {
    super.setMnemonic(myEnableMnemonics ? mnemonic : 0);
  }

  private void setAcceleratorFromShortcuts(Shortcut @NotNull [] shortcuts) {
    for (Shortcut shortcut : shortcuts) {
      if (shortcut instanceof KeyboardShortcut) {
        final KeyStroke firstKeyStroke = ((KeyboardShortcut)shortcut).getFirstKeyStroke();
        //If action has Enter shortcut, do not add it. Otherwise, user won't be able to chose any ActionMenuItem other than that
        if (!isEnterKeyStroke(firstKeyStroke)) {
          setAccelerator(firstKeyStroke);
          if (myScreenMenuItemPeer != null) myScreenMenuItemPeer.setLabel(getText(), firstKeyStroke);
          if (KeymapUtil.isSimplifiedMacShortcuts()) {
            final String shortcutText = KeymapUtil.getPreferredShortcutText(shortcuts);
            putClientProperty("accelerator.text", shortcutText);
            if (myScreenMenuItemPeer != null) myScreenMenuItemPeer.setAcceleratorText(shortcutText);
          }
        }
        break;
      }
    }
  }

  @Override
  public void updateUI() {
    setUI(BegMenuItemUI.createUI(this));
  }

  /**
   * Updates long description of action at the status bar.
   */
  @Override
  public void menuSelectionChanged(boolean isIncluded) {
    super.menuSelectionChanged(isIncluded);
    //noinspection HardCodedStringLiteral
    ActionMenu.showDescriptionInStatusBar(isIncluded, this, myDescription);
  }

  @NlsSafe
  public String getFirstShortcutText() {
    return KeymapUtil.getFirstKeyboardShortcutText(myAction.getAction());
  }

  private void updateIcon(@NotNull Presentation presentation) {
    myToggled = isToggleable() && Toggleable.isSelected(presentation);
    if (isToggleable() && (presentation.getIcon() == null || myInsideCheckedGroup || !UISettings.getInstance().getShowIconsInMenus())) {
      if (ActionPlaces.MAIN_MENU.equals(myPlace) && SystemInfo.isMacSystemMenu) {
        setState(myToggled);
        if (myScreenMenuItemPeer != null) myScreenMenuItemPeer.setState(myToggled);
        setIcon(wrapNullIcon(getIcon()));
      }
      else if (myToggled) {
        Icon checkmark = LafIconLookup.getIcon("checkmark");
        Icon selectedCheckmark = LafIconLookup.getSelectedIcon("checkmark");
        Icon disabledCheckmark = LafIconLookup.getDisabledIcon("checkmark");
        if (ActionMenu.shouldConvertIconToDarkVariant()) {
          checkmark = IconLoader.getDarkIcon(checkmark, true);
          selectedCheckmark = IconLoader.getDarkIcon(selectedCheckmark, true);
          disabledCheckmark = IconLoader.getDarkIcon(disabledCheckmark, true);
        }
        setIcon(checkmark);
        setSelectedIcon(selectedCheckmark);
        setDisabledIcon(disabledCheckmark);
      }
      else {
        setIcon(EmptyIcon.ICON_16);
        setSelectedIcon(EmptyIcon.ICON_16);
        setDisabledIcon(EmptyIcon.ICON_16);
      }
    }
    else if (UISettings.getInstance().getShowIconsInMenus()) {
      Icon icon = presentation.getIcon();
      if (isToggleable() && myToggled) {
        icon = new PoppedIcon(icon, 16, 16);
      }
      Icon disabled = presentation.getDisabledIcon();
      if (disabled == null) {
        disabled = icon == null ? null : IconLoader.getDisabledIcon(icon);
      }
      Icon selected = presentation.getSelectedIcon();
      if (selected == null) {
        selected = icon;
      }

      setIcon(wrapNullIcon(presentation.isEnabled() ? icon : disabled));
      setSelectedIcon(wrapNullIcon(selected));
      setDisabledIcon(wrapNullIcon(disabled));
    }
  }

  private Icon wrapNullIcon(Icon icon) {
    boolean isMainMenu = ActionPlaces.MAIN_MENU.equals(myPlace);
    if (isMainMenu && ActionMenu.isShowNoIcons(myAction.getAction())) {
      return null;
    }
    if (!ActionMenu.isAligned() || !ActionMenu.isAlignedInGroup()) {
      return icon;
    }
    if (icon == null && SystemInfo.isMacSystemMenu && ActionPlaces.MAIN_MENU.equals(myPlace)) {
      return EMPTY_ICON;
    }
    return icon;
  }

  @Override
  public void setIcon(Icon icon) {
    if (icon != null) {
      if (SystemInfo.isMacSystemMenu && ActionPlaces.MAIN_MENU.equals(myPlace)) {
        // JDK can't paint correctly our HiDPI icons at the system menu bar
        icon = IconUtilKt.getMenuBarIcon(icon, myUseDarkIcons);
      }
      else if (ActionMenu.shouldConvertIconToDarkVariant()) {
        icon = IconLoader.getDarkIcon(icon, true);
      }
    }
    super.setIcon(icon);
    if (myScreenMenuItemPeer != null) myScreenMenuItemPeer.setIcon(icon);
  }

  public boolean isToggleable() {
    return myToggleable;
  }

  @Override
  public boolean isSelected() {
    return myToggled;
  }

  public boolean isKeepMenuOpen() {
    return myKeepMenuOpen;
  }

  private void performAction(int modifiers) {
    IdeFocusManager focusManager = IdeFocusManager.findInstanceByContext(myContext);
    AnAction action = myAction.getAction();
    String id = ActionManager.getInstance().getId(action);
    if (id != null) {
      FeatureUsageTracker.getInstance().triggerFeatureUsed("context.menu.click.stats." + id.replace(' ', '.'));
    }

    focusManager.runOnOwnContext(myContext, () -> {
      AWTEvent currentEvent = IdeEventQueue.getInstance().getTrueCurrentEvent();
      AnActionEvent event = new AnActionEvent(
        currentEvent instanceof InputEvent ? (InputEvent)currentEvent : null,
        myContext, myPlace, action.getTemplatePresentation().clone(),
        ActionManager.getInstance(), modifiers, true, false);
      if (ActionUtil.lastUpdateAndCheckDumb(action, event, false)) {
        ActionUtil.performActionDumbAwareWithCallbacks(action, event);
      }
    });
  }
}


TransactionGuardianImpl-
// Copyright 2000-2023 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package com.intellij.openapi.application;

import com.intellij.diagnostic.LoadingState;
import com.intellij.openapi.Disposable;
import com.intellij.openapi.diagnostic.Logger;
import com.intellij.openapi.progress.ProcessCanceledException;
import com.intellij.openapi.progress.ProgressIndicatorProvider;
import com.intellij.openapi.util.Disposer;
import com.intellij.openapi.util.registry.Registry;
import com.intellij.util.containers.CollectionFactory;
import org.jetbrains.annotations.ApiStatus;
import org.jetbrains.annotations.NonNls;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import javax.swing.*;
import java.util.Map;
import java.util.Objects;

public final class TransactionGuardImpl extends TransactionGuard {
  private static final Logger LOG = Logger.getInstance(TransactionGuardImpl.class);

  /**
   * Remembers the value of {@link #myWritingAllowed} at the start of each modality. If writing wasn't allowed at that moment
   * (e.g. inside SwingUtilities.invokeLater), it won't be allowed for all dialogs inside such modality, even from user activity.
   */
  private final Map<ModalityState, Boolean> myWriteSafeModalities = CollectionFactory.createConcurrentWeakMap();
  private boolean myWritingAllowed;
  private boolean myErrorReported;

  public TransactionGuardImpl() {
    myWriteSafeModalities.put(ModalityState.nonModal(), true);
    myWritingAllowed = SwingUtilities.isEventDispatchThread(); // consider app startup a user activity
  }

  @Override
  public void submitTransaction(@NotNull Disposable parentDisposable,
                                @Nullable TransactionId expectedContext,
                                @NotNull Runnable transaction) {
    ModalityState modality = expectedContext == null ? ModalityState.nonModal() : ((TransactionIdImpl)expectedContext).myModality;
    Application app = ApplicationManager.getApplication();
    if (app.isWriteIntentLockAcquired() && myWritingAllowed && !ModalityState.current().dominates(modality)) {
      if (!Disposer.isDisposed(parentDisposable)) {
        transaction.run();
      }
    }
    else {
      AppUIExecutor.onWriteThread(modality).later().expireWith(parentDisposable).execute(transaction);
    }
  }

  @Override
  public void submitTransactionAndWait(final @NotNull Runnable runnable) throws ProcessCanceledException {
    Application app = ApplicationManager.getApplication();
    if (app.isWriteIntentLockAcquired()) {
      if (!myWritingAllowed) {
        @NonNls String message = "Cannot run synchronous submitTransactionAndWait from invokeLater. " +
                                 "Please use asynchronous submit*Transaction. " +
                                 "See TransactionGuard FAQ for details.\nTransaction: " + runnable;
        if (!isWriteSafeModality(ModalityState.current())) {
          message += "\nUnsafe modality: " + ModalityState.current();
        }
        LOG.error(message);
      }
      runnable.run();
      return;
    }

    if (app.isReadAccessAllowed()) {
      throw new IllegalStateException("submitTransactionAndWait should not be invoked from a read action");
    }
    ModalityState state = ModalityState.defaultModalityState();
    if (!isWriteSafeModality(state)) {
      LOG.error("Cannot run synchronous submitTransactionAndWait from a background thread created in a write-unsafe context");
    }
    app.invokeAndWait(runnable, state);
  }

  /**
   * An absolutely guru method!<p/>
   * <p>
   * Executes the given code and marks it as a user activity, to allow write actions to be run without requiring transactions.
   * This is only to be called from UI infrastructure, during InputEvent processing and wrap the point where the control
   * goes to custom input event handlers for the first time.<p/>
   * <p>
   * If you wish to invoke some actionPerformed,
   * please consider using {@code ActionManager.tryToExecute()} instead, or ensure in some other way that the action is enabled
   * and can be invoked in the current modality state.
   */
  @ApiStatus.Internal
  public void performUserActivity(Runnable activity) {
    ApplicationManager.getApplication().assertIsDispatchThread();
    performActivity(true, activity);
  }

  /**
   * An absolute guru method, only intended to be used from Swing event processing. Please consult Peter if you think you need to invoke this.
   */
  @ApiStatus.Internal
  public void performActivity(boolean userActivity, @NotNull Runnable runnable) {
    myErrorReported = false;
    boolean allowWriting = userActivity && isWriteSafeModality(ModalityState.current());
    if (myWritingAllowed == allowWriting) {
      runnable.run();
      return;
    }

    ApplicationManager.getApplication().assertIsDispatchThread();
    boolean prev = myWritingAllowed;
    myWritingAllowed = allowWriting;
    try {
      runnable.run();
    }
    finally {
      myWritingAllowed = prev;
    }
  }

  @Override
  public boolean isWritingAllowed() {
    ApplicationManager.getApplication().assertWriteIntentLockAcquired();
    return myWritingAllowed;
  }

  @Override
  public boolean isWriteSafeModality(@NotNull ModalityState state) {
    return Boolean.TRUE.equals(myWriteSafeModalities.get(state));
  }

  public void assertWriteActionAllowed() {
    ApplicationManager.getApplication().assertWriteIntentLockAcquired();
    if (!myWritingAllowed && areAssertionsEnabled() && !myErrorReported) {
      // please assign exceptions here to Peter
      LOG.error(reportWriteUnsafeContext(ModalityState.current()));
      myErrorReported = true;
    }
  }

  private static @NonNls String reportWriteUnsafeContext(@NotNull ModalityState modality) {
    return "Write-unsafe context! Model changes are allowed from write-safe contexts only. " +
           "Please ensure you're using invokeLater/invokeAndWait with a correct modality state (not \"any\"). " +
           "See TransactionGuard documentation for details." +
           "\n  current modality=" + modality;
  }

  @Override
  public void assertWriteSafeContext(@NotNull ModalityState modality) {
    if (!isWriteSafeModality(modality) && areAssertionsEnabled()) {
      // please assign exceptions here to Peter
      LOG.error(reportWriteUnsafeContext(modality));
    }
  }

  private static boolean areAssertionsEnabled() {
    return LoadingState.COMPONENTS_LOADED.isOccurred() && Registry.is("ide.require.transaction.for.model.changes", false);
  }

  @Override
  public void submitTransactionLater(final @NotNull Disposable parentDisposable, final @NotNull Runnable transaction) {
    TransactionIdImpl ctx = getContextTransaction();
    ApplicationManager.getApplication().invokeLaterOnWriteThread(transaction, ctx == null ? ModalityState.nonModal() : ctx.myModality);
  }

  @Override
  public TransactionIdImpl getContextTransaction() {
    if (ApplicationManager.getApplication().isWriteIntentLockAcquired()) {
      if (!myWritingAllowed) {
        return null;
      }
    }
    else if (ProgressIndicatorProvider.getGlobalProgressIndicator() == null) {
      return null;
    }

    ModalityState state = ModalityState.defaultModalityState();
    return isWriteSafeModality(state) ? new TransactionIdImpl(state) : null;
  }

  public void enteredModality(@NotNull ModalityState modality) {
    myWriteSafeModalities.put(modality, myWritingAllowed);
  }

  public @NotNull Runnable wrapLaterInvocation(final @NotNull Runnable runnable, @NotNull ModalityState modalityState) {
    return new Runnable() {
      @Override
      public void run() {
        if (isWriteSafeModality(modalityState)) {
          ApplicationManager.getApplication().assertWriteIntentLockAcquired();
          runWithWritingAllowed(runnable);
        }
        else {
          runnable.run();
        }
      }

      @Override
      public String toString() {
        return runnable.toString();
      }
    };
  }

  private void runWithWritingAllowed(@NotNull Runnable runnable) {
    final boolean prev = myWritingAllowed;
    myWritingAllowed = true;
    try {
      runnable.run();
    }
    finally {
      myWritingAllowed = prev;
    }
  }

  @Override
  public String toString() {
    return "TransactionGuardImpl{myWritingAllowed=" + myWritingAllowed + '}';
  }

  private static final class TransactionIdImpl implements TransactionId {
    final ModalityState myModality;

    private TransactionIdImpl(ModalityState modality) {
      myModality = modality;
    }

    @Override
    public String toString() {
      return myModality.toString();
    }

    @Override
    public boolean equals(Object o) {
      if (this == o) return true;
      if (!(o instanceof TransactionIdImpl)) return false;
      TransactionIdImpl id = (TransactionIdImpl)o;
      return Objects.equals(myModality, id.myModality);
    }

    @Override
    public int hashCode() {
      return Objects.hash(myModality);
    }
  }
}


InvocationEvent-
/*
 * Copyright (c) 1998, 2021, Oracle and/or its affiliates. All rights reserved.
 * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */

package java.awt.event;

import java.awt.AWTEvent;
import java.awt.ActiveEvent;
import java.io.Serial;

import sun.awt.AWTAccessor;

/**
 * An event which executes the {@code run()} method on a {@code Runnable
 * } when dispatched by the AWT event dispatcher thread. This class can
 * be used as a reference implementation of {@code ActiveEvent} rather
 * than declaring a new class and defining {@code dispatch()}.<p>
 *
 * Instances of this class are placed on the {@code EventQueue} by calls
 * to {@code invokeLater} and {@code invokeAndWait}. Client code
 * can use this fact to write replacement functions for {@code invokeLater
 * } and {@code invokeAndWait} without writing special-case code
 * in any {@code AWTEventListener} objects.
 * <p>
 * An unspecified behavior will be caused if the {@code id} parameter
 * of any particular {@code InvocationEvent} instance is not
 * in the range from {@code INVOCATION_FIRST} to {@code INVOCATION_LAST}.
 *
 * @author      Fred Ecks
 * @author      David Mendenhall
 *
 * @see         java.awt.ActiveEvent
 * @see         java.awt.EventQueue#invokeLater
 * @see         java.awt.EventQueue#invokeAndWait
 * @see         AWTEventListener
 *
 * @since       1.2
 */
public class InvocationEvent extends AWTEvent implements ActiveEvent {

    static {
        AWTAccessor.setInvocationEventAccessor(new AWTAccessor.InvocationEventAccessor() {
            @Override
            public void dispose(InvocationEvent invocationEvent) {
                invocationEvent.finishedDispatching(false);
            }
        });
    }

    /**
     * Marks the first integer id for the range of invocation event ids.
     */
    public static final int INVOCATION_FIRST = 1200;

    /**
     * The default id for all InvocationEvents.
     */
    public static final int INVOCATION_DEFAULT = INVOCATION_FIRST;

    /**
     * Marks the last integer id for the range of invocation event ids.
     */
    public static final int INVOCATION_LAST = INVOCATION_DEFAULT;

    /**
     * The Runnable whose run() method will be called.
     */
    @SuppressWarnings("serial") // Not statically typed as Serializable
    protected Runnable runnable;

    /**
     * The (potentially null) Object whose notifyAll() method will be called
     * immediately after the Runnable.run() method has returned or thrown an exception
     * or after the event was disposed.
     *
     * @see #isDispatched
     */
    @SuppressWarnings("serial") // Not statically typed as Serializable
    protected volatile Object notifier;

    /**
     * The (potentially null) Runnable whose run() method will be called
     * immediately after the event was dispatched or disposed.
     *
     * @see #isDispatched
     * @since 1.8
     */
    @SuppressWarnings("serial") // Not statically typed as Serializable
    private final Runnable listener;

    /**
     * Indicates whether the {@code run()} method of the {@code runnable}
     * was executed or not.
     *
     * @see #isDispatched
     * @since 1.7
     */
    private volatile boolean dispatched;

    /**
     * Set to true if dispatch() catches Throwable and stores it in the
     * exception instance variable. If false, Throwables are propagated up
     * to the EventDispatchThread's dispatch loop.
     */
    protected boolean catchExceptions;

    /**
     * The (potentially null) Exception thrown during execution of the
     * Runnable.run() method. This variable will also be null if a particular
     * instance does not catch exceptions.
     */
    private Exception exception = null;

    /**
     * The (potentially null) Throwable thrown during execution of the
     * Runnable.run() method. This variable will also be null if a particular
     * instance does not catch exceptions.
     */
    private Throwable throwable = null;

    /**
     * The timestamp of when this event occurred.
     *
     * @serial
     * @see #getWhen
     */
    private long when;

    /**
     * Use serialVersionUID from JDK 1.1 for interoperability.
     */
    @Serial
    private static final long serialVersionUID = 436056344909459450L;

    /**
     * Constructs an {@code InvocationEvent} with the specified
     * source which will execute the runnable's {@code run()}
     * method when dispatched.
     * <p>This is a convenience constructor.  An invocation of the form
     * {@code InvocationEvent(source, runnable)}
     * behaves in exactly the same way as the invocation of
     * {@link #InvocationEvent(Object, Runnable, Object, boolean)
     * InvocationEvent(source, runnable, null, false)}.
     * <p> This method throws an {@code IllegalArgumentException}
     * if {@code source} is {@code null}.
     *
     * @param source    The {@code Object} that originated the event
     * @param runnable  The {@code Runnable} whose {@code run()}
     *                  method will be executed
     * @throws IllegalArgumentException if {@code source} is null
     *
     * @see #getSource()
     * @see #InvocationEvent(Object, Runnable, Object, boolean)
     */
    public InvocationEvent(Object source, Runnable runnable) {
        this(source, INVOCATION_DEFAULT, runnable, null, null, false);
    }

    /**
     * Constructs an {@code InvocationEvent} with the specified
     * source which will execute the runnable's {@code run()}
     * method when dispatched.  If notifier is non-{@code null},
     * {@code notifyAll()} will be called on it
     * immediately after {@code run()} has returned or thrown an exception.
     * <p>An invocation of the form
     * {@code InvocationEvent(source, runnable, notifier, catchThrowables)}
     * behaves in exactly the same way as the invocation of
     * {@link #InvocationEvent(Object, int, Runnable, Object, boolean)
     * InvocationEvent(source, InvocationEvent.INVOCATION_DEFAULT, runnable, notifier, catchThrowables)}.
     * <p>This method throws an {@code IllegalArgumentException}
     * if {@code source} is {@code null}.
     *
     * @param source            The {@code Object} that originated
     *                          the event
     * @param runnable          The {@code Runnable} whose
     *                          {@code run()} method will be
     *                          executed
     * @param notifier          The {@code Object} whose {@code notifyAll}
     *                          method will be called after
     *                          {@code Runnable.run} has returned or
     *                          thrown an exception or after the event was
     *                          disposed
     * @param catchThrowables   Specifies whether {@code dispatch}
     *                          should catch Throwable when executing
     *                          the {@code Runnable}'s {@code run()}
     *                          method, or should instead propagate those
     *                          Throwables to the EventDispatchThread's
     *                          dispatch loop
     * @throws IllegalArgumentException if {@code source} is null
     *
     * @see #getSource()
     * @see     #InvocationEvent(Object, int, Runnable, Object, boolean)
     */
    public InvocationEvent(Object source, Runnable runnable, Object notifier,
                           boolean catchThrowables) {
        this(source, INVOCATION_DEFAULT, runnable, notifier, null, catchThrowables);
    }

    /**
     * Constructs an {@code InvocationEvent} with the specified
     * source which will execute the runnable's {@code run()}
     * method when dispatched.  If listener is non-{@code null},
     * {@code listener.run()} will be called immediately after
     * {@code run} has returned, thrown an exception or the event
     * was disposed.
     * <p>This method throws an {@code IllegalArgumentException}
     * if {@code source} is {@code null}.
     *
     * @param source            The {@code Object} that originated
     *                          the event
     * @param runnable          The {@code Runnable} whose
     *                          {@code run()} method will be
     *                          executed
     * @param listener          The {@code Runnable} whose
     *                          {@code run()} method will be called
     *                          after the {@code InvocationEvent}
     *                          was dispatched or disposed
     * @param catchThrowables   Specifies whether {@code dispatch}
     *                          should catch Throwable when executing
     *                          the {@code Runnable}'s {@code run()}
     *                          method, or should instead propagate those
     *                          Throwables to the EventDispatchThread's
     *                          dispatch loop
     * @throws IllegalArgumentException if {@code source} is null
     */
    public InvocationEvent(Object source, Runnable runnable, Runnable listener,
                           boolean catchThrowables)  {
        this(source, INVOCATION_DEFAULT, runnable, null, listener, catchThrowables);
    }

    /**
     * Constructs an {@code InvocationEvent} with the specified
     * source and ID which will execute the runnable's {@code run()}
     * method when dispatched.  If notifier is non-{@code null},
     * {@code notifyAll()} will be called on it immediately after
     * {@code run()} has returned or thrown an exception.
     * <p>This method throws an
     * {@code IllegalArgumentException} if {@code source}
     * is {@code null}.
     *
     * @param source            The {@code Object} that originated
     *                          the event
     * @param id     An integer indicating the type of event.
     *                     For information on allowable values, see
     *                     the class description for {@link InvocationEvent}
     * @param runnable          The {@code Runnable} whose
     *                          {@code run()} method will be executed
     * @param notifier          The {@code Object} whose {@code notifyAll}
     *                          method will be called after
     *                          {@code Runnable.run} has returned or
     *                          thrown an exception or after the event was
     *                          disposed
     * @param catchThrowables   Specifies whether {@code dispatch}
     *                          should catch Throwable when executing the
     *                          {@code Runnable}'s {@code run()}
     *                          method, or should instead propagate those
     *                          Throwables to the EventDispatchThread's
     *                          dispatch loop
     * @throws IllegalArgumentException if {@code source} is null
     * @see #getSource()
     * @see #getID()
     */
    protected InvocationEvent(Object source, int id, Runnable runnable,
                              Object notifier, boolean catchThrowables) {
        this(source, id, runnable, notifier, null, catchThrowables);
    }

    private InvocationEvent(Object source, int id, Runnable runnable,
                            Object notifier, Runnable listener, boolean catchThrowables) {
        super(source, id);
        this.runnable = runnable;
        this.notifier = notifier;
        this.listener = listener;
        this.catchExceptions = catchThrowables;
        this.when = System.currentTimeMillis();
    }
    /**
     * Executes the Runnable's {@code run()} method and notifies the
     * notifier (if any) when {@code run()} has returned or thrown an exception.
     *
     * @see #isDispatched
     */
    public void dispatch() {
        try {
            if (catchExceptions) {
                try {
                    runnable.run();
                }
                catch (Throwable t) {
                    if (t instanceof Exception) {
                        exception = (Exception) t;
                    }
                    throwable = t;
                }
            }
            else {
                runnable.run();
            }
        } finally {
            finishedDispatching(true);
        }
    }

    /**
     * Returns any Exception caught while executing
     * the Runnable's {@code run()} method.
     *
     * @return  A reference to the Exception if one was thrown; null if no
     *          Exception was thrown or if this InvocationEvent does not
     *          catch exceptions
     */
    public Exception getException() {
        return (catchExceptions) ? exception : null;
    }

    /**
     * Returns any Throwable caught while executing
     * the Runnable's {@code run()} method.
     *
     * @return  A reference to the Throwable if one was thrown; null if no
     *          Throwable was thrown or if this InvocationEvent does not
     *          catch Throwables
     * @since 1.5
     */
    public Throwable getThrowable() {
        return (catchExceptions) ? throwable : null;
    }

    /**
     * Returns the timestamp of when this event occurred.
     *
     * @return this event's timestamp
     * @since 1.4
     */
    public long getWhen() {
        return when;
    }

    /**
     * Returns {@code true} if the event is dispatched or any exception is
     * thrown while dispatching, {@code false} otherwise. The method should
     * be called by a waiting thread that calls the {@code notifier.wait()} method.
     * Since spurious wakeups are possible (as explained in {@link Object#wait()}),
     * this method should be used in a waiting loop to ensure that the event
     * got dispatched:
     * <pre>
     *     while (!event.isDispatched()) {
     *         notifier.wait();
     *     }
     * </pre>
     * If the waiting thread wakes up without dispatching the event,
     * the {@code isDispatched()} method returns {@code false}, and
     * the {@code while} loop executes once more, thus, causing
     * the awakened thread to revert to the waiting mode.
     * <p>
     * If the {@code notifier.notifyAll()} happens before the waiting thread
     * enters the {@code notifier.wait()} method, the {@code while} loop ensures
     * that the waiting thread will not enter the {@code notifier.wait()} method.
     * Otherwise, there is no guarantee that the waiting thread will ever be woken
     * from the wait.
     *
     * @return {@code true} if the event has been dispatched, or any exception
     * has been thrown while dispatching, {@code false} otherwise
     * @see #dispatch
     * @see #notifier
     * @see #catchExceptions
     * @since 1.7
     */
    public boolean isDispatched() {
        return dispatched;
    }

    /**
     * Called when the event was dispatched or disposed
     * @param dispatched true if the event was dispatched
     *                   false if the event was disposed
     */
    private void finishedDispatching(boolean dispatched) {
        this.dispatched = dispatched;

        if (notifier != null) {
            synchronized (notifier) {
                notifier.notifyAll();
            }
        }

        if (listener != null) {
            listener.run();
        }
    }

    /**
     * Returns a parameter string identifying this event.
     * This method is useful for event-logging and for debugging.
     *
     * @return  A string identifying the event and its attributes
     */
    public String paramString() {
        String typeStr;
        switch(id) {
            case INVOCATION_DEFAULT:
                typeStr = "INVOCATION_DEFAULT";
                break;
            default:
                typeStr = "unknown type";
        }
        return typeStr + ",runnable=" + runnable + ",notifier=" + notifier +
            ",catchExceptions=" + catchExceptions + ",when=" + when;
    }
}


EventQueue-
/*
 * Copyright (c) 1996, 2021, Oracle and/or its affiliates. All rights reserved.
 * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */

package java.awt;

import java.awt.event.*;

import java.awt.peer.ComponentPeer;

import java.lang.ref.WeakReference;
import java.lang.reflect.InvocationTargetException;

import java.security.AccessController;
import java.security.PrivilegedAction;

import java.util.EmptyStackException;

import sun.awt.*;
import sun.awt.dnd.SunDropTargetEvent;
import sun.util.logging.PlatformLogger;

import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.atomic.AtomicInteger;

import java.security.AccessControlContext;

import jdk.internal.access.SharedSecrets;
import jdk.internal.access.JavaSecurityAccess;

/**
 * {@code EventQueue} is a platform-independent class
 * that queues events, both from the underlying peer classes
 * and from trusted application classes.
 * <p>
 * It encapsulates asynchronous event dispatch machinery which
 * extracts events from the queue and dispatches them by calling
 * {@link #dispatchEvent(AWTEvent) dispatchEvent(AWTEvent)} method
 * on this {@code EventQueue} with the event to be dispatched
 * as an argument.  The particular behavior of this machinery is
 * implementation-dependent.  The only requirements are that events
 * which were actually enqueued to this queue (note that events
 * being posted to the {@code EventQueue} can be coalesced)
 * are dispatched:
 * <dl>
 *   <dt> Sequentially.
 *   <dd> That is, it is not permitted that several events from
 *        this queue are dispatched simultaneously.
 *   <dt> In the same order as they are enqueued.
 *   <dd> That is, if {@code AWTEvent}&nbsp;A is enqueued
 *        to the {@code EventQueue} before
 *        {@code AWTEvent}&nbsp;B then event B will not be
 *        dispatched before event A.
 * </dl>
 * <p>
 * Some browsers partition applets in different code bases into
 * separate contexts, and establish walls between these contexts.
 * In such a scenario, there will be one {@code EventQueue}
 * per context. Other browsers place all applets into the same
 * context, implying that there will be only a single, global
 * {@code EventQueue} for all applets. This behavior is
 * implementation-dependent.  Consult your browser's documentation
 * for more information.
 * <p>
 * For information on the threading issues of the event dispatch
 * machinery, see <a href="doc-files/AWTThreadIssues.html#Autoshutdown"
 * >AWT Threading Issues</a>.
 *
 * @author Thomas Ball
 * @author Fred Ecks
 * @author David Mendenhall
 *
 * @since       1.1
 */
public class EventQueue {
    private static final AtomicInteger threadInitNumber = new AtomicInteger();

    private static final int LOW_PRIORITY = 0;
    private static final int NORM_PRIORITY = 1;
    private static final int HIGH_PRIORITY = 2;
    private static final int ULTIMATE_PRIORITY = 3;

    private static final int NUM_PRIORITIES = ULTIMATE_PRIORITY + 1;

    /*
     * We maintain one Queue for each priority that the EventQueue supports.
     * That is, the EventQueue object is actually implemented as
     * NUM_PRIORITIES queues and all Events on a particular internal Queue
     * have identical priority. Events are pulled off the EventQueue starting
     * with the Queue of highest priority. We progress in decreasing order
     * across all Queues.
     */
    private Queue[] queues = new Queue[NUM_PRIORITIES];

    /*
     * The next EventQueue on the stack, or null if this EventQueue is
     * on the top of the stack.  If nextQueue is non-null, requests to post
     * an event are forwarded to nextQueue.
     */
    private EventQueue nextQueue;

    /*
     * The previous EventQueue on the stack, or null if this is the
     * "base" EventQueue.
     */
    private EventQueue previousQueue;

    /*
     * A single lock to synchronize the push()/pop() and related operations with
     * all the EventQueues from the AppContext. Synchronization on any particular
     * event queue(s) is not enough: we should lock the whole stack.
     */
    private final Lock pushPopLock;
    private final Condition pushPopCond;

    /*
     * Dummy runnable to wake up EDT from getNextEvent() after
     push/pop is performed
     */
    private static final Runnable dummyRunnable = new Runnable() {
        public void run() {
        }
    };

    private EventDispatchThread dispatchThread;

    private final ThreadGroup threadGroup =
        Thread.currentThread().getThreadGroup();
    private final ClassLoader classLoader =
        Thread.currentThread().getContextClassLoader();

    /*
     * The time stamp of the last dispatched InputEvent or ActionEvent.
     */
    private long mostRecentEventTime = System.currentTimeMillis();

    /*
     * The time stamp of the last KeyEvent .
     */
    private long mostRecentKeyEventTime = System.currentTimeMillis();

    /**
     * The modifiers field of the current event, if the current event is an
     * InputEvent or ActionEvent.
     */
    private WeakReference<AWTEvent> currentEvent;

    /*
     * Non-zero if a thread is waiting in getNextEvent(int) for an event of
     * a particular ID to be posted to the queue.
     */
    private volatile int waitForID;

    /*
     * AppContext corresponding to the queue.
     */
    private final AppContext appContext;

    private final String name = "AWT-EventQueue-" + threadInitNumber.getAndIncrement();

    private FwDispatcher fwDispatcher;

    private static volatile PlatformLogger eventLog;

    private static final PlatformLogger getEventLog() {
        if(eventLog == null) {
            eventLog = PlatformLogger.getLogger("java.awt.event.EventQueue");
        }
        return eventLog;
    }

    static {
        AWTAccessor.setEventQueueAccessor(
            new AWTAccessor.EventQueueAccessor() {
                public Thread getDispatchThread(EventQueue eventQueue) {
                    return eventQueue.getDispatchThread();
                }
                public boolean isDispatchThreadImpl(EventQueue eventQueue) {
                    return eventQueue.isDispatchThreadImpl();
                }
                public void removeSourceEvents(EventQueue eventQueue,
                                               Object source,
                                               boolean removeAllEvents)
                {
                    eventQueue.removeSourceEvents(source, removeAllEvents);
                }
                public boolean noEvents(EventQueue eventQueue) {
                    return eventQueue.noEvents();
                }
                public void wakeup(EventQueue eventQueue, boolean isShutdown) {
                    eventQueue.wakeup(isShutdown);
                }
                public void invokeAndWait(Object source, Runnable r)
                    throws InterruptedException, InvocationTargetException
                {
                    EventQueue.invokeAndWait(source, r);
                }
                public void setFwDispatcher(EventQueue eventQueue,
                                            FwDispatcher dispatcher) {
                    eventQueue.setFwDispatcher(dispatcher);
                }

                @Override
                public long getMostRecentEventTime(EventQueue eventQueue) {
                    return eventQueue.getMostRecentEventTimeImpl();
                }
            });
    }

    @SuppressWarnings("removal")
    private static boolean fxAppThreadIsDispatchThread =
            AccessController.doPrivileged(new PrivilegedAction<Boolean>() {
                public Boolean run() {
                    return "true".equals(System.getProperty("javafx.embed.singleThread"));
                }
            });

    /**
     * Initializes a new instance of {@code EventQueue}.
     */
    public EventQueue() {
        for (int i = 0; i < NUM_PRIORITIES; i++) {
            queues[i] = new Queue();
        }
        /*
         * NOTE: if you ever have to start the associated event dispatch
         * thread at this point, be aware of the following problem:
         * If this EventQueue instance is created in
         * SunToolkit.createNewAppContext() the started dispatch thread
         * may call AppContext.getAppContext() before createNewAppContext()
         * completes thus causing mess in thread group to appcontext mapping.
         */

        appContext = AppContext.getAppContext();
        pushPopLock = (Lock)appContext.get(AppContext.EVENT_QUEUE_LOCK_KEY);
        pushPopCond = (Condition)appContext.get(AppContext.EVENT_QUEUE_COND_KEY);
    }

    /**
     * Posts a 1.1-style event to the {@code EventQueue}.
     * If there is an existing event on the queue with the same ID
     * and event source, the source {@code Component}'s
     * {@code coalesceEvents} method will be called.
     *
     * @param theEvent an instance of {@code java.awt.AWTEvent},
     *          or a subclass of it
     * @throws NullPointerException if {@code theEvent} is {@code null}
     */
    public void postEvent(AWTEvent theEvent) {
        SunToolkit.flushPendingEvents(appContext);
        postEventPrivate(theEvent);
    }

    /**
     * Posts a 1.1-style event to the {@code EventQueue}.
     * If there is an existing event on the queue with the same ID
     * and event source, the source {@code Component}'s
     * {@code coalesceEvents} method will be called.
     *
     * @param theEvent an instance of {@code java.awt.AWTEvent},
     *          or a subclass of it
     */
    private void postEventPrivate(AWTEvent theEvent) {
        theEvent.isPosted = true;
        pushPopLock.lock();
        try {
            if (nextQueue != null) {
                // Forward the event to the top of EventQueue stack
                nextQueue.postEventPrivate(theEvent);
                return;
            }
            if (dispatchThread == null) {
                if (theEvent.getSource() == AWTAutoShutdown.getInstance()) {
                    return;
                } else {
                    initDispatchThread();
                }
            }
            postEvent(theEvent, getPriority(theEvent));
        } finally {
            pushPopLock.unlock();
        }
    }

    private static int getPriority(AWTEvent theEvent) {
        if (theEvent instanceof PeerEvent) {
            PeerEvent peerEvent = (PeerEvent)theEvent;
            if ((peerEvent.getFlags() & PeerEvent.ULTIMATE_PRIORITY_EVENT) != 0) {
                return ULTIMATE_PRIORITY;
            }
            if ((peerEvent.getFlags() & PeerEvent.PRIORITY_EVENT) != 0) {
                return HIGH_PRIORITY;
            }
            if ((peerEvent.getFlags() & PeerEvent.LOW_PRIORITY_EVENT) != 0) {
                return LOW_PRIORITY;
            }
        }
        int id = theEvent.getID();
        if ((id >= PaintEvent.PAINT_FIRST) && (id <= PaintEvent.PAINT_LAST)) {
            return LOW_PRIORITY;
        }
        return NORM_PRIORITY;
    }

    /**
     * Posts the event to the internal Queue of specified priority,
     * coalescing as appropriate.
     *
     * @param theEvent an instance of {@code java.awt.AWTEvent},
     *          or a subclass of it
     * @param priority  the desired priority of the event
     */
    private void postEvent(AWTEvent theEvent, int priority) {
        if (coalesceEvent(theEvent, priority)) {
            return;
        }

        EventQueueItem newItem = new EventQueueItem(theEvent);

        cacheEQItem(newItem);

        boolean notifyID = (theEvent.getID() == this.waitForID);

        if (queues[priority].head == null) {
            boolean shouldNotify = noEvents();
            queues[priority].head = queues[priority].tail = newItem;

            if (shouldNotify) {
                if (theEvent.getSource() != AWTAutoShutdown.getInstance()) {
                    AWTAutoShutdown.getInstance().notifyThreadBusy(dispatchThread);
                }
                pushPopCond.signalAll();
            } else if (notifyID) {
                pushPopCond.signalAll();
            }
        } else {
            // The event was not coalesced or has non-Component source.
            // Insert it at the end of the appropriate Queue.
            queues[priority].tail.next = newItem;
            queues[priority].tail = newItem;
            if (notifyID) {
                pushPopCond.signalAll();
            }
        }
    }

    private boolean coalescePaintEvent(PaintEvent e) {
        ComponentPeer sourcePeer = ((Component)e.getSource()).peer;
        if (sourcePeer != null) {
            sourcePeer.coalescePaintEvent(e);
        }
        EventQueueItem[] cache = ((Component)e.getSource()).eventCache;
        if (cache == null) {
            return false;
        }
        int index = eventToCacheIndex(e);

        if (index != -1 && cache[index] != null) {
            PaintEvent merged = mergePaintEvents(e, (PaintEvent)cache[index].event);
            if (merged != null) {
                cache[index].event = merged;
                return true;
            }
        }
        return false;
    }

    private PaintEvent mergePaintEvents(PaintEvent a, PaintEvent b) {
        Rectangle aRect = a.getUpdateRect();
        Rectangle bRect = b.getUpdateRect();
        if (bRect.contains(aRect)) {
            return b;
        }
        if (aRect.contains(bRect)) {
            return a;
        }
        return null;
    }

    private boolean coalesceMouseEvent(MouseEvent e) {
        EventQueueItem[] cache = ((Component)e.getSource()).eventCache;
        if (cache == null) {
            return false;
        }
        int index = eventToCacheIndex(e);
        if (index != -1 && cache[index] != null) {
            cache[index].event = e;
            return true;
        }
        return false;
    }

    private boolean coalescePeerEvent(PeerEvent e) {
        EventQueueItem[] cache = ((Component)e.getSource()).eventCache;
        if (cache == null) {
            return false;
        }
        int index = eventToCacheIndex(e);
        if (index != -1 && cache[index] != null) {
            e = e.coalesceEvents((PeerEvent)cache[index].event);
            if (e != null) {
                cache[index].event = e;
                return true;
            } else {
                cache[index] = null;
            }
        }
        return false;
    }

    /*
     * Should avoid of calling this method by any means
     * as it's working time is dependent on EQ length.
     * In the worst case this method alone can slow down the entire application
     * 10 times by stalling the Event processing.
     * Only here by backward compatibility reasons.
     */
    private boolean coalesceOtherEvent(AWTEvent e, int priority) {
        int id = e.getID();
        Component source = (Component)e.getSource();
        for (EventQueueItem entry = queues[priority].head;
            entry != null; entry = entry.next)
        {
            // Give Component.coalesceEvents a chance
            if (entry.event.getSource() == source && entry.event.getID() == id) {
                AWTEvent coalescedEvent = source.coalesceEvents(
                    entry.event, e);
                if (coalescedEvent != null) {
                    entry.event = coalescedEvent;
                    return true;
                }
            }
        }
        return false;
    }

    private boolean coalesceEvent(AWTEvent e, int priority) {
        if (!(e.getSource() instanceof Component)) {
            return false;
        }
        if (e instanceof PeerEvent) {
            return coalescePeerEvent((PeerEvent)e);
        }
        // The worst case
        if (((Component)e.getSource()).isCoalescingEnabled()
            && coalesceOtherEvent(e, priority))
        {
            return true;
        }
        if (e instanceof PaintEvent) {
            return coalescePaintEvent((PaintEvent)e);
        }
        if (e instanceof MouseEvent) {
            return coalesceMouseEvent((MouseEvent)e);
        }
        return false;
    }

    private void cacheEQItem(EventQueueItem entry) {
        int index = eventToCacheIndex(entry.event);
        if (index != -1 && entry.event.getSource() instanceof Component) {
            Component source = (Component)entry.event.getSource();
            if (source.eventCache == null) {
                source.eventCache = new EventQueueItem[CACHE_LENGTH];
            }
            source.eventCache[index] = entry;
        }
    }

    private void uncacheEQItem(EventQueueItem entry) {
        int index = eventToCacheIndex(entry.event);
        if (index != -1 && entry.event.getSource() instanceof Component) {
            Component source = (Component)entry.event.getSource();
            if (source.eventCache == null) {
                return;
            }
            source.eventCache[index] = null;
        }
    }

    private static final int PAINT = 0;
    private static final int UPDATE = 1;
    private static final int MOVE = 2;
    private static final int DRAG = 3;
    private static final int PEER = 4;
    private static final int CACHE_LENGTH = 5;

    private static int eventToCacheIndex(AWTEvent e) {
        switch(e.getID()) {
        case PaintEvent.PAINT:
            return PAINT;
        case PaintEvent.UPDATE:
            return UPDATE;
        case MouseEvent.MOUSE_MOVED:
            return MOVE;
        case MouseEvent.MOUSE_DRAGGED:
            // Return -1 for SunDropTargetEvent since they are usually synchronous
            // and we don't want to skip them by coalescing with MouseEvent or other drag events
            return e instanceof SunDropTargetEvent ? -1 : DRAG;
        default:
            return e instanceof PeerEvent ? PEER : -1;
        }
    }

    /**
     * Returns whether an event is pending on any of the separate
     * Queues.
     * @return whether an event is pending on any of the separate Queues
     */
    private boolean noEvents() {
        for (int i = 0; i < NUM_PRIORITIES; i++) {
            if (queues[i].head != null) {
                return false;
            }
        }

        return true;
    }

    /**
     * Removes an event from the {@code EventQueue} and
     * returns it.  This method will block until an event has
     * been posted by another thread.
     * @return the next {@code AWTEvent}
     * @throws InterruptedException
     *            if any thread has interrupted this thread
     */
    public AWTEvent getNextEvent() throws InterruptedException {
        do {
            /*
             * SunToolkit.flushPendingEvents must be called outside
             * of the synchronized block to avoid deadlock when
             * event queues are nested with push()/pop().
             */
            SunToolkit.flushPendingEvents(appContext);
            pushPopLock.lock();
            try {
                AWTEvent event = getNextEventPrivate();
                if (event != null) {
                    return event;
                }
                AWTAutoShutdown.getInstance().notifyThreadFree(dispatchThread);
                pushPopCond.await();
            } finally {
                pushPopLock.unlock();
            }
        } while(true);
    }

    /*
     * Must be called under the lock. Doesn't call flushPendingEvents()
     */
    AWTEvent getNextEventPrivate() throws InterruptedException {
        for (int i = NUM_PRIORITIES - 1; i >= 0; i--) {
            if (queues[i].head != null) {
                EventQueueItem entry = queues[i].head;
                queues[i].head = entry.next;
                if (entry.next == null) {
                    queues[i].tail = null;
                }
                uncacheEQItem(entry);
                return entry.event;
            }
        }
        return null;
    }

    AWTEvent getNextEvent(int id) throws InterruptedException {
        do {
            /*
             * SunToolkit.flushPendingEvents must be called outside
             * of the synchronized block to avoid deadlock when
             * event queues are nested with push()/pop().
             */
            SunToolkit.flushPendingEvents(appContext);
            pushPopLock.lock();
            try {
                for (int i = 0; i < NUM_PRIORITIES; i++) {
                    for (EventQueueItem entry = queues[i].head, prev = null;
                         entry != null; prev = entry, entry = entry.next)
                    {
                        if (entry.event.getID() == id) {
                            if (prev == null) {
                                queues[i].head = entry.next;
                            } else {
                                prev.next = entry.next;
                            }
                            if (queues[i].tail == entry) {
                                queues[i].tail = prev;
                            }
                            uncacheEQItem(entry);
                            return entry.event;
                        }
                    }
                }
                waitForID = id;
                pushPopCond.await();
                waitForID = 0;
            } finally {
                pushPopLock.unlock();
            }
        } while(true);
    }

    /**
     * Returns the first event on the {@code EventQueue}
     * without removing it.
     * @return the first event
     */
    public AWTEvent peekEvent() {
        pushPopLock.lock();
        try {
            for (int i = NUM_PRIORITIES - 1; i >= 0; i--) {
                if (queues[i].head != null) {
                    return queues[i].head.event;
                }
            }
        } finally {
            pushPopLock.unlock();
        }

        return null;
    }

    /**
     * Returns the first event with the specified id, if any.
     * @param id the id of the type of event desired
     * @return the first event of the specified id or {@code null}
     *    if there is no such event
     */
    public AWTEvent peekEvent(int id) {
        pushPopLock.lock();
        try {
            for (int i = NUM_PRIORITIES - 1; i >= 0; i--) {
                EventQueueItem q = queues[i].head;
                for (; q != null; q = q.next) {
                    if (q.event.getID() == id) {
                        return q.event;
                    }
                }
            }
        } finally {
            pushPopLock.unlock();
        }

        return null;
    }

    private static final JavaSecurityAccess javaSecurityAccess =
        SharedSecrets.getJavaSecurityAccess();

    /**
     * Dispatches an event. The manner in which the event is
     * dispatched depends upon the type of the event and the
     * type of the event's source object:
     *
     * <table class="striped">
     * <caption>Event types, source types, and dispatch methods</caption>
     * <thead>
     *   <tr>
     *     <th scope="col">Event Type
     *     <th scope="col">Source Type
     *     <th scope="col">Dispatched To
     * </thead>
     * <tbody>
     *   <tr>
     *     <th scope="row">ActiveEvent
     *     <td>Any
     *     <td>event.dispatch()
     *   <tr>
     *     <th scope="row">Other
     *     <td>Component
     *     <td>source.dispatchEvent(AWTEvent)
     *   <tr>
     *     <th scope="row">Other
     *     <td>MenuComponent
     *     <td>source.dispatchEvent(AWTEvent)
     *   <tr>
     *     <th scope="row">Other
     *     <td>Other
     *     <td>No action (ignored)
     * </tbody>
     * </table>
     *
     * @param event an instance of {@code java.awt.AWTEvent},
     *          or a subclass of it
     * @throws NullPointerException if {@code event} is {@code null}
     * @since           1.2
     */
    protected void dispatchEvent(final AWTEvent event) {
        final Object src = event.getSource();
        final PrivilegedAction<Void> action = new PrivilegedAction<Void>() {
            public Void run() {
                // In case fwDispatcher is installed and we're already on the
                // dispatch thread (e.g. performing DefaultKeyboardFocusManager.sendMessage),
                // dispatch the event straight away.
                if (fwDispatcher == null || isDispatchThreadImpl()) {
                    dispatchEventImpl(event, src);
                } else {
                    fwDispatcher.scheduleDispatch(new Runnable() {
                        @Override
                        public void run() {
                            if (dispatchThread.filterAndCheckEvent(event)) {
                                dispatchEventImpl(event, src);
                            }
                        }
                    });
                }
                return null;
            }
        };

        @SuppressWarnings("removal")
        final AccessControlContext stack = AccessController.getContext();
        @SuppressWarnings("removal")
        final AccessControlContext srcAcc = getAccessControlContextFrom(src);
        @SuppressWarnings("removal")
        final AccessControlContext eventAcc = event.getAccessControlContext();
        if (srcAcc == null) {
            javaSecurityAccess.doIntersectionPrivilege(action, stack, eventAcc);
        } else {
            javaSecurityAccess.doIntersectionPrivilege(
                new PrivilegedAction<Void>() {
                    public Void run() {
                        javaSecurityAccess.doIntersectionPrivilege(action, eventAcc);
                        return null;
                    }
                }, stack, srcAcc);
        }
    }

    @SuppressWarnings("removal")
    private static AccessControlContext getAccessControlContextFrom(Object src) {
        return src instanceof Component ?
            ((Component)src).getAccessControlContext() :
            src instanceof MenuComponent ?
                ((MenuComponent)src).getAccessControlContext() :
                src instanceof TrayIcon ?
                    ((TrayIcon)src).getAccessControlContext() :
                    null;
    }

    /**
     * Called from dispatchEvent() under a correct AccessControlContext
     */
    private void dispatchEventImpl(final AWTEvent event, final Object src) {
        event.isPosted = true;
        if (event instanceof ActiveEvent) {
            // This could become the sole method of dispatching in time.
            setCurrentEventAndMostRecentTimeImpl(event);
            ((ActiveEvent)event).dispatch();
        } else if (src instanceof Component) {
            ((Component)src).dispatchEvent(event);
            event.dispatched();
        } else if (src instanceof MenuComponent) {
            ((MenuComponent)src).dispatchEvent(event);
        } else if (src instanceof TrayIcon) {
            ((TrayIcon)src).dispatchEvent(event);
        } else if (src instanceof AWTAutoShutdown) {
            if (noEvents()) {
                dispatchThread.stopDispatching();
            }
        } else {
            if (getEventLog().isLoggable(PlatformLogger.Level.FINE)) {
                getEventLog().fine("Unable to dispatch event: " + event);
            }
        }
    }

    /**
     * Returns the timestamp of the most recent event that had a timestamp, and
     * that was dispatched from the {@code EventQueue} associated with the
     * calling thread. If an event with a timestamp is currently being
     * dispatched, its timestamp will be returned. If no events have yet
     * been dispatched, the EventQueue's initialization time will be
     * returned instead.In the current version of
     * the JDK, only {@code InputEvent}s,
     * {@code ActionEvent}s, and {@code InvocationEvent}s have
     * timestamps; however, future versions of the JDK may add timestamps to
     * additional event types. Note that this method should only be invoked
     * from an application's {@link #isDispatchThread event dispatching thread}.
     * If this method is
     * invoked from another thread, the current system time (as reported by
     * {@code System.currentTimeMillis()}) will be returned instead.
     *
     * @return the timestamp of the last {@code InputEvent},
     *         {@code ActionEvent}, or {@code InvocationEvent} to be
     *         dispatched, or {@code System.currentTimeMillis()} if this
     *         method is invoked on a thread other than an event dispatching
     *         thread
     * @see java.awt.event.InputEvent#getWhen
     * @see java.awt.event.ActionEvent#getWhen
     * @see java.awt.event.InvocationEvent#getWhen
     * @see #isDispatchThread
     *
     * @since 1.4
     */
    public static long getMostRecentEventTime() {
        return Toolkit.getEventQueue().getMostRecentEventTimeImpl();
    }
    private long getMostRecentEventTimeImpl() {
        pushPopLock.lock();
        try {
            return (Thread.currentThread() == dispatchThread)
                ? mostRecentEventTime
                : System.currentTimeMillis();
        } finally {
            pushPopLock.unlock();
        }
    }

    /**
     * @return most recent event time on all threads.
     */
    long getMostRecentEventTimeEx() {
        pushPopLock.lock();
        try {
            return mostRecentEventTime;
        } finally {
            pushPopLock.unlock();
        }
    }

    /**
     * Returns the event currently being dispatched by the
     * {@code EventQueue} associated with the calling thread. This is
     * useful if a method needs access to the event, but was not designed to
     * receive a reference to it as an argument. Note that this method should
     * only be invoked from an application's event dispatching thread. If this
     * method is invoked from another thread, null will be returned.
     *
     * @return the event currently being dispatched, or null if this method is
     *         invoked on a thread other than an event dispatching thread
     * @since 1.4
     */
    public static AWTEvent getCurrentEvent() {
        return Toolkit.getEventQueue().getCurrentEventImpl();
    }
    private AWTEvent getCurrentEventImpl() {
        pushPopLock.lock();
        try {
            if (Thread.currentThread() == dispatchThread
                    || fxAppThreadIsDispatchThread) {
                return (currentEvent != null)
                        ? currentEvent.get()
                        : null;
            }
            return null;
        } finally {
            pushPopLock.unlock();
        }
    }

    /**
     * Replaces the existing {@code EventQueue} with the specified one.
     * Any pending events are transferred to the new {@code EventQueue}
     * for processing by it.
     *
     * @param newEventQueue an {@code EventQueue}
     *          (or subclass thereof) instance to be use
     * @see      java.awt.EventQueue#pop
     * @throws NullPointerException if {@code newEventQueue} is {@code null}
     * @since           1.2
     */
    public void push(EventQueue newEventQueue) {
        if (getEventLog().isLoggable(PlatformLogger.Level.FINE)) {
            getEventLog().fine("EventQueue.push(" + newEventQueue + ")");
        }

        pushPopLock.lock();
        try {
            EventQueue topQueue = this;
            while (topQueue.nextQueue != null) {
                topQueue = topQueue.nextQueue;
            }
            if (topQueue.fwDispatcher != null) {
                throw new RuntimeException("push() to queue with fwDispatcher");
            }
            if ((topQueue.dispatchThread != null) &&
                (topQueue.dispatchThread.getEventQueue() == this))
            {
                newEventQueue.dispatchThread = topQueue.dispatchThread;
                topQueue.dispatchThread.setEventQueue(newEventQueue);
            }

            // Transfer all events forward to new EventQueue.
            while (topQueue.peekEvent() != null) {
                try {
                    // Use getNextEventPrivate() as it doesn't call flushPendingEvents()
                    newEventQueue.postEventPrivate(topQueue.getNextEventPrivate());
                } catch (InterruptedException ie) {
                    if (getEventLog().isLoggable(PlatformLogger.Level.FINE)) {
                        getEventLog().fine("Interrupted push", ie);
                    }
                }
            }

            if (topQueue.dispatchThread != null) {
                // Wake up EDT waiting in getNextEvent(), so it can
                // pick up a new EventQueue. Post the waking event before
                // topQueue.nextQueue is assigned, otherwise the event would
                // go newEventQueue
                topQueue.postEventPrivate(new InvocationEvent(topQueue, dummyRunnable));
            }

            newEventQueue.previousQueue = topQueue;
            topQueue.nextQueue = newEventQueue;

            if (appContext.get(AppContext.EVENT_QUEUE_KEY) == topQueue) {
                appContext.put(AppContext.EVENT_QUEUE_KEY, newEventQueue);
            }

            pushPopCond.signalAll();
        } finally {
            pushPopLock.unlock();
        }
    }

    /**
     * Stops dispatching events using this {@code EventQueue}.
     * Any pending events are transferred to the previous
     * {@code EventQueue} for processing.
     * <p>
     * Warning: To avoid deadlock, do not declare this method
     * synchronized in a subclass.
     *
     * @throws EmptyStackException if no previous push was made
     *  on this {@code EventQueue}
     * @see      java.awt.EventQueue#push
     * @since           1.2
     */
    protected void pop() throws EmptyStackException {
        if (getEventLog().isLoggable(PlatformLogger.Level.FINE)) {
            getEventLog().fine("EventQueue.pop(" + this + ")");
        }

        pushPopLock.lock();
        try {
            EventQueue topQueue = this;
            while (topQueue.nextQueue != null) {
                topQueue = topQueue.nextQueue;
            }
            EventQueue prevQueue = topQueue.previousQueue;
            if (prevQueue == null) {
                throw new EmptyStackException();
            }

            topQueue.previousQueue = null;
            prevQueue.nextQueue = null;

            // Transfer all events back to previous EventQueue.
            while (topQueue.peekEvent() != null) {
                try {
                    prevQueue.postEventPrivate(topQueue.getNextEventPrivate());
                } catch (InterruptedException ie) {
                    if (getEventLog().isLoggable(PlatformLogger.Level.FINE)) {
                        getEventLog().fine("Interrupted pop", ie);
                    }
                }
            }

            if ((topQueue.dispatchThread != null) &&
                (topQueue.dispatchThread.getEventQueue() == this))
            {
                prevQueue.dispatchThread = topQueue.dispatchThread;
                topQueue.dispatchThread.setEventQueue(prevQueue);
            }

            if (appContext.get(AppContext.EVENT_QUEUE_KEY) == this) {
                appContext.put(AppContext.EVENT_QUEUE_KEY, prevQueue);
            }

            // Wake up EDT waiting in getNextEvent(), so it can
            // pick up a new EventQueue
            topQueue.postEventPrivate(new InvocationEvent(topQueue, dummyRunnable));

            pushPopCond.signalAll();
        } finally {
            pushPopLock.unlock();
        }
    }

    /**
     * Creates a new {@code secondary loop} associated with this
     * event queue. Use the {@link SecondaryLoop#enter} and
     * {@link SecondaryLoop#exit} methods to start and stop the
     * event loop and dispatch the events from this queue.
     *
     * @return secondaryLoop A new secondary loop object, which can
     *                       be used to launch a new nested event
     *                       loop and dispatch events from this queue
     *
     * @see SecondaryLoop#enter
     * @see SecondaryLoop#exit
     *
     * @since 1.7
     */
    public SecondaryLoop createSecondaryLoop() {
        return createSecondaryLoop(null, null, 0);
    }

    private class FwSecondaryLoopWrapper implements SecondaryLoop {
        private final SecondaryLoop loop;
        private final EventFilter filter;

        public FwSecondaryLoopWrapper(SecondaryLoop loop, EventFilter filter) {
            this.loop = loop;
            this.filter = filter;
        }

        @Override
        public boolean enter() {
            if (filter != null) {
                dispatchThread.addEventFilter(filter);
            }
            return loop.enter();
        }

        @Override
        public boolean exit() {
            if (filter != null) {
                dispatchThread.removeEventFilter(filter);
            }
            return loop.exit();
        }
    }

    SecondaryLoop createSecondaryLoop(Conditional cond, EventFilter filter, long interval) {
        pushPopLock.lock();
        try {
            if (nextQueue != null) {
                // Forward the request to the top of EventQueue stack
                return nextQueue.createSecondaryLoop(cond, filter, interval);
            }
            if (fwDispatcher != null) {
                return new FwSecondaryLoopWrapper(fwDispatcher.createSecondaryLoop(), filter);
            }
            if (dispatchThread == null) {
                initDispatchThread();
            }
            return new WaitDispatchSupport(dispatchThread, cond, filter, interval);
        } finally {
            pushPopLock.unlock();
        }
    }

    /**
     * Returns true if the calling thread is
     * {@link Toolkit#getSystemEventQueue the current AWT EventQueue}'s
     * dispatch thread. Use this method to ensure that a particular
     * task is being executed (or not being) there.
     * <p>
     * Note: use the {@link #invokeLater} or {@link #invokeAndWait}
     * methods to execute a task in
     * {@link Toolkit#getSystemEventQueue the current AWT EventQueue}'s
     * dispatch thread.
     *
     * @return true if running in
     * {@link Toolkit#getSystemEventQueue the current AWT EventQueue}'s
     * dispatch thread
     * @see             #invokeLater
     * @see             #invokeAndWait
     * @see             Toolkit#getSystemEventQueue
     * @since           1.2
     */
    public static boolean isDispatchThread() {
        EventQueue eq = Toolkit.getEventQueue();
        return eq.isDispatchThreadImpl();
    }

    final boolean isDispatchThreadImpl() {
        EventQueue eq = this;
        pushPopLock.lock();
        try {
            EventQueue next = eq.nextQueue;
            while (next != null) {
                eq = next;
                next = eq.nextQueue;
            }
            if (eq.fwDispatcher != null) {
                return eq.fwDispatcher.isDispatchThread();
            }
            return (Thread.currentThread() == eq.dispatchThread);
        } finally {
            pushPopLock.unlock();
        }
    }

    @SuppressWarnings({"deprecation", "removal"})
    final void initDispatchThread() {
        pushPopLock.lock();
        try {
            if (dispatchThread == null && !threadGroup.isDestroyed() && !appContext.isDisposed()) {
                dispatchThread = AccessController.doPrivileged(
                    new PrivilegedAction<EventDispatchThread>() {
                        public EventDispatchThread run() {
                            EventDispatchThread t =
                                new EventDispatchThread(threadGroup,
                                                        name,
                                                        EventQueue.this);
                            t.setContextClassLoader(classLoader);
                            t.setPriority(Thread.NORM_PRIORITY + 1);
                            t.setDaemon(false);
                            AWTAutoShutdown.getInstance().notifyThreadBusy(t);
                            return t;
                        }
                    }
                );
                dispatchThread.start();
            }
        } finally {
            pushPopLock.unlock();
        }
    }

    final void detachDispatchThread(EventDispatchThread edt) {
        /*
         * Minimize discard possibility for non-posted events
         */
        SunToolkit.flushPendingEvents(appContext);
        /*
         * This synchronized block is to secure that the event dispatch
         * thread won't die in the middle of posting a new event to the
         * associated event queue. It is important because we notify
         * that the event dispatch thread is busy after posting a new event
         * to its queue, so the EventQueue.dispatchThread reference must
         * be valid at that point.
         */
        pushPopLock.lock();
        try {
            if (edt == dispatchThread) {
                dispatchThread = null;
            }
            AWTAutoShutdown.getInstance().notifyThreadFree(edt);
            /*
             * Event was posted after EDT events pumping had stopped, so start
             * another EDT to handle this event
             */
            if (peekEvent() != null) {
                initDispatchThread();
            }
        } finally {
            pushPopLock.unlock();
        }
    }

    /*
     * Gets the {@code EventDispatchThread} for this
     * {@code EventQueue}.
     * @return the event dispatch thread associated with this event queue
     *         or {@code null} if this event queue doesn't have a
     *         working thread associated with it
     * @see    java.awt.EventQueue#initDispatchThread
     * @see    java.awt.EventQueue#detachDispatchThread
     */
    final EventDispatchThread getDispatchThread() {
        pushPopLock.lock();
        try {
            return dispatchThread;
        } finally {
            pushPopLock.unlock();
        }
    }

    /*
     * Removes any pending events for the specified source object.
     * If removeAllEvents parameter is {@code true} then all
     * events for the specified source object are removed, if it
     * is {@code false} then {@code SequencedEvent}, {@code SentEvent},
     * {@code FocusEvent}, {@code WindowEvent}, {@code KeyEvent},
     * and {@code InputMethodEvent} are kept in the queue, but all other
     * events are removed.
     *
     * This method is normally called by the source's
     * {@code removeNotify} method.
     */
    final void removeSourceEvents(Object source, boolean removeAllEvents) {
        SunToolkit.flushPendingEvents(appContext);
        pushPopLock.lock();
        try {
            for (int i = 0; i < NUM_PRIORITIES; i++) {
                EventQueueItem entry = queues[i].head;
                EventQueueItem prev = null;
                while (entry != null) {
                    if ((entry.event.getSource() == source)
                        && (removeAllEvents
                            || ! (entry.event instanceof SequencedEvent
                                  || entry.event instanceof SentEvent
                                  || entry.event instanceof FocusEvent
                                  || entry.event instanceof WindowEvent
                                  || entry.event instanceof KeyEvent
                                  || entry.event instanceof InputMethodEvent)))
                    {
                        if (entry.event instanceof SequencedEvent) {
                            ((SequencedEvent)entry.event).dispose();
                        }
                        if (entry.event instanceof SentEvent) {
                            ((SentEvent)entry.event).dispose();
                        }
                        if (entry.event instanceof InvocationEvent) {
                            AWTAccessor.getInvocationEventAccessor()
                                    .dispose((InvocationEvent)entry.event);
                        }
                        if (entry.event instanceof SunDropTargetEvent) {
                            ((SunDropTargetEvent)entry.event).dispose();
                        }
                        if (prev == null) {
                            queues[i].head = entry.next;
                        } else {
                            prev.next = entry.next;
                        }
                        uncacheEQItem(entry);
                    } else {
                        prev = entry;
                    }
                    entry = entry.next;
                }
                queues[i].tail = prev;
            }
        } finally {
            pushPopLock.unlock();
        }
    }

    synchronized long getMostRecentKeyEventTime() {
        pushPopLock.lock();
        try {
            return mostRecentKeyEventTime;
        } finally {
            pushPopLock.unlock();
        }
    }

    static void setCurrentEventAndMostRecentTime(AWTEvent e) {
        Toolkit.getEventQueue().setCurrentEventAndMostRecentTimeImpl(e);
    }
    private void setCurrentEventAndMostRecentTimeImpl(AWTEvent e) {
        pushPopLock.lock();
        try {
            if (!fxAppThreadIsDispatchThread && Thread.currentThread() != dispatchThread) {
                return;
            }

            currentEvent = new WeakReference<>(e);

            // This series of 'instanceof' checks should be replaced with a
            // polymorphic type (for example, an interface which declares a
            // getWhen() method). However, this would require us to make such
            // a type public, or to place it in sun.awt. Both of these approaches
            // have been frowned upon. So for now, we hack.
            //
            // In tiger, we will probably give timestamps to all events, so this
            // will no longer be an issue.
            long mostRecentEventTime2 = Long.MIN_VALUE;
            if (e instanceof InputEvent) {
                InputEvent ie = (InputEvent)e;
                mostRecentEventTime2 = ie.getWhen();
                if (e instanceof KeyEvent) {
                    mostRecentKeyEventTime = ie.getWhen();
                }
            } else if (e instanceof InputMethodEvent) {
                InputMethodEvent ime = (InputMethodEvent)e;
                mostRecentEventTime2 = ime.getWhen();
            } else if (e instanceof ActionEvent) {
                ActionEvent ae = (ActionEvent)e;
                mostRecentEventTime2 = ae.getWhen();
            } else if (e instanceof InvocationEvent) {
                InvocationEvent ie = (InvocationEvent)e;
                mostRecentEventTime2 = ie.getWhen();
            }
            mostRecentEventTime = Math.max(mostRecentEventTime, mostRecentEventTime2);
        } finally {
            pushPopLock.unlock();
        }
    }

    /**
     * Causes {@code runnable} to have its {@code run}
     * method called in the {@link #isDispatchThread dispatch thread} of
     * {@link Toolkit#getSystemEventQueue the system EventQueue}.
     * This will happen after all pending events are processed.
     *
     * @param runnable  the {@code Runnable} whose {@code run}
     *                  method should be executed
     *                  asynchronously in the
     *                  {@link #isDispatchThread event dispatch thread}
     *                  of {@link Toolkit#getSystemEventQueue the system EventQueue}
     * @see             #invokeAndWait
     * @see             Toolkit#getSystemEventQueue
     * @see             #isDispatchThread
     * @since           1.2
     */
    public static void invokeLater(Runnable runnable) {
        Toolkit.getEventQueue().postEvent(
            new InvocationEvent(Toolkit.getDefaultToolkit(), runnable));
    }

    /**
     * Causes {@code runnable} to have its {@code run}
     * method called in the {@link #isDispatchThread dispatch thread} of
     * {@link Toolkit#getSystemEventQueue the system EventQueue}.
     * This will happen after all pending events are processed.
     * The call blocks until this has happened.  This method
     * will throw an Error if called from the
     * {@link #isDispatchThread event dispatcher thread}.
     *
     * @param runnable  the {@code Runnable} whose {@code run}
     *                  method should be executed
     *                  synchronously in the
     *                  {@link #isDispatchThread event dispatch thread}
     *                  of {@link Toolkit#getSystemEventQueue the system EventQueue}
     * @throws       InterruptedException  if any thread has
     *                  interrupted this thread
     * @throws       InvocationTargetException  if an throwable is thrown
     *                  when running {@code runnable}
     * @see             #invokeLater
     * @see             Toolkit#getSystemEventQueue
     * @see             #isDispatchThread
     * @since           1.2
     */
    public static void invokeAndWait(Runnable runnable)
        throws InterruptedException, InvocationTargetException
    {
        invokeAndWait(Toolkit.getDefaultToolkit(), runnable);
    }

    static void invokeAndWait(Object source, Runnable runnable)
        throws InterruptedException, InvocationTargetException
    {
        if (EventQueue.isDispatchThread()) {
            throw new Error("Cannot call invokeAndWait from the event dispatcher thread");
        }

        class AWTInvocationLock {}
        Object lock = new AWTInvocationLock();

        InvocationEvent event =
            new InvocationEvent(source, runnable, lock, true);

        synchronized (lock) {
            Toolkit.getEventQueue().postEvent(event);
            while (!event.isDispatched()) {
                lock.wait();
            }
        }

        Throwable eventThrowable = event.getThrowable();
        if (eventThrowable != null) {
            throw new InvocationTargetException(eventThrowable);
        }
    }

    /*
     * Called from PostEventQueue.postEvent to notify that a new event
     * appeared. First it proceeds to the EventQueue on the top of the
     * stack, then notifies the associated dispatch thread if it exists
     * or starts a new one otherwise.
     */
    private void wakeup(boolean isShutdown) {
        pushPopLock.lock();
        try {
            if (nextQueue != null) {
                // Forward call to the top of EventQueue stack.
                nextQueue.wakeup(isShutdown);
            } else if (dispatchThread != null) {
                pushPopCond.signalAll();
            } else if (!isShutdown) {
                initDispatchThread();
            }
        } finally {
            pushPopLock.unlock();
        }
    }

    // The method is used by AWTAccessor for javafx/AWT single threaded mode.
    private void setFwDispatcher(FwDispatcher dispatcher) {
        if (nextQueue != null) {
            nextQueue.setFwDispatcher(dispatcher);
        } else {
            fwDispatcher = dispatcher;
        }
    }
}

/**
 * The Queue object holds pointers to the beginning and end of one internal
 * queue. An EventQueue object is composed of multiple internal Queues, one
 * for each priority supported by the EventQueue. All Events on a particular
 * internal Queue have identical priority.
 */
class Queue {
    EventQueueItem head;
    EventQueueItem tail;
}



AccessController-
/*
 * Copyright (c) 1997, 2022, Oracle and/or its affiliates. All rights reserved.
 * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */

package java.security;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import java.lang.ref.Reference;

import jdk.internal.vm.annotation.Hidden;
import sun.security.util.Debug;
import sun.security.util.SecurityConstants;
import jdk.internal.reflect.CallerSensitive;
import jdk.internal.reflect.Reflection;
import jdk.internal.vm.annotation.DontInline;
import jdk.internal.vm.annotation.ForceInline;
import jdk.internal.vm.annotation.ReservedStackAccess;

/**
 * <p> The {@code AccessController} class is used for access control operations
 * and decisions.
 *
 * <p> More specifically, the {@code AccessController} class is used for
 * three purposes:
 *
 * <ul>
 * <li> to decide whether an access to a critical system
 * resource is to be allowed or denied, based on the security policy
 * currently in effect,
 * <li>to mark code as being "privileged", thus affecting subsequent
 * access determinations, and
 * <li>to obtain a "snapshot" of the current calling context so
 * access-control decisions from a different context can be made with
 * respect to the saved context. </ul>
 *
 * <p> The {@link #checkPermission(Permission) checkPermission} method
 * determines whether the access request indicated by a specified
 * permission should be granted or denied. A sample call appears
 * below. In this example, {@code checkPermission} will determine
 * whether or not to grant "read" access to the file named "testFile" in
 * the "/temp" directory.
 *
 * <pre>
 *
 * FilePermission perm = new FilePermission("/temp/testFile", "read");
 * AccessController.checkPermission(perm);
 *
 * </pre>
 *
 * <p> If a requested access is allowed,
 * {@code checkPermission} returns quietly. If denied, an
 * {@code AccessControlException} is
 * thrown. {@code AccessControlException} can also be thrown if the requested
 * permission is of an incorrect type or contains an invalid value.
 * Such information is given whenever possible.
 *
 * Suppose the current thread traversed m callers, in the order of caller 1
 * to caller 2 to caller m. Then caller m invoked the
 * {@code checkPermission} method.
 * The {@code checkPermission} method determines whether access
 * is granted or denied based on the following algorithm:
 *
 *  <pre> {@code
 * for (int i = m; i > 0; i--) {
 *
 *     if (caller i's domain does not have the permission)
 *         throw AccessControlException
 *
 *     else if (caller i is marked as privileged) {
 *         if (a context was specified in the call to doPrivileged)
 *             context.checkPermission(permission)
 *         if (limited permissions were specified in the call to doPrivileged) {
 *             for (each limited permission) {
 *                 if (the limited permission implies the requested permission)
 *                     return;
 *             }
 *         } else
 *             return;
 *     }
 * }
 *
 * // Next, check the context inherited when the thread was created.
 * // Whenever a new thread is created, the AccessControlContext at
 * // that time is stored and associated with the new thread, as the
 * // "inherited" context.
 *
 * inheritedContext.checkPermission(permission);
 * }</pre>
 *
 * <p> A caller can be marked as being "privileged"
 * (see {@link #doPrivileged(PrivilegedAction) doPrivileged} and below).
 * When making access control decisions, the {@code checkPermission}
 * method stops checking if it reaches a caller that
 * was marked as "privileged" via a {@code doPrivileged}
 * call without a context argument (see below for information about a
 * context argument). If that caller's domain has the
 * specified permission and at least one limiting permission argument (if any)
 * implies the requested permission, no further checking is done and
 * {@code checkPermission}
 * returns quietly, indicating that the requested access is allowed.
 * If that domain does not have the specified permission, an exception
 * is thrown, as usual. If the caller's domain had the specified permission
 * but it was not implied by any limiting permission arguments given in the call
 * to {@code doPrivileged} then the permission checking continues
 * until there are no more callers or another {@code doPrivileged}
 * call matches the requested permission and returns normally.
 *
 * <p> The normal use of the "privileged" feature is as follows. If you
 * don't need to return a value from within the "privileged" block, do
 * the following:
 *
 *  <pre> {@code
 * somemethod() {
 *     ...normal code here...
 *     AccessController.doPrivileged(new PrivilegedAction<Void>() {
 *         public Void run() {
 *             // privileged code goes here, for example:
 *             System.loadLibrary("awt");
 *             return null; // nothing to return
 *         }
 *     });
 *     ...normal code here...
 * }}</pre>
 *
 * <p>
 * {@code PrivilegedAction} is an interface with a single method, named
 * {@code run}.
 * The above example shows creation of an implementation
 * of that interface; a concrete implementation of the
 * {@code run} method is supplied.
 * When the call to {@code doPrivileged} is made, an
 * instance of the {@code PrivilegedAction} implementation is passed
 * to it. The {@code doPrivileged} method calls the
 * {@code run} method from the {@code PrivilegedAction}
 * implementation after enabling privileges, and returns the
 * {@code run} method's return value as the
 * {@code doPrivileged} return value (which is
 * ignored in this example).
 *
 * <p> If you need to return a value, you can do something like the following:
 *
 *  <pre> {@code
 * somemethod() {
 *     ...normal code here...
 *     String user = AccessController.doPrivileged(
 *         new PrivilegedAction<String>() {
 *         public String run() {
 *             return System.getProperty("user.name");
 *             }
 *         });
 *     ...normal code here...
 * }}</pre>
 *
 * <p>If the action performed in your {@code run} method could
 * throw a "checked" exception (those listed in the {@code throws} clause
 * of a method), then you need to use the
 * {@code PrivilegedExceptionAction} interface instead of the
 * {@code PrivilegedAction} interface:
 *
 *  <pre> {@code
 * somemethod() throws FileNotFoundException {
 *     ...normal code here...
 *     try {
 *         FileInputStream fis = AccessController.doPrivileged(
 *         new PrivilegedExceptionAction<FileInputStream>() {
 *             public FileInputStream run() throws FileNotFoundException {
 *                 return new FileInputStream("someFile");
 *             }
 *         });
 *     } catch (PrivilegedActionException e) {
 *         // e.getException() should be an instance of FileNotFoundException,
 *         // as only "checked" exceptions will be "wrapped" in a
 *         // PrivilegedActionException.
 *         throw (FileNotFoundException) e.getException();
 *     }
 *     ...normal code here...
 *  }}</pre>
 *
 * <p> Be *very* careful in your use of the "privileged" construct, and
 * always remember to make the privileged code section as small as possible.
 * You can pass {@code Permission} arguments to further limit the
 * scope of the "privilege" (see below).
 *
 *
 * <p> Note that {@code checkPermission} always performs security checks
 * within the context of the currently executing thread.
 * Sometimes a security check that should be made within a given context
 * will actually need to be done from within a
 * <i>different</i> context (for example, from within a worker thread).
 * The {@link #getContext() getContext} method and
 * {@code AccessControlContext} class are provided
 * for this situation. The {@code getContext} method takes a "snapshot"
 * of the current calling context, and places
 * it in an {@code AccessControlContext} object, which it returns. A sample call is
 * the following:
 *
 * <pre>
 *
 * AccessControlContext acc = AccessController.getContext()
 *
 * </pre>
 *
 * <p>
 * {@code AccessControlContext} itself has a {@code checkPermission} method
 * that makes access decisions based on the context <i>it</i> encapsulates,
 * rather than that of the current execution thread.
 * Code within a different context can thus call that method on the
 * previously-saved {@code AccessControlContext} object. A sample call is the
 * following:
 *
 * <pre>
 *
 * acc.checkPermission(permission)
 *
 * </pre>
 *
 * <p> There are also times where you don't know a priori which permissions
 * to check the context against. In these cases you can use the
 * {@code doPrivileged} method that takes a context. You can also limit the
 * scope of the privileged code by passing additional {@code Permission}
 * parameters.
 *
 *  <pre> {@code
 * somemethod() {
 *     AccessController.doPrivileged(new PrivilegedAction<Object>() {
 *         public Object run() {
 *             // Code goes here. Any permission checks within this
 *             // run method will require that the intersection of the
 *             // caller's protection domain and the snapshot's
 *             // context have the desired permission. If a requested
 *             // permission is not implied by the limiting FilePermission
 *             // argument then checking of the thread continues beyond the
 *             // caller of doPrivileged.
 *         }
 *     }, acc, new FilePermission("/temp/*", read));
 *     ...normal code here...
 * }}</pre>
 * <p> Passing a limiting {@code Permission} argument of an instance of
 * {@code AllPermission} is equivalent to calling the equivalent
 * {@code doPrivileged} method without limiting {@code Permission}
 * arguments. Passing a zero length array of {@code Permission} disables
 * the code privileges so that checking always continues beyond the caller of
 * that {@code doPrivileged} method.
 *
 * @see AccessControlContext
 *
 * @author Li Gong
 * @author Roland Schemers
 * @since 1.2
 * @deprecated This class is only useful in conjunction with
 *       {@linkplain SecurityManager the Security Manager}, which is deprecated
 *       and subject to removal in a future release. Consequently, this class
 *       is also deprecated and subject to removal. There is no replacement for
 *       the Security Manager or this class.
 */

@Deprecated(since="17", forRemoval=true)
public final class AccessController {

    /**
     * Don't allow anyone to instantiate an {@code AccessController}
     */
    private AccessController() { }

    /**
     * Performs the specified {@code PrivilegedAction} with privileges
     * enabled. The action is performed with <i>all</i> of the permissions
     * possessed by the caller's protection domain.
     *
     * <p> If the action's {@code run} method throws an (unchecked)
     * exception, it will propagate through this method.
     *
     * <p> Note that any {@code DomainCombiner} associated with the current
     * {@code AccessControlContext} will be ignored while the action is
     * performed.
     *
     * @param <T> the type of the value returned by the PrivilegedAction's
     *                  {@code run} method.
     *
     * @param action the action to be performed.
     *
     * @return the value returned by the action's {@code run} method.
     *
     * @throws    NullPointerException if the action is {@code null}
     *
     * @see #doPrivileged(PrivilegedAction,AccessControlContext)
     * @see #doPrivileged(PrivilegedExceptionAction)
     * @see #doPrivilegedWithCombiner(PrivilegedAction)
     * @see java.security.DomainCombiner
     */

    @CallerSensitive
    public static <T> T doPrivileged(PrivilegedAction<T> action)
    {
        return executePrivileged(action, null, Reflection.getCallerClass());
    }

    /**
     * Performs the specified {@code PrivilegedAction} with privileges
     * enabled. The action is performed with <i>all</i> of the permissions
     * possessed by the caller's protection domain.
     *
     * <p> If the action's {@code run} method throws an (unchecked)
     * exception, it will propagate through this method.
     *
     * <p> This method preserves the current AccessControlContext's
     * {@code DomainCombiner} (which may be null) while the action is performed.
     *
     * @param <T> the type of the value returned by the PrivilegedAction's
     *                  {@code run} method.
     *
     * @param action the action to be performed.
     *
     * @return the value returned by the action's {@code run} method.
     *
     * @throws    NullPointerException if the action is {@code null}
     *
     * @see #doPrivileged(PrivilegedAction)
     * @see java.security.DomainCombiner
     *
     * @since 1.6
     */
    @CallerSensitive
    public static <T> T doPrivilegedWithCombiner(PrivilegedAction<T> action) {
        @SuppressWarnings("removal")
        AccessControlContext acc = getStackAccessControlContext();
        if (acc == null) {
            return AccessController.doPrivileged(action);
        }
        @SuppressWarnings("removal")
        DomainCombiner dc = acc.getAssignedCombiner();
        return AccessController.doPrivileged(action,
                                             preserveCombiner(dc, Reflection.getCallerClass()));
    }


    /**
     * Performs the specified {@code PrivilegedAction} with privileges
     * enabled and restricted by the specified {@code AccessControlContext}.
     * The action is performed with the intersection of the permissions
     * possessed by the caller's protection domain, and those possessed
     * by the domains represented by the specified {@code AccessControlContext}.
     * <p>
     * If the action's {@code run} method throws an (unchecked) exception,
     * it will propagate through this method.
     * <p>
     * If a security manager is installed and the specified
     * {@code AccessControlContext} was not created by system code and the
     * caller's {@code ProtectionDomain} has not been granted the
     * {@literal "createAccessControlContext"}
     * {@link java.security.SecurityPermission}, then the action is performed
     * with no permissions.
     *
     * @param <T> the type of the value returned by the PrivilegedAction's
     *                  {@code run} method.
     * @param action the action to be performed.
     * @param context an <i>access control context</i>
     *                representing the restriction to be applied to the
     *                caller's domain's privileges before performing
     *                the specified action.  If the context is
     *                {@code null}, then no additional restriction is applied.
     *
     * @return the value returned by the action's {@code run} method.
     *
     * @throws    NullPointerException if the action is {@code null}
     *
     * @see #doPrivileged(PrivilegedAction)
     * @see #doPrivileged(PrivilegedExceptionAction,AccessControlContext)
     */
    @CallerSensitive
    public static <T> T doPrivileged(PrivilegedAction<T> action,
                                     @SuppressWarnings("removal") AccessControlContext context)
    {
        Class<?> caller = Reflection.getCallerClass();
        context = checkContext(context, caller);
        return executePrivileged(action, context, caller);
    }


    /**
     * Performs the specified {@code PrivilegedAction} with privileges
     * enabled and restricted by the specified
     * {@code AccessControlContext} and with a privilege scope limited
     * by specified {@code Permission} arguments.
     *
     * The action is performed with the intersection of the permissions
     * possessed by the caller's protection domain, and those possessed
     * by the domains represented by the specified
     * {@code AccessControlContext}.
     * <p>
     * If the action's {@code run} method throws an (unchecked) exception,
     * it will propagate through this method.
     * <p>
     * If a security manager is installed and the specified
     * {@code AccessControlContext} was not created by system code and the
     * caller's {@code ProtectionDomain} has not been granted the
     * {@literal "createAccessControlContext"}
     * {@link java.security.SecurityPermission}, then the action is performed
     * with no permissions.
     *
     * @param <T> the type of the value returned by the PrivilegedAction's
     *                  {@code run} method.
     * @param action the action to be performed.
     * @param context an <i>access control context</i>
     *                representing the restriction to be applied to the
     *                caller's domain's privileges before performing
     *                the specified action.  If the context is
     *                {@code null},
     *                then no additional restriction is applied.
     * @param perms the {@code Permission} arguments which limit the
     *              scope of the caller's privileges. The number of arguments
     *              is variable.
     *
     * @return the value returned by the action's {@code run} method.
     *
     * @throws NullPointerException if action or perms or any element of
     *         perms is {@code null}
     *
     * @see #doPrivileged(PrivilegedAction)
     * @see #doPrivileged(PrivilegedExceptionAction,AccessControlContext)
     *
     * @since 1.8
     */
    @CallerSensitive
    public static <T> T doPrivileged(PrivilegedAction<T> action,
            @SuppressWarnings("removal") AccessControlContext context,
            Permission... perms) {

        @SuppressWarnings("removal")
        AccessControlContext parent = getContext();
        if (perms == null) {
            throw new NullPointerException("null permissions parameter");
        }
        Class<?> caller = Reflection.getCallerClass();
        @SuppressWarnings("removal")
        DomainCombiner dc = (context == null) ? null : context.getCombiner();
        return AccessController.doPrivileged(action, createWrapper(dc,
            caller, parent, context, perms));
    }


    /**
     * Performs the specified {@code PrivilegedAction} with privileges
     * enabled and restricted by the specified
     * {@code AccessControlContext} and with a privilege scope limited
     * by specified {@code Permission} arguments.
     *
     * The action is performed with the intersection of the permissions
     * possessed by the caller's protection domain, and those possessed
     * by the domains represented by the specified
     * {@code AccessControlContext}.
     * <p>
     * If the action's {@code run} method throws an (unchecked) exception,
     * it will propagate through this method.
     *
     * <p> This method preserves the current AccessControlContext's
     * {@code DomainCombiner} (which may be null) while the action is performed.
     * <p>
     * If a security manager is installed and the specified
     * {@code AccessControlContext} was not created by system code and the
     * caller's {@code ProtectionDomain} has not been granted the
     * {@literal "createAccessControlContext"}
     * {@link java.security.SecurityPermission}, then the action is performed
     * with no permissions.
     *
     * @param <T> the type of the value returned by the PrivilegedAction's
     *                  {@code run} method.
     * @param action the action to be performed.
     * @param context an <i>access control context</i>
     *                representing the restriction to be applied to the
     *                caller's domain's privileges before performing
     *                the specified action.  If the context is
     *                {@code null},
     *                then no additional restriction is applied.
     * @param perms the {@code Permission} arguments which limit the
     *              scope of the caller's privileges. The number of arguments
     *              is variable.
     *
     * @return the value returned by the action's {@code run} method.
     *
     * @throws NullPointerException if action or perms or any element of
     *         perms is {@code null}
     *
     * @see #doPrivileged(PrivilegedAction)
     * @see #doPrivileged(PrivilegedExceptionAction,AccessControlContext)
     * @see java.security.DomainCombiner
     *
     * @since 1.8
     */
    @CallerSensitive
    public static <T> T doPrivilegedWithCombiner(PrivilegedAction<T> action,
            @SuppressWarnings("removal") AccessControlContext context,
            Permission... perms) {

        @SuppressWarnings("removal")
        AccessControlContext parent = getContext();
        @SuppressWarnings("removal")
        DomainCombiner dc = parent.getCombiner();
        if (dc == null && context != null) {
            dc = context.getCombiner();
        }
        if (perms == null) {
            throw new NullPointerException("null permissions parameter");
        }
        Class<?> caller = Reflection.getCallerClass();
        return AccessController.doPrivileged(action, createWrapper(dc, caller,
            parent, context, perms));
    }

    /**
     * Performs the specified {@code PrivilegedExceptionAction} with
     * privileges enabled.  The action is performed with <i>all</i> of the
     * permissions possessed by the caller's protection domain.
     *
     * <p> If the action's {@code run} method throws an <i>unchecked</i>
     * exception, it will propagate through this method.
     *
     * <p> Note that any {@code DomainCombiner} associated with the current
     * {@code AccessControlContext} will be ignored while the action is
     * performed.
     *
     * @param <T> the type of the value returned by the
     *                  PrivilegedExceptionAction's {@code run} method.
     *
     * @param action the action to be performed
     *
     * @return the value returned by the action's {@code run} method
     *
     * @throws    PrivilegedActionException if the specified action's
     *         {@code run} method threw a <i>checked</i> exception
     * @throws    NullPointerException if the action is {@code null}
     *
     * @see #doPrivileged(PrivilegedAction)
     * @see #doPrivileged(PrivilegedExceptionAction,AccessControlContext)
     * @see #doPrivilegedWithCombiner(PrivilegedExceptionAction)
     * @see java.security.DomainCombiner
     */
    @CallerSensitive
    public static <T> T
        doPrivileged(PrivilegedExceptionAction<T> action)
        throws PrivilegedActionException
    {
        @SuppressWarnings("removal")
        AccessControlContext context = null;
        Class<?> caller = Reflection.getCallerClass();
        try {
            return executePrivileged(action, context, caller);
        } catch (RuntimeException e) {
            throw e;
        } catch (Exception e) {
            throw wrapException(e);
        }
    }

    /**
     * Performs the specified {@code PrivilegedExceptionAction} with
     * privileges enabled.  The action is performed with <i>all</i> of the
     * permissions possessed by the caller's protection domain.
     *
     * <p> If the action's {@code run} method throws an <i>unchecked</i>
     * exception, it will propagate through this method.
     *
     * <p> This method preserves the current AccessControlContext's
     * {@code DomainCombiner} (which may be null) while the action is performed.
     *
     * @param <T> the type of the value returned by the
     *                  PrivilegedExceptionAction's {@code run} method.
     *
     * @param action the action to be performed.
     *
     * @return the value returned by the action's {@code run} method
     *
     * @throws    PrivilegedActionException if the specified action's
     *         {@code run} method threw a <i>checked</i> exception
     * @throws    NullPointerException if the action is {@code null}
     *
     * @see #doPrivileged(PrivilegedAction)
     * @see #doPrivileged(PrivilegedExceptionAction,AccessControlContext)
     * @see java.security.DomainCombiner
     *
     * @since 1.6
     */
    @CallerSensitive
    public static <T> T doPrivilegedWithCombiner(PrivilegedExceptionAction<T> action)
        throws PrivilegedActionException
    {
        @SuppressWarnings("removal")
        AccessControlContext acc = getStackAccessControlContext();
        if (acc == null) {
            return AccessController.doPrivileged(action);
        }
        @SuppressWarnings("removal")
        DomainCombiner dc = acc.getAssignedCombiner();
        return AccessController.doPrivileged(action,
                                             preserveCombiner(dc, Reflection.getCallerClass()));
    }

    /**
     * preserve the combiner across the doPrivileged call
     */
    @SuppressWarnings("removal")
    private static AccessControlContext preserveCombiner(DomainCombiner combiner,
                                                         Class<?> caller)
    {
        return createWrapper(combiner, caller, null, null, null);
    }

    /**
     * Create a wrapper to contain the limited privilege scope data.
     */
    @SuppressWarnings("removal")
    private static AccessControlContext
        createWrapper(DomainCombiner combiner, Class<?> caller,
                      AccessControlContext parent, AccessControlContext context,
                      Permission[] perms)
    {
        ProtectionDomain callerPD = getProtectionDomain(caller);
        // check if caller is authorized to create context
        if (System.getSecurityManager() != null &&
            context != null && !context.isAuthorized() &&
            !callerPD.implies(SecurityConstants.CREATE_ACC_PERMISSION))
        {
            return getInnocuousAcc();
        } else {
            return new AccessControlContext(callerPD, combiner, parent,
                                            context, perms);
        }
    }

    private static class AccHolder {
        // An AccessControlContext with no granted permissions.
        // Only initialized on demand when getInnocuousAcc() is called.
        @SuppressWarnings("removal")
        static final AccessControlContext innocuousAcc =
            new AccessControlContext(new ProtectionDomain[] {
                                     new ProtectionDomain(null, null) });
    }
    @SuppressWarnings("removal")
    private static AccessControlContext getInnocuousAcc() {
        return AccHolder.innocuousAcc;
    }

    private static native ProtectionDomain getProtectionDomain(final Class<?> caller);

    /**
     * Performs the specified {@code PrivilegedExceptionAction} with
     * privileges enabled and restricted by the specified
     * {@code AccessControlContext}.  The action is performed with the
     * intersection of the permissions possessed by the caller's
     * protection domain, and those possessed by the domains represented by the
     * specified {@code AccessControlContext}.
     * <p>
     * If the action's {@code run} method throws an <i>unchecked</i>
     * exception, it will propagate through this method.
     * <p>
     * If a security manager is installed and the specified
     * {@code AccessControlContext} was not created by system code and the
     * caller's {@code ProtectionDomain} has not been granted the
     * {@literal "createAccessControlContext"}
     * {@link java.security.SecurityPermission}, then the action is performed
     * with no permissions.
     *
     * @param <T> the type of the value returned by the
     *                  PrivilegedExceptionAction's {@code run} method.
     * @param action the action to be performed
     * @param context an <i>access control context</i>
     *                representing the restriction to be applied to the
     *                caller's domain's privileges before performing
     *                the specified action.  If the context is
     *                {@code null}, then no additional restriction is applied.
     *
     * @return the value returned by the action's {@code run} method
     *
     * @throws    PrivilegedActionException if the specified action's
     *         {@code run} method threw a <i>checked</i> exception
     * @throws    NullPointerException if the action is {@code null}
     *
     * @see #doPrivileged(PrivilegedAction)
     * @see #doPrivileged(PrivilegedAction,AccessControlContext)
     */
    @CallerSensitive
    public static <T> T
        doPrivileged(PrivilegedExceptionAction<T> action,
                     @SuppressWarnings("removal") AccessControlContext context)
        throws PrivilegedActionException
    {
        Class<?> caller = Reflection.getCallerClass();
        context = checkContext(context, caller);
        try {
            return executePrivileged(action, context, caller);
        } catch (RuntimeException e) {
            throw e;
        } catch (Exception e) {
            throw wrapException(e);
        }
    }

    @SuppressWarnings("removal")
    private static AccessControlContext checkContext(AccessControlContext context,
        Class<?> caller)
    {
        // check if caller is authorized to create context
        if (System.getSecurityManager() != null &&
            context != null && !context.isAuthorized() &&
            context != getInnocuousAcc())
        {
            ProtectionDomain callerPD = getProtectionDomain(caller);
            if (callerPD != null && !callerPD.implies(SecurityConstants.CREATE_ACC_PERMISSION)) {
                return getInnocuousAcc();
            }
        }
        return context;
    }

    /**
     * The value needs to be physically located in the frame, so that it
     * can be found by a stack walk.
     */
    @Hidden
    private static native void ensureMaterializedForStackWalk(Object o);

    /**
     * Sanity check that the caller context is indeed privileged.
     *
     * Used by {@code executePrivileged} to make sure the frame is properly
     * recognized by the VM.
     */
    private static boolean isPrivileged() {
        @SuppressWarnings("removal")
        AccessControlContext ctx = getStackAccessControlContext();
        return ctx == null || ctx.isPrivileged();
    }

    /**
     * Execute the action as privileged.
     *
     * The VM recognizes this method as special, so any changes to the
     * name or signature require corresponding changes in
     * getStackAccessControlContext().
     */
    @Hidden
    @ForceInline
    private static <T> T
        executePrivileged(PrivilegedAction<T> action,
                          @SuppressWarnings("removal") AccessControlContext context,
                          Class<?> caller)
    {
        // Ensure context has a physical value in the frame
        if (context != null) {
            ensureMaterializedForStackWalk(context);
        }

        assert isPrivileged(); // sanity check invariant
        T result = action.run();
        assert isPrivileged(); // sanity check invariant

        // Keep these alive across the run() call so they can be
        // retrieved by getStackAccessControlContext().
        Reference.reachabilityFence(context);
        Reference.reachabilityFence(caller);
        return result;
    }

    /**
     * Execute the action as privileged.
     *
     * The VM recognizes this method as special, so any changes to the
     * name or signature require corresponding changes in
     * getStackAccessControlContext().
     */
    @Hidden
    @ForceInline
    private static <T> T
        executePrivileged(PrivilegedExceptionAction<T> action,
                          @SuppressWarnings("removal") AccessControlContext context,
                          Class<?> caller)
        throws Exception
    {
        // Ensure context has a physical value in the frame
        if (context != null) {
            ensureMaterializedForStackWalk(context);
        }

        assert isPrivileged(); // sanity check invariant
        T result = action.run();
        assert isPrivileged(); // sanity check invariant

        // Keep these alive across the run() call so they can be
        // retrieved by getStackAccessControlContext().
        Reference.reachabilityFence(context);
        Reference.reachabilityFence(caller);
        return result;
    }


    /**
     * Wrap an exception.  The annotations are used in a best effort to
     * avoid StackOverflowError in the caller.  Inlining the callees as
     * well and tail-call elimination could also help here, but are not
     * needed for correctness, only quality of implementation.
     */
    @Hidden
    @ForceInline
    @ReservedStackAccess
    private static PrivilegedActionException wrapException(Exception e) {
        return new PrivilegedActionException(e);
    }

    /**
     * Performs the specified {@code PrivilegedExceptionAction} with
     * privileges enabled and restricted by the specified
     * {@code AccessControlContext} and with a privilege scope limited by
     * specified {@code Permission} arguments.
     *
     * The action is performed with the intersection of the permissions
     * possessed by the caller's protection domain, and those possessed
     * by the domains represented by the specified
     * {@code AccessControlContext}.
     * <p>
     * If the action's {@code run} method throws an (unchecked) exception,
     * it will propagate through this method.
     * <p>
     * If a security manager is installed and the specified
     * {@code AccessControlContext} was not created by system code and the
     * caller's {@code ProtectionDomain} has not been granted the
     * {@literal "createAccessControlContext"}
     * {@link java.security.SecurityPermission}, then the action is performed
     * with no permissions.
     *
     * @param <T> the type of the value returned by the
     *                  PrivilegedExceptionAction's {@code run} method.
     * @param action the action to be performed.
     * @param context an <i>access control context</i>
     *                representing the restriction to be applied to the
     *                caller's domain's privileges before performing
     *                the specified action.  If the context is
     *                {@code null},
     *                then no additional restriction is applied.
     * @param perms the {@code Permission} arguments which limit the
     *              scope of the caller's privileges. The number of arguments
     *              is variable.
     *
     * @return the value returned by the action's {@code run} method.
     *
     * @throws PrivilegedActionException if the specified action's
     *         {@code run} method threw a <i>checked</i> exception
     * @throws NullPointerException if action or perms or any element of
     *         perms is {@code null}
     *
     * @see #doPrivileged(PrivilegedAction)
     * @see #doPrivileged(PrivilegedAction,AccessControlContext)
     *
     * @since 1.8
     */
    @CallerSensitive
    public static <T> T doPrivileged(PrivilegedExceptionAction<T> action,
            @SuppressWarnings("removal") AccessControlContext context,
            Permission... perms)
        throws PrivilegedActionException
    {
        @SuppressWarnings("removal")
        AccessControlContext parent = getContext();
        if (perms == null) {
            throw new NullPointerException("null permissions parameter");
        }
        Class<?> caller = Reflection.getCallerClass();
        @SuppressWarnings("removal")
        DomainCombiner dc = (context == null) ? null : context.getCombiner();
        return AccessController.doPrivileged(action, createWrapper(dc, caller, parent, context, perms));
    }


    /**
     * Performs the specified {@code PrivilegedExceptionAction} with
     * privileges enabled and restricted by the specified
     * {@code AccessControlContext} and with a privilege scope limited by
     * specified {@code Permission} arguments.
     *
     * The action is performed with the intersection of the permissions
     * possessed by the caller's protection domain, and those possessed
     * by the domains represented by the specified
     * {@code AccessControlContext}.
     * <p>
     * If the action's {@code run} method throws an (unchecked) exception,
     * it will propagate through this method.
     *
     * <p> This method preserves the current AccessControlContext's
     * {@code DomainCombiner} (which may be null) while the action is performed.
     * <p>
     * If a security manager is installed and the specified
     * {@code AccessControlContext} was not created by system code and the
     * caller's {@code ProtectionDomain} has not been granted the
     * {@literal "createAccessControlContext"}
     * {@link java.security.SecurityPermission}, then the action is performed
     * with no permissions.
     *
     * @param <T> the type of the value returned by the
     *                  PrivilegedExceptionAction's {@code run} method.
     * @param action the action to be performed.
     * @param context an <i>access control context</i>
     *                representing the restriction to be applied to the
     *                caller's domain's privileges before performing
     *                the specified action.  If the context is
     *                {@code null},
     *                then no additional restriction is applied.
     * @param perms the {@code Permission} arguments which limit the
     *              scope of the caller's privileges. The number of arguments
     *              is variable.
     *
     * @return the value returned by the action's {@code run} method.
     *
     * @throws PrivilegedActionException if the specified action's
     *         {@code run} method threw a <i>checked</i> exception
     * @throws NullPointerException if action or perms or any element of
     *         perms is {@code null}
     *
     * @see #doPrivileged(PrivilegedAction)
     * @see #doPrivileged(PrivilegedAction,AccessControlContext)
     * @see java.security.DomainCombiner
     *
     * @since 1.8
     */
    @CallerSensitive
    public static <T> T doPrivilegedWithCombiner(PrivilegedExceptionAction<T> action,
                                                 @SuppressWarnings("removal") AccessControlContext context,
                                                 Permission... perms)
        throws PrivilegedActionException
    {
        @SuppressWarnings("removal")
        AccessControlContext parent = getContext();
        @SuppressWarnings("removal")
        DomainCombiner dc = parent.getCombiner();
        if (dc == null && context != null) {
            dc = context.getCombiner();
        }
        if (perms == null) {
            throw new NullPointerException("null permissions parameter");
        }
        Class<?> caller = Reflection.getCallerClass();
        return AccessController.doPrivileged(action, createWrapper(dc, caller,
            parent, context, perms));
    }

    /**
     * Returns the {@code AccessControlContext}. i.e., it gets
     * the protection domains of all the callers on the stack,
     * starting at the first class with a non-null
     * {@code ProtectionDomain}.
     *
     * @return the access control context based on the current stack or
     *         {@code null} if there was only privileged system code.
     */

    @SuppressWarnings("removal")
    private static native AccessControlContext getStackAccessControlContext();


    /**
     * Returns the "inherited" {@code AccessControlContext}. This is the context
     * that existed when the thread was created. Package private so
     * {@code AccessControlContext} can use it.
     */

    @SuppressWarnings("removal")
    static native AccessControlContext getInheritedAccessControlContext();

    /**
     * This method takes a "snapshot" of the current calling context, which
     * includes the current thread's inherited {@code AccessControlContext}
     * and any limited privilege scope, and places it in an
     * {@code AccessControlContext} object.
     * This context may then be checked at a later point, possibly in another thread.
     *
     * @see AccessControlContext
     *
     * @return the {@code AccessControlContext} based on the current context.
     */

    @SuppressWarnings("removal")
    public static AccessControlContext getContext()
    {
        AccessControlContext acc = getStackAccessControlContext();
        if (acc == null) {
            // all we had was privileged system code. We don't want
            // to return null though, so we construct a real ACC.
            return new AccessControlContext(null, true);
        } else {
            return acc.optimize();
        }
    }

    /**
     * Determines whether the access request indicated by the
     * specified permission should be allowed or denied, based on
     * the current {@code AccessControlContext} and security policy.
     * This method quietly returns if the access request
     * is permitted, or throws an {@code AccessControlException} otherwise. The
     * {@code getPermission} method of the {@code AccessControlException}
     * returns the {@code Permission} object instance ({@code perm}}.
     *
     * @param perm the requested permission.
     *
     * @throws    AccessControlException if the specified permission
     *            is not permitted, based on the current security policy.
     * @throws    NullPointerException if the specified permission
     *            is {@code null} and is checked based on the
     *            security policy currently in effect.
     */

    @SuppressWarnings("removal")
    public static void checkPermission(Permission perm)
        throws AccessControlException
    {
        //System.err.println("checkPermission "+perm);
        //Thread.currentThread().dumpStack();

        if (perm == null) {
            throw new NullPointerException("permission can't be null");
        }

        AccessControlContext stack = getStackAccessControlContext();
        // if context is null, we had privileged system code on the stack.
        if (stack == null) {
            Debug debug = AccessControlContext.getDebug();
            boolean dumpDebug = false;
            if (debug != null) {
                dumpDebug = !Debug.isOn("codebase=");
                dumpDebug &= !Debug.isOn("permission=") ||
                    Debug.isOn("permission=" + perm.getClass().getCanonicalName());
            }

            if (dumpDebug && Debug.isOn("stack")) {
                Thread.dumpStack();
            }

            if (dumpDebug && Debug.isOn("domain")) {
                debug.println("domain (context is null)");
            }

            if (dumpDebug) {
                debug.println("access allowed "+perm);
            }
            return;
        }

        AccessControlContext acc = stack.optimize();
        acc.checkPermission(perm);
    }
}


ProtectionDomain-
/*
 * Copyright (c) 1997, 2022, Oracle and/or its affiliates. All rights reserved.
 * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */

package java.security;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Enumeration;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.WeakHashMap;
import jdk.internal.access.JavaSecurityAccess;
import jdk.internal.access.SharedSecrets;
import sun.security.action.GetPropertyAction;
import sun.security.provider.PolicyFile;
import sun.security.util.Debug;
import sun.security.util.FilePermCompat;
import sun.security.util.SecurityConstants;

/**
 * The {@code ProtectionDomain} class encapsulates the characteristics of a
 * domain, which encloses a set of classes whose instances are granted a set
 * of permissions when being executed on behalf of a given set of Principals.
 * <p>
 * A static set of permissions can be bound to a {@code ProtectionDomain}
 * when it is constructed; such permissions are granted to the domain
 * regardless of the policy in force. However, to support dynamic security
 * policies, a {@code ProtectionDomain} can also be constructed such that it
 * is dynamically mapped to a set of permissions by the current policy whenever
 * a permission is checked.
 *
 * @author Li Gong
 * @author Roland Schemers
 * @author Gary Ellison
 * @since 1.2
 */

public class ProtectionDomain {

    /**
     * If {@code true}, {@link #impliesWithAltFilePerm} will try to be
     * compatible on FilePermission checking even if a 3rd-party Policy
     * implementation is set.
     */
    private static final boolean filePermCompatInPD =
            "true".equals(GetPropertyAction.privilegedGetProperty(
                "jdk.security.filePermCompat"));

    private static class JavaSecurityAccessImpl implements JavaSecurityAccess {

        private JavaSecurityAccessImpl() {
        }

        @SuppressWarnings("removal")
        @Override
        public <T> T doIntersectionPrivilege(
                PrivilegedAction<T> action,
                final AccessControlContext stack,
                final AccessControlContext context) {
            if (action == null) {
                throw new NullPointerException();
            }

            return AccessController.doPrivileged(
                action,
                getCombinedACC(context, stack)
            );
        }

        @SuppressWarnings("removal")
        @Override
        public <T> T doIntersectionPrivilege(
                PrivilegedAction<T> action,
                AccessControlContext context) {
            return doIntersectionPrivilege(action,
                AccessController.getContext(), context);
        }

        @Override
        public ProtectionDomain[] getProtectDomains(@SuppressWarnings("removal") AccessControlContext context) {
            return context.getContext();
        }

        @SuppressWarnings("removal")
        private static AccessControlContext getCombinedACC(
            AccessControlContext context, AccessControlContext stack) {
            AccessControlContext acc =
                new AccessControlContext(context, stack.getCombiner(), true);

            return new AccessControlContext(stack.getContext(), acc).optimize();
        }

        @Override
        public ProtectionDomainCache getProtectionDomainCache() {
            return new ProtectionDomainCache() {
                private final Map<Key, PermissionCollection> map =
                        Collections.synchronizedMap(new WeakHashMap<>());
                public void put(ProtectionDomain pd,
                                PermissionCollection pc) {
                    map.put((pd == null ? null : pd.key), pc);
                }
                public PermissionCollection get(ProtectionDomain pd) {
                    return pd == null ? map.get(null) : map.get(pd.key);
                }
            };
        }
    }

    static {
        // Set up JavaSecurityAccess in SharedSecrets
        SharedSecrets.setJavaSecurityAccess(new JavaSecurityAccessImpl());
    }

    /* CodeSource */
    private final CodeSource codesource ;

    /* ClassLoader the protection domain was consed from */
    private final ClassLoader classloader;

    /* Principals running-as within this protection domain */
    private final Principal[] principals;

    /* the rights this protection domain is granted */
    private PermissionCollection permissions;

    /* if the permissions object has AllPermission */
    private boolean hasAllPerm = false;

    /* the PermissionCollection is static (pre 1.4 constructor)
       or dynamic (via a policy refresh) */
    private final boolean staticPermissions;

    /*
     * An object used as a key when the ProtectionDomain is stored in a Map.
     */
    final Key key = new Key();

    /**
     * Creates a new {@code ProtectionDomain} with the given {@code CodeSource}
     * and permissions. If permissions is not {@code null}, then
     * {@code setReadOnly()} will be called on the passed in
     * permissions.
     * <p>
     * The permissions granted to this domain are static, i.e.
     * invoking the {@link #staticPermissionsOnly()} method returns
     * {@code true}.
     * They contain only the ones passed to this constructor and
     * the current policy will not be consulted.
     *
     * @param codesource the codesource associated with this domain
     * @param permissions the permissions granted to this domain
     */
    public ProtectionDomain(CodeSource codesource,
                            PermissionCollection permissions) {
        this.codesource = codesource;
        if (permissions != null) {
            this.permissions = permissions;
            this.permissions.setReadOnly();
            if (permissions instanceof Permissions &&
                ((Permissions)permissions).allPermission != null) {
                hasAllPerm = true;
            }
        }
        this.classloader = null;
        this.principals = new Principal[0];
        staticPermissions = true;
    }

    /**
     * Creates a new {@code ProtectionDomain} qualified by the given
     * {@code CodeSource}, permissions, {@code ClassLoader} and array
     * of principals. If permissions is not {@code null}, then
     * {@code setReadOnly()} will be called on the passed in permissions.
     * <p>
     * The permissions granted to this domain are dynamic, i.e.
     * invoking the {@link #staticPermissionsOnly()} method returns
     * {@code false}.
     * They include both the static permissions passed to this constructor,
     * and any permissions granted to this domain by the current policy at the
     * time a permission is checked.
     * <p>
     * This constructor is typically used by
     * {@link SecureClassLoader ClassLoaders}
     * and {@link DomainCombiner DomainCombiners} which delegate to the
     * {@code Policy} object to actively associate the permissions granted to
     * this domain. This constructor affords the
     * policy provider the opportunity to augment the supplied
     * {@code PermissionCollection} to reflect policy changes.
     *
     * @param codesource the {@code CodeSource} associated with this domain
     * @param permissions the permissions granted to this domain
     * @param classloader the {@code ClassLoader} associated with this domain
     * @param principals the array of {@code Principal} objects associated
     * with this domain. The contents of the array are copied to protect against
     * subsequent modification.
     * @see Policy#refresh
     * @see Policy#getPermissions(ProtectionDomain)
     * @since 1.4
     */
    public ProtectionDomain(CodeSource codesource,
                            PermissionCollection permissions,
                            ClassLoader classloader,
                            Principal[] principals) {
        this.codesource = codesource;
        if (permissions != null) {
            this.permissions = permissions;
            this.permissions.setReadOnly();
            if (permissions instanceof Permissions &&
                ((Permissions)permissions).allPermission != null) {
                hasAllPerm = true;
            }
        }
        this.classloader = classloader;
        this.principals = (principals != null ? principals.clone():
                           new Principal[0]);
        staticPermissions = false;
    }

    /**
     * Returns the {@code CodeSource} of this domain.
     * @return the {@code CodeSource} of this domain which may be {@code null}.
     * @since 1.2
     */
    public final CodeSource getCodeSource() {
        return this.codesource;
    }


    /**
     * Returns the {@code ClassLoader} of this domain.
     * @return the {@code ClassLoader} of this domain which may be {@code null}.
     *
     * @since 1.4
     */
    public final ClassLoader getClassLoader() {
        return this.classloader;
    }


    /**
     * Returns an array of principals for this domain.
     * @return a non-null array of principals for this domain.
     * Returns a new array each time this method is called.
     *
     * @since 1.4
     */
    public final Principal[] getPrincipals() {
        return this.principals.clone();
    }

    /**
     * Returns the static permissions granted to this domain.
     *
     * @return the static set of permissions for this domain which may be
     * {@code null}.
     * @see Policy#refresh
     * @see Policy#getPermissions(ProtectionDomain)
     */
    public final PermissionCollection getPermissions() {
        return permissions;
    }

    /**
     * Returns {@code true} if this domain contains only static permissions
     * and does not check the current {@code Policy} at the time of
     * permission checking.
     *
     * @return {@code true} if this domain contains only static permissions.
     *
     * @since 9
     */
    public final boolean staticPermissionsOnly() {
        return this.staticPermissions;
    }

    /**
     * Check and see if this {@code ProtectionDomain} implies the permissions
     * expressed in the {@code Permission} object.
     * <p>
     * The set of permissions evaluated is a function of whether the
     * {@code ProtectionDomain} was constructed with a static set of permissions
     * or it was bound to a dynamically mapped set of permissions.
     * <p>
     * If the {@link #staticPermissionsOnly()} method returns
     * {@code true}, then the permission will only be checked against the
     * {@code PermissionCollection} supplied at construction.
     * <p>
     * Otherwise, the permission will be checked against the combination
     * of the {@code PermissionCollection} supplied at construction and
     * the current policy binding.
     *
     * @param perm the {code Permission} object to check.
     *
     * @return {@code true} if {@code perm} is implied by this
     * {@code ProtectionDomain}.
     */
    @SuppressWarnings("removal")
    public boolean implies(Permission perm) {

        if (hasAllPerm) {
            // internal permission collection already has AllPermission -
            // no need to go to policy
            return true;
        }

        if (!staticPermissions &&
            Policy.getPolicyNoCheck().implies(this, perm)) {
            return true;
        }
        if (permissions != null) {
            return permissions.implies(perm);
        }

        return false;
    }

    /**
     * This method has almost the same logic flow as {@link #implies} but
     * it ensures some level of FilePermission compatibility after JDK-8164705.
     *
     * This method is called by {@link AccessControlContext#checkPermission}
     * and not intended to be called by an application.
     */
    boolean impliesWithAltFilePerm(Permission perm) {

        // If FilePermCompat.compat is set (default value), FilePermission
        // checking compatibility should be considered.

        // If filePermCompatInPD is set, this method checks for alternative
        // FilePermission to keep compatibility for any Policy implementation.
        // When set to false (default value), implies() is called since
        // the PolicyFile implementation already supports compatibility.

        // If this is a subclass of ProtectionDomain, call implies()
        // because most likely user has overridden it.

        if (!filePermCompatInPD || !FilePermCompat.compat ||
                getClass() != ProtectionDomain.class) {
            return implies(perm);
        }

        if (hasAllPerm) {
            // internal permission collection already has AllPermission -
            // no need to go to policy
            return true;
        }

        Permission p2 = null;
        boolean p2Calculated = false;

        if (!staticPermissions) {
            @SuppressWarnings("removal")
            Policy policy = Policy.getPolicyNoCheck();
            if (policy instanceof PolicyFile) {
                // The PolicyFile implementation supports compatibility
                // inside, and it also covers the static permissions.
                return policy.implies(this, perm);
            } else {
                if (policy.implies(this, perm)) {
                    return true;
                }
                p2 = FilePermCompat.newPermUsingAltPath(perm);
                p2Calculated = true;
                if (p2 != null && policy.implies(this, p2)) {
                    return true;
                }
            }
        }
        if (permissions != null) {
            if (permissions.implies(perm)) {
                return true;
            } else {
                if (!p2Calculated) {
                    p2 = FilePermCompat.newPermUsingAltPath(perm);
                }
                if (p2 != null) {
                    return permissions.implies(p2);
                }
            }
        }
        return false;
    }

    /**
     * Convert a {@code ProtectionDomain} to a {@code String}.
     */
    @Override public String toString() {
        String pals = "<no principals>";
        if (principals != null && principals.length > 0) {
            StringBuilder palBuf = new StringBuilder("(principals ");

            for (int i = 0; i < principals.length; i++) {
                palBuf.append(principals[i].getClass().getName() +
                            " \"" + principals[i].getName() +
                            "\"");
                if (i < principals.length-1)
                    palBuf.append(",\n");
                else
                    palBuf.append(")\n");
            }
            pals = palBuf.toString();
        }

        // Check if policy is set; we don't want to load
        // the policy prematurely here
        @SuppressWarnings("removal")
        PermissionCollection pc = Policy.isSet() && seeAllp() ?
                                      mergePermissions():
                                      getPermissions();

        return "ProtectionDomain "+
            " "+codesource+"\n"+
            " "+classloader+"\n"+
            " "+pals+"\n"+
            " "+pc+"\n";
    }

    /*
     * holder class for the static field "debug" to delay its initialization
     */
    private static class DebugHolder {
        private static final Debug debug = Debug.getInstance("domain");
    }

    /**
     * Return {@code true} (merge policy permissions) in the following cases:
     *
     * . SecurityManager is {@code null}
     *
     * . SecurityManager is not {@code null},
     *          debug is not {@code null},
     *          SecurityManager implementation is in bootclasspath,
     *          Policy implementation is in bootclasspath
     *          (the bootclasspath restrictions avoid recursion)
     *
     * . SecurityManager is not {@code null},
     *          debug is {@code null},
     *          caller has Policy.getPolicy permission
     */
    @SuppressWarnings("removal")
    private static boolean seeAllp() {
        SecurityManager sm = System.getSecurityManager();

        if (sm == null) {
            return true;
        } else {
            if (DebugHolder.debug != null) {
                return sm.getClass().getClassLoader() == null &&
                        Policy.getPolicyNoCheck().getClass().getClassLoader()
                                == null;
            } else {
                try {
                    sm.checkPermission(SecurityConstants.GET_POLICY_PERMISSION);
                    return true;
                } catch (SecurityException se) {
                    return false;
                }
            }
        }
    }

    private PermissionCollection mergePermissions() {
        if (staticPermissions)
            return permissions;

        @SuppressWarnings("removal")
        PermissionCollection perms =
            java.security.AccessController.doPrivileged
            ((PrivilegedAction<PermissionCollection>) () ->
                Policy.getPolicyNoCheck().getPermissions(ProtectionDomain.this));

        Permissions mergedPerms = new Permissions();
        int swag = 32;
        int vcap = 8;
        Enumeration<Permission> e;
        List<Permission> pdVector = new ArrayList<>(vcap);
        List<Permission> plVector = new ArrayList<>(swag);

        //
        // Build a vector of domain permissions for subsequent merge
        if (permissions != null) {
            synchronized (permissions) {
                e = permissions.elements();
                while (e.hasMoreElements()) {
                    pdVector.add(e.nextElement());
                }
            }
        }

        //
        // Build a vector of Policy permissions for subsequent merge
        if (perms != null) {
            synchronized (perms) {
                e = perms.elements();
                while (e.hasMoreElements()) {
                    plVector.add(e.nextElement());
                    vcap++;
                }
            }
        }

        if (perms != null && permissions != null) {
            //
            // Weed out the duplicates from the policy. Unless a refresh
            // has occurred since the pd was consed this should result in
            // an empty vector.
            synchronized (permissions) {
                e = permissions.elements();   // domain vs policy
                while (e.hasMoreElements()) {
                    Permission pdp = e.nextElement();
                    Class<?> pdpClass = pdp.getClass();
                    String pdpActions = pdp.getActions();
                    String pdpName = pdp.getName();
                    for (int i = 0; i < plVector.size(); i++) {
                        Permission pp = plVector.get(i);
                        if (pdpClass.isInstance(pp)) {
                            // The equals() method on some permissions
                            // have some side effects so this manual
                            // comparison is sufficient.
                            if (pdpName.equals(pp.getName()) &&
                                Objects.equals(pdpActions, pp.getActions())) {
                                plVector.remove(i);
                                break;
                            }
                        }
                    }
                }
            }
        }

        if (perms !=null) {
            // the order of adding to merged perms and permissions
            // needs to preserve the bugfix 4301064

            for (int i = plVector.size()-1; i >= 0; i--) {
                mergedPerms.add(plVector.get(i));
            }
        }
        if (permissions != null) {
            for (int i = pdVector.size()-1; i >= 0; i--) {
                mergedPerms.add(pdVector.get(i));
            }
        }

        return mergedPerms;
    }

    /**
     * Used for storing ProtectionDomains as keys in a Map.
     */
    static final class Key {}

}


IdeEventQueue.kt-
// Copyright 2000-2023 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
@file:Suppress("JAVA_MODULE_DOES_NOT_EXPORT_PACKAGE", "FunctionName", "ReplaceGetOrSet", "ReplacePutWithAssignment")

package com.intellij.ide

import com.intellij.codeWithMe.ClientId.Companion.current
import com.intellij.codeWithMe.ClientId.Companion.isCurrentlyUnderLocalId
import com.intellij.codeWithMe.ClientId.Companion.withClientId
import com.intellij.concurrency.resetThreadContext
import com.intellij.diagnostic.EventWatcher
import com.intellij.diagnostic.LoadingState
import com.intellij.diagnostic.PerformanceWatcher
import com.intellij.ide.MnemonicUsageCollector.Companion.logMnemonicUsed
import com.intellij.ide.actions.MaximizeActiveDialogAction
import com.intellij.ide.dnd.DnDManager
import com.intellij.ide.dnd.DnDManagerImpl
import com.intellij.ide.plugins.StartupAbortedException
import com.intellij.ide.ui.UISettings
import com.intellij.openapi.Disposable
import com.intellij.openapi.application.ApplicationManager
import com.intellij.openapi.application.TransactionGuard
import com.intellij.openapi.application.TransactionGuardImpl
import com.intellij.openapi.application.ex.ApplicationManagerEx
import com.intellij.openapi.application.impl.InvocationUtil
import com.intellij.openapi.components.serviceIfCreated
import com.intellij.openapi.diagnostic.ControlFlowException
import com.intellij.openapi.diagnostic.Logger
import com.intellij.openapi.diagnostic.debug
import com.intellij.openapi.diagnostic.logger
import com.intellij.openapi.extensions.ExtensionPointName
import com.intellij.openapi.keymap.impl.IdeKeyEventDispatcher
import com.intellij.openapi.keymap.impl.IdeMouseEventDispatcher
import com.intellij.openapi.keymap.impl.KeyState
import com.intellij.openapi.progress.ProgressManager
import com.intellij.openapi.ui.JBPopupMenu
import com.intellij.openapi.util.*
import com.intellij.openapi.util.registry.Registry
import com.intellij.openapi.wm.IdeFocusManager
import com.intellij.openapi.wm.WindowManager
import com.intellij.openapi.wm.ex.WindowManagerEx
import com.intellij.openapi.wm.impl.FocusManagerImpl
import com.intellij.ui.ComponentUtil
import com.intellij.util.concurrency.annotations.RequiresEdt
import com.intellij.util.containers.ContainerUtil
import com.intellij.util.ui.EDT
import com.intellij.util.ui.EdtInvocationManager
import com.intellij.util.ui.UIUtil
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.job
import org.jetbrains.annotations.ApiStatus.Internal
import org.jetbrains.annotations.TestOnly
import org.jetbrains.annotations.VisibleForTesting
import sun.awt.AppContext
import java.awt.*
import java.awt.event.*
import java.lang.invoke.MethodHandle
import java.lang.invoke.MethodHandles
import java.lang.invoke.MethodType
import java.util.concurrent.ConcurrentLinkedQueue
import java.util.concurrent.Future
import java.util.concurrent.TimeUnit
import java.util.concurrent.atomic.AtomicInteger
import java.util.function.Consumer
import javax.swing.*
import javax.swing.plaf.basic.ComboPopup

@Suppress("FunctionName")
class IdeEventQueue private constructor() : EventQueue() {
  /**
   * Adding/Removing of "idle" listeners should be thread safe.
   */
  private val lock = Any()
  private val activityListeners = ContainerUtil.createLockFreeCopyOnWriteList<Runnable>()

  val keyEventDispatcher: IdeKeyEventDispatcher = IdeKeyEventDispatcher(this)
  val mouseEventDispatcher: IdeMouseEventDispatcher = IdeMouseEventDispatcher()
  val popupManager: IdePopupManager = IdePopupManager()

  @get:Internal
  var popupTriggerTime: Long = -1
    private set

  /**
   * Counter of processed events. It is used to assert that data context lives only inside a single Swing event.
   */
  var eventCount: Int = 0

  @VisibleForTesting
  @JvmField
  val keyboardEventPosted: AtomicInteger = AtomicInteger()

  @VisibleForTesting
  @JvmField
  val keyboardEventDispatched: AtomicInteger = AtomicInteger()

  private var isInInputEvent = false
  var trueCurrentEvent: AWTEvent = InvocationEvent(this, EmptyRunnable.getInstance())
    private set

  private var currentSequencedEvent: AWTEvent? = null

  @Volatile
  private var lastActiveTime = System.nanoTime()
  private var lastEventTime = System.currentTimeMillis()
  private val dispatchers = ContainerUtil.createLockFreeCopyOnWriteList<EventDispatcher>()
  private val postProcessors = ContainerUtil.createLockFreeCopyOnWriteList<EventDispatcher>()
  private val preProcessors = ContainerUtil.createLockFreeCopyOnWriteList<EventDispatcher>()
  private val ready = HashSet<Runnable>()
  private val hoverService = HoverService()
  private var keyboardBusy = false
  private var winMetaPressed = false
  private var inputMethodLock = 0
  private val postEventListeners = ContainerUtil.createLockFreeCopyOnWriteList<PostEventHook>()
  private val runnablesWaitingFocusChange = HashMap<AWTEvent, MutableList<Runnable>>()

  private val focusEventList = ConcurrentLinkedQueue<AWTEvent>()

  @Internal
  @JvmField
  val isDispatchingOnMainThread: Boolean = Thread.currentThread().name.contains("AppKit").also {
    if (it) System.setProperty("jb.dispatching.on.main.thread", "true")
  }

  private var idleTracker: () -> Unit = {}


  private var testMode: Boolean? = null

  init {
    assert(isDispatchThread()) { Thread.currentThread() }
    val systemEventQueue = Toolkit.getDefaultToolkit().systemEventQueue
    assert(systemEventQueue !is IdeEventQueue) { systemEventQueue }
    systemEventQueue.push(this)
    EDT.updateEdt()
    replaceDefaultKeyboardFocusManager()
    addDispatcher(WindowsAltSuppressor(), null)
    if (SystemInfoRt.isWindows && java.lang.Boolean.parseBoolean(System.getProperty("keymap.windows.up.to.maximize.dialogs", "true"))) {
      // 'Windows+Up' shortcut would maximize active dialog under Win 7+
      addDispatcher(WindowsUpMaximizer(), null)
    }
    addDispatcher(EditingCanceller(), null)
    //addDispatcher(new UIMouseTracker(), null);
    abracadabraDaberBoreh()
    if (java.lang.Boolean.parseBoolean(System.getProperty("skip.move.resize.events", "true"))) {
      postEventListeners.add { skipMoveResizeEvents(it) } // hot path, do not use method reference
    }
  }

  companion object {
    private val _instance by lazy { IdeEventQueue() }

    @JvmStatic
    fun getInstance(): IdeEventQueue = _instance

    // used for GuiTests to stop IdeEventQueue when application is disposed already
    @JvmStatic
    fun applicationClose() {
      appIsLoaded = false
    }
  }

  @RequiresEdt
  internal fun setIdleTracker(value: () -> Unit) {
    EDT.assertIsEdt()
    idleTracker = value
  }

  /**
   * Executes given `runnable` after all focus activities are finished.
   *
   * @apiNote be careful with this method. It may run `runnable` synchronously in the context of the current thread, or may queue
   * runnable until the focus events queue is empty. In the latter case, runnable is going to be run while processing the last focus
   * event from the queue, without any context, e.g., outside the write-safe context. Consider using safer [IdeFocusManager.doWhenFocusSettlesDown]
   */
  fun executeWhenAllFocusEventsLeftTheQueue(runnable: Runnable) {
    ifFocusEventsInTheQueue(
      yes = { e ->
        var runnables = runnablesWaitingFocusChange.get(e)
        if (runnables == null) {
          runnables = mutableListOf()
          runnables.add(runnable)
          runnablesWaitingFocusChange.put(e, runnables)
        }
        else {
          Logs.FOCUS_AWARE_RUNNABLES_LOG.debug { "We have already had a runnable for the event: $e" }
          runnables.add(runnable)
        }
      },
      no = runnable,
    )
  }

  private fun runnablesWaitingForFocusChangeState(): String {
    return focusEventList.joinToString(separator = ", ") { event -> "[${event.id}; ${event.source.javaClass.name}]" }
  }

  private fun getLastFocusGainedEvent(): AWTEvent? = focusEventList.lastOrNull { it.id == FocusEvent.FOCUS_GAINED }

  private fun ifFocusEventsInTheQueue(yes: (AWTEvent) -> Unit, no: Runnable) {
    val lastFocusGainedEvent = getLastFocusGainedEvent()
    if (lastFocusGainedEvent != null) {
      Logs.FOCUS_AWARE_RUNNABLES_LOG.debug {
        "Focus event list (trying to execute runnable): ${runnablesWaitingForFocusChangeState()}\n" +
        "runnable saved for : [${lastFocusGainedEvent.id}; ${lastFocusGainedEvent.source}] -> ${no.javaClass.name}"
      }
      yes(lastFocusGainedEvent)
    }
    else {
      Logs.FOCUS_AWARE_RUNNABLES_LOG.debug { "No focus gained event in the queue runnable is run on EDT if needed : ${no.javaClass.name}" }
      EdtInvocationManager.invokeLaterIfNeeded(no)
    }
  }

  @Suppress("SpellCheckingInspection")
  private fun abracadabraDaberBoreh() {
    // We need to track if there are KeyBoardEvents in IdeEventQueue
    // So we want to intercept all events posted to IdeEventQueue and increment counters
    // However, the regular control flow goes like this:
    //    PostEventQueue.flush() -> EventQueue.postEvent() -> IdeEventQueue.postEventPrivate() -> AAAA we missed event, because postEventPrivate() can't be overridden.
    // Instead, we do following:
    //  - create new PostEventQueue holding our IdeEventQueue instead of old EventQueue
    //  - replace "PostEventQueue" value in AppContext with this new PostEventQueue
    // After that the control flow goes like this:
    //    PostEventQueue.flush() -> IdeEventQueue.postEvent() -> We intercepted event, incremented counters.
    val aClass = Class.forName("sun.awt.PostEventQueue")
    val constructor = aClass.getDeclaredConstructor(EventQueue::class.java)
    constructor.isAccessible = true
    val postEventQueue = constructor.newInstance(this)
    AppContext.getAppContext().put("PostEventQueue", postEventQueue)
  }

  @Suppress("DeprecatedCallableAddReplaceWith")
  @Deprecated("Use IdleFlow and coroutines")
  fun addIdleListener(runnable: Runnable, timeoutMillis: Int) {
    @Suppress("DEPRECATION")
    IdleTracker.getInstance().addIdleListener(runnable = runnable, timeoutMillis = timeoutMillis)
  }

  @Suppress("DeprecatedCallableAddReplaceWith")
  @Deprecated("Use IdleFlow and coroutines")
  fun removeIdleListener(runnable: Runnable) {
    @Suppress("DEPRECATION")
    IdleTracker.getInstance().removeIdleListener(runnable)
  }

  fun addActivityListener(runnable: Runnable, parentDisposable: Disposable) {
    activityListeners.add(runnable)
    Disposer.register(parentDisposable) { activityListeners.remove(runnable) }
  }

  fun addActivityListener(runnable: Runnable, coroutineScope: CoroutineScope) {
    activityListeners.add(runnable)
    coroutineScope.coroutineContext.job.invokeOnCompletion {
      activityListeners.remove(runnable)
    }
  }

  fun addDispatcher(dispatcher: EventDispatcher, parent: Disposable?) {
    _addProcessor(dispatcher, parent, dispatchers)
  }

  fun addDispatcher(dispatcher: EventDispatcher, scope: CoroutineScope) {
    dispatchers.add(dispatcher)
    scope.coroutineContext.job.invokeOnCompletion {
      dispatchers.remove(dispatcher)
    }
  }

  fun removeDispatcher(dispatcher: EventDispatcher) {
    dispatchers.remove(dispatcher)
  }

  fun containsDispatcher(dispatcher: EventDispatcher): Boolean {
    return dispatchers.contains(dispatcher)
  }

  fun addPostprocessor(dispatcher: EventDispatcher, parent: Disposable?) {
    _addProcessor(dispatcher, parent, postProcessors)
  }

  fun removePostprocessor(dispatcher: EventDispatcher) {
    postProcessors.remove(dispatcher)
  }

  fun addPreprocessor(dispatcher: EventDispatcher, parent: Disposable?) {
    _addProcessor(dispatcher, parent, preProcessors)
  }

  public override fun dispatchEvent(e: AWTEvent) {
    var event = e

    // DO NOT ADD ANYTHING BEFORE fixNestedSequenceEvent is called
    val startedAt = System.currentTimeMillis()
    val performanceWatcher = PerformanceWatcher.getInstanceIfCreated()
    val eventWatcher = EventWatcher.getInstanceOrNull()
    try {
      performanceWatcher?.edtEventStarted()
      eventWatcher?.edtEventStarted(event, startedAt)
      fixNestedSequenceEvent(event)
      // Add code below if you need

      // Update EDT if it changes (might happen after Application disposal)
      EDT.updateEdt()
      if (event.id == WindowEvent.WINDOW_ACTIVATED || event.id == WindowEvent.WINDOW_DEICONIFIED || event.id == WindowEvent.WINDOW_OPENED) {
        ActiveWindowsWatcher.addActiveWindow(event.source as Window)
      }

      if (isMetaKeyPressedOnLinux(event)) {
        return
      }

      if (event.source is TrayIcon) {
        dispatchTrayIconEvent(event)
        return
      }

      checkForTimeJump(startedAt)
      hoverService.process(event)

      if (!appIsLoaded()) {
        try {
          super.dispatchEvent(event)
        }
        catch (t: Throwable) {
          processException(t)
        }
        return
      }

      event = mapEvent(event)
      val metaEvent = mapMetaState(event)
      if (metaEvent != null && Registry.`is`("keymap.windows.as.meta", false)) {
        event = metaEvent
      }
      if (SystemInfoRt.isMac && event is InputEvent) {
        disableAltGrUnsupportedOnMac(event)
      }

      val wasInputEvent = isInInputEvent
      isInInputEvent = isInputEvent(event)
      val oldEvent = trueCurrentEvent
      trueCurrentEvent = event
      val finalEvent = event
      val runnable = InvocationUtil.extractRunnable(event)
      val runnableClass = runnable?.javaClass ?: Runnable::class.java
      val processEventRunnable = Runnable {
        val app = ApplicationManager.getApplication()
        val progressManager = if (app != null && !app.isDisposed) {
          try {
            ProgressManager.getInstance()
          }
          catch (ex: RuntimeException) {
            Logs.LOG.warn("app services aren't yet initialized", ex)
            null
          }
        }
        else {
          null
        }

        try {
          runCustomProcessors(finalEvent, preProcessors)
          performActivity(finalEvent) {
            if (progressManager == null) {
              _dispatchEvent(finalEvent)
            }
            else {
              progressManager.computePrioritized(ThrowableComputable {
                _dispatchEvent(finalEvent)
                null
              })
            }
          }
        }
        catch (t: Throwable) {
          processException(t)
        }
        finally {
          isInInputEvent = wasInputEvent
          trueCurrentEvent = oldEvent
          if (currentSequencedEvent === finalEvent) {
            currentSequencedEvent = null
          }
          runCustomProcessors(finalEvent, postProcessors)
          if (finalEvent is KeyEvent) {
            maybeReady()
          }
          if (eventWatcher != null && runnable != null && !InvocationUtil.isFlushNow(runnable)) {
            eventWatcher.logTimeMillis(if (runnableClass == Runnable::class.java) finalEvent.toString() else runnableClass.name,
                                       startedAt,
                                       runnableClass)
          }
        }
        if (isFocusEvent(finalEvent)) {
          onFocusEvent(finalEvent)
        }
      }

      if (runnableClass == InvocationUtil.REPAINT_PROCESSING_CLASS) {
        processEventRunnable.run()
        return
      }

      if (defaultEventWithWrite) {
        ApplicationManagerEx.getApplicationEx().runIntendedWriteActionOnCurrentThread(processEventRunnable)
      }
      else {
        processEventRunnable.run()
      }
    }
    finally {
      Thread.interrupted()
      if (event is WindowEvent || event is FocusEvent || event is InputEvent) {
        // Increment the activity counter right before notifying listeners
        // so that the listeners would get data providers with fresh data
        incrementActivityCountIfNeeded(e)
        processIdleActivityListeners(event)
      }
      performanceWatcher?.edtEventFinished()
      eventWatcher?.edtEventFinished(event, System.currentTimeMillis())
    }
  }

  private fun runCustomProcessors(event: AWTEvent, processors: List<EventDispatcher>) {
    for (each in processors) {
      try {
        each.dispatch(event)
      }
      catch (t: Throwable) {
        processException(t)
      }
    }
  }

  // Fixes IDEA-218430: nested sequence events cause deadlock
  private fun fixNestedSequenceEvent(e: AWTEvent) {
    if (e.javaClass == SequencedEventNestedFieldHolder.SEQUENCED_EVENT_CLASS) {
      if (currentSequencedEvent != null) {
        val sequenceEventToDispose = currentSequencedEvent!!
        currentSequencedEvent = null // Set to null BEFORE dispose b/c `dispose` can dispatch events internally
        SequencedEventNestedFieldHolder.invokeDispose(sequenceEventToDispose)
      }
      currentSequencedEvent = e
    }
  }

  private fun onFocusEvent(event: AWTEvent) {
    Logs.FOCUS_AWARE_RUNNABLES_LOG.debug { "Focus event list (execute on focus event): " + runnablesWaitingForFocusChangeState() }
    val events = mutableListOf<AWTEvent>()
    while (!focusEventList.isEmpty()) {
      val f = focusEventList.poll()
      events.add(f)
      if (f == event) {
        break
      }
    }

    for (entry in events) {
      val runnables = runnablesWaitingFocusChange.remove(entry) ?: continue
      for (r in runnables) {
        if (r !is ExpirableRunnable || !r.isExpired) {
          try {
            r.run()
          }
          catch (e: Throwable) {
            processException(e)
          }
        }
      }
    }
  }

  // as we rely on system time monotonicity in many places, let's log anomalies at least
  private fun checkForTimeJump(now: Long) {
    if (lastEventTime > now + 1000) {
      Logs.LOG.warn("System clock's jumped back by ~${(lastEventTime - now) / 1000} sec")
    }
    lastEventTime = now
  }

  override fun getNextEvent(): AWTEvent {
    val applicationEx = ApplicationManagerEx.getApplicationEx()
    val event = if (applicationEx != null && appIsLoaded()) {
      applicationEx.runUnlockingIntendedWrite<AWTEvent, InterruptedException> { super.getNextEvent() }
    }
    else {
      super.getNextEvent()
    }
    if (isKeyboardEvent(event) && keyboardEventDispatched.incrementAndGet() > keyboardEventPosted.get()) {
      throw RuntimeException("$event; posted: $keyboardEventPosted; dispatched: $keyboardEventDispatched")
    }
    return event
  }

  private fun processException(exception: Throwable) {
    var t = exception
    if (isTestMode()) {
      throw t
    }

    if (t is ControlFlowException && java.lang.Boolean.getBoolean("report.control.flow.exceptions.in.edt")) {
      // 'bare' ControlFlowException-s are not reported
      t = RuntimeException(t)
    }
    StartupAbortedException.processException(t)
  }

  /**
   * Here we try to use 'Windows' a key like modifier, so we patch events with modifier 'Meta'
   * when 'Windows' key was pressed and still is not released.
   *
   * @param e event to be patched
   * @return new 'patched' event if you need, otherwise null
   *
   * Note: As a side effect, this method tracks a special flag for 'Windows' key state that is valuable in itself
   */
  private fun mapMetaState(e: AWTEvent): AWTEvent? {
    if (winMetaPressed) {
      val app = ApplicationManager.getApplication()
      var weAreNotActive = app == null || !app.isActive
      weAreNotActive = weAreNotActive or (e is FocusEvent && e.oppositeComponent == null)
      if (weAreNotActive) {
        winMetaPressed = false
        return null
      }
    }

    if (e is KeyEvent) {
      if (e.keyCode == KeyEvent.VK_WINDOWS) {
        if (e.id == KeyEvent.KEY_PRESSED) winMetaPressed = true
        if (e.id == KeyEvent.KEY_RELEASED) winMetaPressed = false
        return null
      }
      if (winMetaPressed) {
        @Suppress("DEPRECATION")
        return KeyEvent(e.component, e.id, e.getWhen(), UIUtil.getAllModifiers(e) or Event.META_MASK,
                        e.keyCode,
                        e.keyChar, e.keyLocation)
      }
    }

    if (winMetaPressed && e is MouseEvent && e.button != 0) {
      @Suppress("DEPRECATION")
      return MouseEvent(e.component, e.id, e.getWhen(), UIUtil.getAllModifiers(e) or Event.META_MASK,
                        e.x, e.y,
                        e.clickCount, e.isPopupTrigger, e.button)
    }
    return null
  }

  private fun _dispatchEvent(e: AWTEvent) {
    if (e.id == MouseEvent.MOUSE_DRAGGED && appIsLoaded()) {
      (DnDManager.getInstance() as? DnDManagerImpl)?.lastDropHandler = null
    }
    eventCount++
    keyboardBusy = e is KeyEvent || keyboardEventPosted.get() > keyboardEventDispatched.get()
    if (e is KeyEvent) {
      if (e.getID() == KeyEvent.KEY_RELEASED && e.keyCode == KeyEvent.VK_SHIFT) {
        mouseEventDispatcher.resetHorScrollingTracker()
      }
    }
    if (e is MouseWheelEvent && processMouseWheelEvent(e)) {
      return
    }

    // increment the activity counter before performing the action
    // so that they are called with data providers with fresh data
    incrementActivityCountIfNeeded(e)
    if (popupManager.isPopupActive && popupManager.dispatch(e)) {
      if (keyEventDispatcher.isWaitingForSecondKeyStroke) {
        keyEventDispatcher.state = KeyState.STATE_INIT
      }
      return
    }

    if (e is WindowEvent) {
      processAppActivationEvent(e)
    }
    if (dispatchByCustomDispatchers(e)) {
      return
    }
    if (e is InputMethodEvent && SystemInfoRt.isMac && keyEventDispatcher.isWaitingForSecondKeyStroke) {
      return
    }

    val application = ApplicationManagerEx.getApplicationEx()
    if (e is ComponentEvent && appIsLoaded && !application.isHeadlessEnvironment) {
      (application.serviceIfCreated<WindowManager>() as WindowManagerEx?)?.dispatchComponentEvent(e)
    }
    when (e) {
      is KeyEvent -> dispatchKeyEvent(e)
      is MouseEvent -> dispatchMouseEvent(e)
      else -> application.runWithoutImplicitRead { defaultDispatchEvent(e) }
    }
  }

  private fun isActivityInputEvent(e: AWTEvent): Boolean =
    KeyEvent.KEY_PRESSED == e.id ||
    KeyEvent.KEY_TYPED == e.id ||
    MouseEvent.MOUSE_PRESSED == e.id ||
    MouseEvent.MOUSE_RELEASED == e.id ||
    MouseEvent.MOUSE_CLICKED == e.id

  private fun incrementActivityCountIfNeeded(e: AWTEvent) {
    if (isActivityInputEvent(e) || e is WindowEvent || e is FocusEvent) {
      ActivityTracker.getInstance().inc()
    }
  }

  private fun processIdleActivityListeners(e: AWTEvent) {
    idleTracker()
    if (!isActivityInputEvent(e)) return
    synchronized(lock) {
      lastActiveTime = System.nanoTime()
      for (activityListener in activityListeners) {
        activityListener.run()
      }
    }
  }

  private fun dispatchKeyEvent(e: AWTEvent) {
    if (keyEventDispatcher.dispatchKeyEvent(e as KeyEvent)) {
      e.consume()
    }
    defaultDispatchEvent(e)
  }

  private fun dispatchMouseEvent(e: AWTEvent) {
    val me = e as MouseEvent
    @Suppress("DEPRECATION")
    if (me.id == MouseEvent.MOUSE_PRESSED && me.modifiers > 0 && me.modifiersEx == 0) {
      resetGlobalMouseEventTarget(me)
    }
    if (IdeMouseEventDispatcher.patchClickCount(me) && me.id == MouseEvent.MOUSE_CLICKED) {
      redispatchLater(me)
    }
    if (!mouseEventDispatcher.dispatchMouseEvent(me)) {
      defaultDispatchEvent(e)
    }
  }

  /**
   * [java.awt.LightweightDispatcher.processMouseEvent] uses a recent 'active' component
   * from inner WeakReference (see [LightweightDispatcher.mouseEventTarget]) even if the component has been already removed from component hierarchy.
   * So we have to reset this WeakReference with synthetic event just before processing of the actual event
   */
  private fun resetGlobalMouseEventTarget(me: MouseEvent) {
    super.dispatchEvent(MouseEvent(me.component, MouseEvent.MOUSE_MOVED, me.getWhen(), 0, me.x, me.y, 0, false, 0))
  }

  private fun redispatchLater(me: MouseEvent) {
    @Suppress("DEPRECATION")
    val toDispatch = MouseEvent(me.component, me.id, System.currentTimeMillis(), me.modifiers, me.x, me.y, 1, me.isPopupTrigger, me.button)
    SwingUtilities.invokeLater { dispatchEvent(toDispatch) }
  }

  private fun dispatchByCustomDispatchers(e: AWTEvent): Boolean {
    for (eachDispatcher in dispatchers) {
      try {
        if (eachDispatcher.dispatch(e)) {
          return true
        }
      }
      catch (t: Throwable) {
        processException(t)
      }
    }
    for (eachDispatcher in DISPATCHER_EP.extensionsIfPointIsRegistered) {
      try {
        if (eachDispatcher.dispatch(e)) {
          return true
        }
      }
      catch (t: Throwable) {
        processException(t)
      }
    }
    return false
  }

  private fun defaultDispatchEvent(e: AWTEvent) {
    try {
      maybeReady()
      val me = if (e is MouseEvent) e else null
      val ke = if (e is KeyEvent) e else null
      val consumed = ke == null || ke.isConsumed
      if (me != null && (me.isPopupTrigger || e.id == MouseEvent.MOUSE_PRESSED) || ke != null && ke.keyCode == KeyEvent.VK_CONTEXT_MENU) {
        popupTriggerTime = System.currentTimeMillis()
      }
      super.dispatchEvent(e)
      // collect mnemonics statistics only if key event was processed above
      if (!consumed && ke!!.isConsumed && KeyEvent.KEY_PRESSED == ke.id) {
        logMnemonicUsed(ke)
      }
    }
    catch (t: Throwable) {
      processException(t)
    }
  }

  @Internal
  fun flushQueue() {
    EDT.assertIsEdt()
    resetThreadContext().use {
      while (true) {
        peekEvent() ?: return
        try {
          dispatchEvent(nextEvent)
        }
        catch (e: Exception) {
          Logs.LOG.error(e)
        }
      }
    }
  }

  fun pumpEventsForHierarchy(modalComponent: Component, exitCondition: Future<*>, eventConsumer: Consumer<AWTEvent>) {
    EDT.assertIsEdt()
    Logs.LOG.debug { "pumpEventsForHierarchy($modalComponent, $exitCondition)" }

    while (!exitCondition.isDone) {
      try {
        val event = nextEvent
        val consumed = consumeUnrelatedEvent(modalComponent, event)
        if (!consumed) {
          dispatchEvent(event)
        }
        eventConsumer.accept(event)
      }
      catch (e: Throwable) {
        Logs.LOG.error(e)
      }
    }
    Logs.LOG.debug { "pumpEventsForHierarchy.exit($modalComponent, $exitCondition)" }
  }

  fun interface EventDispatcher {
    fun dispatch(e: AWTEvent): Boolean
  }

  val idleTime: Long
    get() = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - lastActiveTime)

  /**
   * When `blockMode` is `COMPLETE`, blocks following related mouse events completely, when `blockMode` is
   * `ACTIONS` only blocks performing actions bound to corresponding mouse shortcuts.
   */
  /**
   * Same as [.blockNextEvents] with `blockMode` equal to `COMPLETE`.
   */
  @JvmOverloads
  fun blockNextEvents(e: MouseEvent, blockMode: BlockMode = BlockMode.COMPLETE) {
    mouseEventDispatcher.blockNextEvents(e, blockMode)
  }

  private val isReady: Boolean
    get() = !keyboardBusy && keyEventDispatcher.isReady

  internal fun maybeReady() {
    if (ready.isNotEmpty() && isReady) {
      invokeReadyHandlers()
    }
  }

  private fun invokeReadyHandlers() {
    val ready = ready.toTypedArray()
    this.ready.clear()
    for (each in ready) {
      each.run()
    }
  }

  fun doWhenReady(runnable: Runnable) {
    if (isDispatchThread()) {
      ready.add(runnable)
      maybeReady()
    }
    else {
      SwingUtilities.invokeLater {
        ready.add(runnable)
        maybeReady()
      }
    }
  }

  val isPopupActive: Boolean
    get() = popupManager.isPopupActive

  //Windows OS doesn't support a Windows+Up/Down shortcut for dialogs, so we provide a workaround
  private inner class WindowsUpMaximizer : EventDispatcher {
    override fun dispatch(e: AWTEvent): Boolean {
      if ((winMetaPressed
           && e is KeyEvent && e.getID() == KeyEvent.KEY_RELEASED) && (e.keyCode == KeyEvent.VK_UP || e.keyCode == KeyEvent.VK_DOWN)) {
        val parent: Component? = ComponentUtil.getWindow(e.component)
        if (parent is JDialog) {
          SwingUtilities.invokeLater {
            if (e.keyCode == KeyEvent.VK_UP) {
              MaximizeActiveDialogAction.maximize(parent)
            }
            else {
              MaximizeActiveDialogAction.normalize(parent)
            }
          }
          return true
        }
      }
      return false
    }
  }

  val isInputMethodEnabled: Boolean
    get() = !SystemInfoRt.isMac || inputMethodLock == 0

  fun disableInputMethods(parentDisposable: Disposable) {
    inputMethodLock++
    Disposer.register(parentDisposable) { inputMethodLock-- }
  }

  override fun postEvent(event: AWTEvent) {
    doPostEvent(event)
  }

  // return true if posted, false if consumed immediately
  fun doPostEvent(event: AWTEvent): Boolean {
    for (listener in postEventListeners) {
      if (listener(event)) {
        return false
      }
    }
    if (event is InvocationEvent && !isCurrentlyUnderLocalId) {
      // only do wrapping trickery with non-local events to preserve correct behavior -
      // local events will get dispatched under local ID anyway
      val clientId = current
      super.postEvent(InvocationEvent(event.getSource()) { withClientId(clientId).use { dispatchEvent(event) } })
      return true
    }
    if (event is KeyEvent) {
      keyboardEventPosted.incrementAndGet()
    }
    if (isFocusEvent(event)) {
      focusEventList.add(event)
    }
    super.postEvent(event)
    return true
  }

  @Deprecated("Does nothing currently")
  fun flushDelayedKeyEvents() {
  }

  private fun isTestMode(): Boolean {
    var testMode = testMode
    if (testMode != null) {
      return testMode
    }
    val application = ApplicationManager.getApplication() ?: return false
    testMode = application.isUnitTestMode
    this.testMode = testMode
    return testMode
  }

  @TestOnly
  fun executeInProductionModeEvenThoughWeAreInTests(runnable: Runnable) {
    assert(ApplicationManager.getApplication().isUnitTestMode)
    testMode = false
    try {
      runnable.run()
    }
    finally {
      testMode = true
    }
  }

  /**
   * @see IdeEventQueue.blockNextEvents
   */
  enum class BlockMode {
    COMPLETE,
    ACTIONS
  }

  fun addPostEventListener(listener: PostEventHook, parentDisposable: Disposable) {
    postEventListeners.add(listener)
    Disposer.register(parentDisposable) {
      postEventListeners.remove(listener)
    }
  }
}

// IdeEventQueue is created before log configuration - cannot be initialized as a part of IdeEventQueue
private object Logs {
  @JvmField
  val LOG: Logger = logger<IdeEventQueue>()

  @JvmField
  val FOCUS_AWARE_RUNNABLES_LOG: Logger = Logger.getInstance(IdeEventQueue::class.java.name + ".runnables")
}

/**
 * An absolute guru API, please avoid using it at all costs.
 * @return true, if event is handled by the listener and shouldn't be added to an event queue at all
 */
typealias PostEventHook = (event: AWTEvent) -> Boolean

private val DISPATCHER_EP = ExtensionPointName<IdeEventQueue.EventDispatcher>("com.intellij.ideEventQueueDispatcher")

@Suppress("ConstPropertyName")
private const val defaultEventWithWrite = true

private val isSkipMetaPressOnLinux = java.lang.Boolean.getBoolean("keymap.skip.meta.press.on.linux")

private var transactionGuard: TransactionGuardImpl? = null

private fun skipMoveResizeEvents(event: AWTEvent): Boolean {
  // JList, JTable and JTree paint every cell/row/column using the following method:
  //   CellRendererPane.paintComponent(Graphics, Component, Container, int, int, int, int, boolean)
  // This method sets bounds to a renderer component and invokes the following internal method:
  //   Component.notifyNewBounds
  // All default and simple renderers do not post specified events,
  // but panel-based renderers have to post events by contract.
  when (event.id) {
    ComponentEvent.COMPONENT_MOVED, ComponentEvent.COMPONENT_RESIZED, HierarchyEvent.ANCESTOR_MOVED, HierarchyEvent.ANCESTOR_RESIZED -> {
      val source = event.source
      if (source is Component && ComponentUtil.getParentOfType(CellRendererPane::class.java, source) != null) {
        return true
      }
    }
  }
  return false
}

private fun _addProcessor(dispatcher: IdeEventQueue.EventDispatcher,
                          parent: Disposable?,
                          set: MutableCollection<IdeEventQueue.EventDispatcher>) {
  set.add(dispatcher)
  if (parent != null) {
    Disposer.register(parent) { set.remove(dispatcher) }
  }
}

private var appIsLoaded = false

private fun appIsLoaded(): Boolean {
  return when {
    appIsLoaded -> true
    LoadingState.COMPONENTS_LOADED.isOccurred -> {
      appIsLoaded = true
      true
    }
    else -> appIsLoaded
  }
}

private fun dispatchTrayIconEvent(e: AWTEvent) {
  if (e is ActionEvent) {
    for (listener in (e.getSource() as TrayIcon).actionListeners) {
      listener.actionPerformed(e)
    }
  }
}

private fun disableAltGrUnsupportedOnMac(e: AWTEvent) {
  if (e is KeyEvent && e.keyCode == KeyEvent.VK_ALT_GRAPH) {
    e.keyCode = KeyEvent.VK_ALT
  }
  IdeKeyEventDispatcher.removeAltGraph((e as InputEvent))
}

private fun isMetaKeyPressedOnLinux(e: AWTEvent): Boolean {
  if (!isSkipMetaPressOnLinux) {
    return false
  }

  val metaIsPressed = e is InputEvent && e.modifiersEx and InputEvent.META_DOWN_MASK != 0
  val typedKeyEvent = e.id == KeyEvent.KEY_TYPED
  return SystemInfoRt.isLinux && typedKeyEvent && metaIsPressed
}

private fun isInputEvent(e: AWTEvent): Boolean {
  return e is InputEvent || e is InputMethodEvent || e is WindowEvent || e is ActionEvent
}

internal fun performActivity(e: AWTEvent, runnable: () -> Unit) {
  var transactionGuard = transactionGuard
  if (transactionGuard == null && appIsLoaded()) {
    val app = ApplicationManager.getApplication()
    if (app != null && !app.isDisposed) {
      transactionGuard = TransactionGuard.getInstance() as TransactionGuardImpl
      com.intellij.ide.transactionGuard = transactionGuard
    }
  }

  if (transactionGuard == null) {
    runnable()
  }
  else {
    transactionGuard.performActivity(isInputEvent(e) || e is ItemEvent || e is FocusEvent, runnable)
  }
}

private fun mapEvent(e: AWTEvent): AWTEvent {
  return if (SystemInfoRt.isXWindow && e is MouseEvent && e.button > 3) mapXWindowMouseEvent(e) else e
}

private fun mapXWindowMouseEvent(src: MouseEvent): AWTEvent {
  if (src.button < 6) {
    // Convert these events(buttons 4&5 in are produced by touchpad, they must be converted to horizontal scrolling events
    @Suppress("DEPRECATION")
    return MouseWheelEvent(src.component, MouseEvent.MOUSE_WHEEL, src.getWhen(),
                           src.modifiers or InputEvent.SHIFT_DOWN_MASK, src.x, src.y,
                           0, false, MouseWheelEvent.WHEEL_UNIT_SCROLL, src.clickCount,
                           if (src.button == 4) -1 else 1)
  }
  else {
    // Here we "shift" events with buttons 6 and 7 to similar events with buttons 4 and 5
    // See java.awt.InputEvent#BUTTON_DOWN_MASK, 1<<14 is 4th physical button, 1<<15 is 5th.
    @Suppress("DEPRECATION")
    return MouseEvent(src.component, src.id, src.getWhen(),
                      src.modifiers or (1 shl 8 + src.button),
                      src.x, src.y, 1, src.isPopupTrigger, src.button - 2)
  }
}

private fun processMouseWheelEvent(e: MouseWheelEvent): Boolean {
  val selectedPath = MenuSelectionManager.defaultManager().selectedPath
  if (selectedPath.isEmpty() || selectedPath[0] is ComboPopup) {
    return false
  }

  e.consume()
  (selectedPath[0].component as? JBPopupMenu)?.processMouseWheelEvent(e)
  return true
}

private fun processAppActivationEvent(event: WindowEvent) {
  ApplicationActivationStateManager.updateState(event)
  if (event.id != WindowEvent.WINDOW_DEACTIVATED && event.id != WindowEvent.WINDOW_LOST_FOCUS) {
    return
  }

  val eventWindow = event.window
  val focusOwnerInDeactivatedWindow = eventWindow.mostRecentFocusOwner ?: return
  if (!appIsLoaded()) {
    return
  }

  val windowManager = ApplicationManager.getApplication().serviceIfCreated<WindowManager>() as WindowManagerEx? ?: return
  val frame = ComponentUtil.findUltimateParent(eventWindow)
  for (frameHelper in windowManager.projectFrameHelpers) {
    if (frame === frameHelper.frame) {
      val focusManager = IdeFocusManager.getGlobalInstance()
      if (focusManager is FocusManagerImpl) {
        focusManager.setLastFocusedAtDeactivation(frame as Window, focusOwnerInDeactivatedWindow)
      }
    }
  }
}

private fun isFocusEvent(e: AWTEvent): Boolean {
  return e.id == FocusEvent.FOCUS_GAINED ||
         e.id == FocusEvent.FOCUS_LOST ||
         e.id == WindowEvent.WINDOW_ACTIVATED ||
         e.id == WindowEvent.WINDOW_DEACTIVATED ||
         e.id == WindowEvent.WINDOW_LOST_FOCUS ||
         e.id == WindowEvent.WINDOW_GAINED_FOCUS
}

private fun isKeyboardEvent(event: AWTEvent): Boolean = event is KeyEvent

// return true if consumed
internal fun consumeUnrelatedEvent(modalComponent: Component?, event: AWTEvent): Boolean {
  if (modalComponent == null) {
    if (event is InputEvent && event.getSource() is Component) {
      Logs.LOG.debug { "pumpEventsForHierarchy.consumed: $event" }
      event.consume()
      return true
    }
    else {
      return false
    }
  }

  var consumed = false
  if (event is InputEvent) {
    val s = event.getSource()
    if (s is Component) {
      var c: Component? = s
      val modalWindow = SwingUtilities.windowForComponent(modalComponent)
      while (c != null && c !== modalWindow) {
        c = c.parent
      }
      if (c == null) {
        consumed = true
        Logs.LOG.debug { "pumpEventsForHierarchy.consumed: $event" }
        event.consume()
      }
    }
  }
  return consumed
}

private object SequencedEventNestedFieldHolder {
  private val DISPOSE_METHOD: MethodHandle

  @JvmField
  val SEQUENCED_EVENT_CLASS: Class<*> = SequencedEventNestedFieldHolder::class.java.classLoader.loadClass("java.awt.SequencedEvent")

  fun invokeDispose(event: AWTEvent) {
    DISPOSE_METHOD.invoke(event)
  }

  init {
    DISPOSE_METHOD = MethodHandles.privateLookupIn(SEQUENCED_EVENT_CLASS, MethodHandles.lookup())
      .findVirtual(SEQUENCED_EVENT_CLASS, "dispose", MethodType.methodType(Void.TYPE))
  }
}

/**
 * This should've been an item in [IdeEventQueue.dispatchers],
 * but [IdeEventQueue.dispatchByCustomDispatchers] is run after [IdePopupManager.dispatch]
 * and after [processAppActivationEvent], which defeats the very purpose of this flag.
 */
@Internal
internal var skipWindowDeactivationEvents: Boolean = false

// we have to stop editing with <ESC> (if any) and consume the event to prevent any further processing (dialog closing etc.)
private class EditingCanceller : IdeEventQueue.EventDispatcher {
  override fun dispatch(e: AWTEvent): Boolean {
    return e is KeyEvent && e.getID() == KeyEvent.KEY_PRESSED && e.keyCode == KeyEvent.VK_ESCAPE &&
           !IdeEventQueue.getInstance().popupManager.isPopupActive && cancelCellEditing()
  }
}

private fun cancelCellEditing(): Boolean {
  val owner = ComponentUtil.findParentByCondition(KeyboardFocusManager.getCurrentKeyboardFocusManager().focusOwner) { component ->
    component is JTable || component is JTree
  }
  return when {
    owner is JTable && owner.isEditing -> {
      owner.editingCanceled(null)
      true
    }
    owner is JTree && owner.isEditing -> {
      owner.cancelEditing()
      true
    }
    else -> false
  }
}

private class WindowsAltSuppressor : IdeEventQueue.EventDispatcher {
  private var waitingForAltRelease = false
  private var robot: Robot? = null

  override fun dispatch(e: AWTEvent): Boolean = e is KeyEvent && dispatchKeyEvent(e)

  private fun dispatchKeyEvent(ke: KeyEvent): Boolean {
    @Suppress("DEPRECATION")
    val pureAlt = ke.keyCode == KeyEvent.VK_ALT && ke.modifiers or InputEvent.ALT_MASK == InputEvent.ALT_MASK
    if (!pureAlt) {
      waitingForAltRelease = false
      return false
    }

    val uiSettings = UISettings.instanceOrNull
    if (uiSettings == null ||
        !SystemInfoRt.isWindows ||
        !Registry.`is`("actionSystem.win.suppressAlt", true) ||
        !(uiSettings.hideToolStripes || uiSettings.presentationMode)) {
      return false
    }

    val component = ke.component
    var dispatch = true
    if (ke.id == KeyEvent.KEY_PRESSED) {
      dispatch = !waitingForAltRelease
    }
    else if (ke.id == KeyEvent.KEY_RELEASED) {
      if (waitingForAltRelease) {
        waitingForAltRelease = false
        dispatch = false
      }
      else if (component != null) {
        EventQueue.invokeLater {
          try {
            val window = ComponentUtil.getWindow(component)
            if (window == null || !window.isActive) {
              return@invokeLater
            }
            waitingForAltRelease = true
            if (robot == null) {
              robot = Robot()
            }
            robot!!.keyPress(KeyEvent.VK_ALT)
            robot!!.keyRelease(KeyEvent.VK_ALT)
          }
          catch (e1: AWTException) {
            Logs.LOG.debug(e1)
          }
        }
      }
    }
    return !dispatch
  }
}


ApplicationImpl-
// Copyright 2000-2023 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package com.intellij.openapi.application.impl;

import com.intellij.CommonBundle;
import com.intellij.codeWithMe.ClientId;
import com.intellij.configurationStore.StoreUtil;
import com.intellij.diagnostic.*;
import com.intellij.featureStatistics.fusCollectors.LifecycleUsageTriggerCollector;
import com.intellij.ide.*;
import com.intellij.ide.plugins.ContainerDescriptor;
import com.intellij.ide.plugins.IdeaPluginDescriptorImpl;
import com.intellij.idea.*;
import com.intellij.openapi.Disposable;
import com.intellij.openapi.application.*;
import com.intellij.openapi.application.ex.ApplicationEx;
import com.intellij.openapi.application.ex.ApplicationUtil;
import com.intellij.openapi.client.ClientAwareComponentManager;
import com.intellij.openapi.diagnostic.Attachment;
import com.intellij.openapi.diagnostic.Logger;
import com.intellij.openapi.diagnostic.RuntimeExceptionWithAttachments;
import com.intellij.openapi.progress.*;
import com.intellij.openapi.progress.impl.CoreProgressManager;
import com.intellij.openapi.progress.impl.ProgressResult;
import com.intellij.openapi.progress.impl.ProgressRunner;
import com.intellij.openapi.progress.util.PotemkinProgress;
import com.intellij.openapi.progress.util.ProgressWindow;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.project.ProjectManager;
import com.intellij.openapi.project.ex.ProjectManagerEx;
import com.intellij.openapi.ui.DoNotAskOption;
import com.intellij.openapi.ui.MessageDialogBuilder;
import com.intellij.openapi.ui.Messages;
import com.intellij.openapi.util.*;
import com.intellij.openapi.util.registry.Registry;
import com.intellij.openapi.util.text.StringUtil;
import com.intellij.openapi.vfs.VirtualFileManager;
import com.intellij.platform.diagnostic.telemetry.IJTracer;
import com.intellij.platform.diagnostic.telemetry.TelemetryManager;
import com.intellij.platform.diagnostic.telemetry.helpers.TraceUtil;
import com.intellij.psi.util.ReadActionCache;
import com.intellij.serviceContainer.ComponentManagerImpl;
import com.intellij.ui.ComponentUtil;
import com.intellij.util.*;
import com.intellij.util.concurrency.AppExecutorUtil;
import com.intellij.util.concurrency.AppScheduledExecutorService;
import com.intellij.util.concurrency.Propagation;
import com.intellij.util.containers.Stack;
import com.intellij.util.messages.Topic;
import com.intellij.util.ui.EDT;
import io.opentelemetry.api.trace.Span;
import io.opentelemetry.context.Scope;
import kotlin.coroutines.EmptyCoroutineContext;
import kotlinx.coroutines.CoroutineScope;
import kotlinx.coroutines.GlobalScope;
import org.jetbrains.annotations.*;
import sun.awt.AWTAccessor;

import javax.swing.*;
import java.awt.*;
import java.util.concurrent.Callable;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.Consumer;

import static com.intellij.ide.ShutdownKt.cancelAndJoinBlocking;
import static com.intellij.util.concurrency.AppExecutorUtil.propagateContextOrCancellation;

@ApiStatus.Internal
public class ApplicationImpl extends ClientAwareComponentManager implements ApplicationEx {
  private static @NotNull Logger getLogger() {
    return Logger.getInstance(ApplicationImpl.class);
  }

  static final String MUST_NOT_EXECUTE_INSIDE_READ_ACTION = "Must not execute inside read action";
  static final String MUST_EXECUTE_INSIDE_READ_ACTION = "Read access is allowed from inside read-action or Event Dispatch Thread (EDT) only (see Application.runReadAction())";
  static final String MUST_EXECUTE_INSIDE_WRITE_ACTION = "Write access is allowed inside write-action only (see Application.runWriteAction())";
  static final String MUST_EXECUTE_UNDER_EDT = "Access is allowed from Event Dispatch Thread (EDT) only";
  static final String MUST_NOT_EXECUTE_UNDER_EDT = "Access from Event Dispatch Thread (EDT) is not allowed";

  private static final String DOCUMENTATION_LINK = "; see https://jb.gg/ij-platform-threading for details";

  final ReadMostlyRWLock myLock;

  /**
   * @deprecated see {@link ModalityInvokator} notice
   */
  @Deprecated
  private final ModalityInvokator myInvokator = new ModalityInvokatorImpl();

  private final EventDispatcher<ApplicationListener> myDispatcher = EventDispatcher.create(ApplicationListener.class);

  private final boolean myTestModeFlag;
  private final boolean myHeadlessMode;
  private final boolean myCommandLineMode;

  private final boolean myIsInternal;

  // contents modified in write action, read in read action
  private final Stack<Class<?>> myWriteActionsStack = new Stack<>();
  private final TransactionGuardImpl myTransactionGuard = new TransactionGuardImpl();
  private int myWriteStackBase;

  private final ReadActionCacheImpl myReadActionCacheImpl = new ReadActionCacheImpl();

  private final long myStartTime = System.currentTimeMillis();
  private boolean mySaveAllowed;
  private volatile boolean myExitInProgress;

  private final @Nullable Disposable myLastDisposable;  // the last to be disposed

  // defer reading isUnitTest flag until it's initialized
  private static class Holder {
    private static final int ourDumpThreadsOnLongWriteActionWaiting =
      ApplicationManager.getApplication().isUnitTestMode() ? 0 : Integer.getInteger("dump.threads.on.long.write.action.waiting", 0);
  }

  private static final String WAS_EVER_SHOWN = "was.ever.shown";

  @TestOnly
  public ApplicationImpl(boolean isHeadless, @NotNull RwLockHolder lockHolder) {
    super(null,
          CoroutineScopeKt.namedChildScope(GlobalScope.INSTANCE, ApplicationImpl.class.getName(), EmptyCoroutineContext.INSTANCE, true),
          true);

    myLock = lockHolder.lock;

    registerFakeServices(this);

    myIsInternal = true;
    myTestModeFlag = true;
    myHeadlessMode = isHeadless;
    myCommandLineMode = true;
    mySaveAllowed = false;

    postInit(this);

    myLastDisposable = Disposer.newDisposable();
    // reset back to null only when all components already disposed
    ApplicationManager.setApplication(this, myLastDisposable);
  }

  public ApplicationImpl(@NotNull CoroutineScope coroutineScope,
                         boolean isInternal,
                         boolean isHeadless,
                         boolean isCommandLine,
                         @NotNull RwLockHolder lockHolder) {
    super(null, coroutineScope, true);

    myLock = lockHolder.lock;

    registerFakeServices(this);

    myIsInternal = isInternal;
    myTestModeFlag = false;
    myHeadlessMode = isHeadless;
    myCommandLineMode = isCommandLine;
    if (!isHeadless) {
      mySaveAllowed = true;
    }

    myLastDisposable = null;

    postInit(this);
    ApplicationManager.setApplication(this);
  }

  private static void registerFakeServices(ApplicationImpl app) {
    app.registerServiceInstance(TransactionGuard.class, app.myTransactionGuard, ComponentManagerImpl.fakeCorePluginDescriptor);
    app.registerServiceInstance(ApplicationInfo.class, ApplicationInfoImpl.getShadowInstance(),
                                ComponentManagerImpl.fakeCorePluginDescriptor);
    app.registerServiceInstance(Application.class, app, ComponentManagerImpl.fakeCorePluginDescriptor);
    app.registerServiceInstance(ReadActionCache.class, app.myReadActionCacheImpl, ComponentManagerImpl.fakeCorePluginDescriptor);
  }

  @ApiStatus.Internal
  public static void postInit(@NotNull ApplicationImpl app) {
    AtomicBoolean reported = new AtomicBoolean();
    IdeEventQueue.getInstance().addPostprocessor(e -> {
      if (app.isWriteAccessAllowed() && reported.compareAndSet(false, true)) {
        getLogger().error("AWT events are not allowed inside write action: " + e);
      }
      return true;
    }, app);

    app.addApplicationListener(new ApplicationListener() {
      @Override
      public void afterWriteActionFinished(@NotNull Object action) {
        reported.set(false);
      }
    }, app);
  }

  /**
   * Executes a {@code runnable} in an "impatient" mode.
   * In this mode any attempt to call {@link #runReadAction(Runnable)}
   * would fail (i.e., throw {@link ApplicationUtil.CannotRunReadActionException})
   * if there is a pending write action.
   */
  @Override
  public void executeByImpatientReader(@NotNull Runnable runnable) throws ApplicationUtil.CannotRunReadActionException {
    if (isDispatchThread()) {
      runnable.run();
    }
    else {
      myLock.executeByImpatientReader(runnable);
    }
  }

  @Override
  public boolean isInImpatientReader() {
    return myLock.isInImpatientReader();
  }

  @TestOnly
  public void disposeContainer() {
    cancelAndJoinBlocking(this);
    runWriteAction(() -> {
      startDispose();
      Disposer.dispose(this);
    });
    Disposer.assertIsEmpty();
  }

  @Override
  public boolean holdsReadLock() {
    return myLock.isReadLockedByThisThread();
  }

  @Override
  public boolean isInternal() {
    return myIsInternal;
  }

  @Override
  public boolean isEAP() {
    return ApplicationInfoImpl.getShadowInstance().isEAP();
  }

  @Override
  public boolean isUnitTestMode() {
    return myTestModeFlag;
  }

  @Override
  public boolean isHeadlessEnvironment() {
    return myHeadlessMode;
  }

  @Override
  public boolean isCommandLine() {
    return myCommandLineMode;
  }

  @Override
  public final boolean isLightEditMode() {
    return AppMode.isLightEdit();
  }

  @Override
  public @NotNull Future<?> executeOnPooledThread(@NotNull Runnable action) {
    Runnable actionDecorated = ClientId.decorateRunnable(action);
    return AppExecutorUtil.getAppExecutorService().submit(new Runnable() {
      @Override
      public void run() {
        if (isDisposed()) {
          return;
        }

        try {
          actionDecorated.run();
        }
        catch (ProcessCanceledException e) {
          // ignore
        }
        catch (Throwable e) {
          getLogger().error(e);
        }
        finally {
          Thread.interrupted(); // reset interrupted status
        }
      }

      @Override
      public String toString() {
        return action.toString();
      }
    });
  }

  @Override
  public @NotNull <T> Future<T> executeOnPooledThread(@NotNull Callable<T> action) {
    Callable<T> actionDecorated = ClientId.decorateCallable(action);
    return AppExecutorUtil.getAppExecutorService().submit(new Callable<>() {
      @Override
      public T call() {
        if (isDisposed()) {
          return null;
        }

        try {
          return actionDecorated.call();
        }
        catch (ProcessCanceledException e) {
          // ignore
        }
        catch (Throwable e) {
          getLogger().error(e);
        }
        finally {
          Thread.interrupted(); // reset interrupted status
        }
        return null;
      }

      @Override
      public String toString() {
        return action.toString();
      }
    });
  }

  @Override
  public boolean isDispatchThread() {
    return myLock.isWriteThread();
  }

  @Override
  public boolean isWriteIntentLockAcquired() {
    return myLock.isWriteThread() && myLock.isWriteIntentLocked();
  }

  @Deprecated
  @Override
  public @NotNull ModalityInvokator getInvokator() {
    PluginException.reportDeprecatedUsage("Application.getInvokator", "Use `invokeLater` instead");
    return myInvokator;
  }

  @Override
  public void invokeLater(@NotNull Runnable runnable) {
    invokeLater(runnable, getDisposed());
  }

  @Override
  public void invokeLater(@NotNull Runnable runnable, @NotNull Condition<?> expired) {
    invokeLater(runnable, getDefaultModalityState(), expired);
  }

  @Override
  public void invokeLater(@NotNull Runnable runnable, @NotNull ModalityState state) {
    invokeLater(runnable, state, getDisposed());
  }

  @Override
  public void invokeLater(@NotNull Runnable runnable, @NotNull ModalityState state, @NotNull Condition<?> expired) {
    if (propagateContextOrCancellation()) {
      Pair<Runnable, Condition<?>> captured = Propagation.capturePropagationAndCancellationContext(runnable, expired);
      runnable = captured.getFirst();
      expired = captured.getSecond();
    }
    Runnable r = myTransactionGuard.wrapLaterInvocation(runnable, state);
    // Don't need to enable implicit read, as Write Intent lock includes Explicit Read
    LaterInvocator.invokeLater(state, expired, wrapWithRunIntendedWriteAction(r));
  }

  @Override
  public void dispose() {
    //noinspection deprecation
    myDispatcher.getMulticaster().applicationExiting();

    super.dispose();
    // Remove IW lock from EDT as EDT might be re-created, which might lead to deadlock if anybody uses this disposed app
    if (!StartupUtil.isImplicitReadOnEDTDisabled() || isUnitTestMode()) {
      invokeLater(() -> releaseWriteIntentLock(), ModalityState.nonModal());
    }

    // FileBasedIndexImpl can schedule some more activities to execute, so, shutdown executor only after service disposing
    AppExecutorUtil.shutdownApplicationScheduledExecutorService();

    if (myLastDisposable == null) {
      ApplicationManager.setApplication(null);
    }
    else {
      Disposer.dispose(myLastDisposable);
    }
  }

  @Override
  public boolean runProcessWithProgressSynchronously(@NotNull Runnable process,
                                                     @NotNull String progressTitle,
                                                     boolean canBeCanceled,
                                                     boolean shouldShowModalWindow,
                                                     @Nullable Project project,
                                                     @Nullable JComponent parentComponent,
                                                     @Nullable @Nls(capitalization = Nls.Capitalization.Title) String cancelText) {
    // disallow running process in a separate thread from a write-action, or a thread will deadlock trying to acquire the read-lock
    if (isDispatchThread() && isWriteAccessAllowed()) {
      getLogger().debug("Starting process with progress from within write action makes no sense");
      try {
        ProgressManager.getInstance().runProcess(process, new EmptyProgressIndicator());
      }
      catch (ProcessCanceledException e) {
        // ok to ignore.
        return false;
      }
      return true;
    }

    CompletableFuture<@NotNull ProgressWindow> progress =
      createProgressWindowAsyncIfNeeded(progressTitle, canBeCanceled, shouldShowModalWindow, project, parentComponent, cancelText);

    // Event pumping (`ProgressRunner.modal()`) is not correct without entering the modality (`shouldShowModalWindow == false`),
    // because one of the events might show a dialog scheduled in outer modality,
    // which will start another nested loop and prevent the pumping from exit until the dialog closed (IDEA-307428):
    // - modal progress: `enterModal`;
    // - modal progress: schedule modal dialog to show after 300ms;
    // - modal progress: `pumpEventsForHierarchy`;
    // - one of events runs `isConditionalModal() && !shouldStartInBackground()` task;
    // - on EDT such tasks are executed synchronously;
    // - task starts nested `pumpEventsForHierarchy` without entering the modality;
    // - nested `pumpEventsForHierarchy` shows scheduled modal progress dialog;
    // - nested `pumpEventsForHierarchy` cannot finish because scheduled modal progress dialog runs nested event loop;
    // - modal dialog cannot finish until task is finished because it's synchronous.
    //
    // Applying `ProgressRunner.modal()` only when `shouldShowModalWindow == true` is a correct solution,
    // but it forces the execution of non-modal synchronous tasks directly on the EDT
    // (see com.intellij.openapi.progress.impl.ProgressRunner.checkIfForceDirectExecNeeded),
    // and clients are not ready for this, they still expect the process Runnable to be executed on a BGT.
    //
    // On the other hand, synchronous execution of background tasks on EDT happens for headless tasks,
    // and it should still pump the EDT without entering the modality state (IDEA-241785).
    // In tests and is headless mode, there are is modal progress dialog, so IDEA-307428 should not be possible in tests.
    //
    // Instead, IDEA-307428 is fixed by ensuring the new modality state for non-headless synchronous EDT tasks
    // (see `CoreProgressManager.runProcessWithProgressSynchronously(Task)`),
    // so that the scheduled outer modal progress dialog cannot be shown from inside the nested `pumpEventsForHierarchy`.
    ProgressRunner<?> progressRunner = new ProgressRunner<>(process)
      .sync()
      .onThread(ProgressRunner.ThreadToUse.POOLED)
      .modal()
      .withProgress(progress);

    ProgressResult<?> result = progressRunner.submitAndGet();

    Throwable exception = result.getThrowable();
    if (!(exception instanceof ProcessCanceledException)) {
      ExceptionUtil.rethrowUnchecked(exception);
    }
    return !result.isCanceled();
  }


  @Override
  public void invokeAndWait(@NotNull Runnable runnable, @NotNull ModalityState modalityState) {
    if (isDispatchThread()) {
      runnable.run();
      return;
    }
    if (EDT.isCurrentThreadEdt()) {
      runIntendedWriteActionOnCurrentThread(runnable);
      return;
    }

    if (holdsReadLock()) {
      throw new IllegalStateException("Calling invokeAndWait from read-action leads to possible deadlock.");
    }

    Runnable r = myTransactionGuard.wrapLaterInvocation(AppScheduledExecutorService.capturePropagationAndCancellationContext(runnable), modalityState);
    LaterInvocator.invokeAndWait(modalityState, wrapWithRunIntendedWriteAction(r));
  }

  private @NotNull Runnable wrapWithRunIntendedWriteAction(@NotNull Runnable runnable) {
    return new Runnable() {
      @Override
      public void run() {
        runIntendedWriteActionOnCurrentThread(runnable);
      }

      @Override
      public String toString() {
        return runnable.toString();
      }
    };
  }

  @Override
  public void invokeAndWait(@NotNull Runnable runnable) throws ProcessCanceledException {
    invokeAndWait(runnable, getDefaultModalityState());
  }

  @Override
  public @NotNull ModalityState getCurrentModalityState() {
    return LaterInvocator.getCurrentModalityState();
  }

  @Override
  public @NotNull ModalityState getModalityStateForComponent(@NotNull Component c) {
    Window window = ComponentUtil.getWindow(c);
    if (window == null) return getNoneModalityState(); //?
    return LaterInvocator.modalityStateForWindow(window);
  }

  @Override
  public @NotNull ModalityState getAnyModalityState() {
    return AnyModalityState.ANY;
  }

  @Override
  public @NotNull ModalityState getDefaultModalityState() {
    return isDispatchThread() ? getCurrentModalityState() : CoreProgressManager.getCurrentThreadProgressModality();
  }

  @Override
  public @NotNull ModalityState getNoneModalityState() {
    return ModalityState.nonModal();
  }

  @Override
  public long getStartTime() {
    return myStartTime;
  }

  @Override
  public long getIdleTime() {
    return IdeEventQueue.getInstance().getIdleTime();
  }

  @Override
  public final void restart(boolean exitConfirmed) {
    restart(exitConfirmed, false);
  }

  @Override
  public final void restart(boolean exitConfirmed, boolean elevate) {
    int flags = SAVE;
    if (exitConfirmed) {
      flags |= EXIT_CONFIRMED;
    }
    if (elevate) {
      flags |= ELEVATE;
    }
    restart(flags, ArrayUtilRt.EMPTY_STRING_ARRAY);
  }

  /**
   * There are two ways we can get an exit notification.
   * 1. From user input i.e., ExitAction
   * 2. From the native system.
   * We should not process any quit notifications if we are handling another one
   * <p>
   * Note: there are possible scenarios when we get a quit notification at a moment when another
   * quit message is shown. In that case, showing multiple messages sounds contra-intuitive as well
   */
  @Override
  public final void exit(boolean force, boolean exitConfirmed, boolean restart, int exitCode) {
    int flags = SAVE;
    if (force) {
      flags |= FORCE_EXIT;
    }
    if (exitConfirmed) {
      flags |= EXIT_CONFIRMED;
    }
    exit(flags, restart, ArrayUtilRt.EMPTY_STRING_ARRAY, exitCode);
  }

  @Override
  public final void exit(boolean force, boolean exitConfirmed, boolean restart) {
    exit(force, exitConfirmed, restart, 0);
  }

  public void restart(int flags, String @NotNull [] beforeRestart) {
    exit(flags, true, beforeRestart, 0);
  }

  @Override
  public final void exit(int flags, int exitCode) {
    exit(flags, false, ArrayUtil.EMPTY_STRING_ARRAY, exitCode);
  }

  @Override
  public final void exit(int flags) {
    exit(flags, false, ArrayUtil.EMPTY_STRING_ARRAY, 0);
  }

  private void exit(int flags, boolean restart, String @NotNull [] beforeRestart, int exitCode) {
    if (!BitUtil.isSet(flags, FORCE_EXIT) &&
        (myExitInProgress || (!BitUtil.isSet(flags, EXIT_CONFIRMED) && getDefaultModalityState() != ModalityState.nonModal()))) {
      return;
    }

    myExitInProgress = true;
    if (isDispatchThread()) {
      doExit(flags, restart, beforeRestart, exitCode);
    }
    else {
      invokeLater(() -> doExit(flags, restart, beforeRestart, exitCode), ModalityState.nonModal());
    }
  }

  @Override
  public final boolean isExitInProgress() {
    return myExitInProgress;
  }

  private void doExit(int flags, boolean restart, String @NotNull [] beforeRestart, int exitCode) {
    IJTracer tracer = TelemetryManager.getInstance().getTracer(new com.intellij.platform.diagnostic.telemetry.Scope("exitApp", null));
    Span exitSpan = tracer.spanBuilder("application.exit").startSpan();
    boolean force = BitUtil.isSet(flags, FORCE_EXIT);
    try (Scope scope = exitSpan.makeCurrent()) {
      if (!force && !confirmExitIfNeeded(BitUtil.isSet(flags, EXIT_CONFIRMED))) {
        return;
      }

      AppLifecycleListener lifecycleListener = getMessageBus().syncPublisher(AppLifecycleListener.TOPIC);
      lifecycleListener.appClosing();

      if (!force && !canExit()) {
        return;
      }

      stopServicePreloading();


      if (BitUtil.isSet(flags, SAVE)) {
        TraceUtil.runWithSpanThrows(tracer, "saveSettingsOnExit",
                                    (span) -> SaveAndSyncHandler.getInstance().saveSettingsUnderModalProgress(this));
      }

      if (isInstantShutdownPossible()) {
        for (Frame frame : Frame.getFrames()) {
          frame.setVisible(false);
        }
      }

      try {
        lifecycleListener.appWillBeClosed(restart);
      }
      catch (Throwable t) {
        getLogger().error(t);
      }

      LifecycleUsageTriggerCollector.onIdeClose(restart);

      boolean success = TraceUtil.computeWithSpanThrows(tracer, "disposeProjects", (span) -> {
        ProjectManagerEx manager = ProjectManagerEx.getInstanceExIfCreated();
        if (manager != null) {
          try {
            if (!manager.closeAndDisposeAllProjects(!force)) {
              return false;
            }
          }
          catch (Throwable e) {
            getLogger().error(e);
          }
        }
        try {
          //noinspection TestOnlyProblems
          disposeContainer();
        }
        catch (Throwable t) {
          getLogger().error(t);
        }
        return true;
      });


      //noinspection SpellCheckingInspection
      if (!success || isUnitTestMode() || Boolean.getBoolean("idea.test.guimode")) {
        //noinspection SpellCheckingInspection
        if (Boolean.getBoolean("idea.test.guimode")) {
          shutdown();
        }
        return;
      }

      IdeaLogger.dropFrequentExceptionsCaches();
      if (restart && Restarter.isSupported()) {
        try {
          Restarter.scheduleRestart(BitUtil.isSet(flags, ELEVATE), beforeRestart);
        }
        catch (Throwable t) {
          getLogger().error("Restart failed", t);
          StartupErrorReporter.showMessage(BootstrapBundle.message("restart.failed.title"), t);
          if(exitCode == 0) {
            exitCode = AppExitCodes.RESTART_FAILED;
          }
        }
      }
      scope.close();
      exitSpan.end();
      System.exit(exitCode);
    }
    finally {
      exitSpan.end();
      myExitInProgress = false;
    }
  }

  private static boolean isInstantShutdownPossible() {
    if (!Registry.is("ide.instant.shutdown", true)) {
      return false;
    }

    return !ProgressManager.getInstance().hasProgressIndicator();
  }

  private @NotNull CompletableFuture<@NotNull ProgressWindow> createProgressWindowAsyncIfNeeded(
    @NotNull @NlsContexts.ProgressTitle String progressTitle,
    boolean canBeCanceled,
    boolean shouldShowModalWindow,
    @Nullable Project project,
    @Nullable JComponent parentComponent,
    @Nullable @NlsContexts.Button String cancelText
  ) {
    if (SwingUtilities.isEventDispatchThread()) {
      return CompletableFuture.completedFuture(
        createProgressWindow(progressTitle, canBeCanceled, shouldShowModalWindow, project, parentComponent, cancelText));
    }
    else {
      return CompletableFuture.supplyAsync(
        () -> createProgressWindow(progressTitle, canBeCanceled, shouldShowModalWindow, project, parentComponent, cancelText),
        this::invokeLater);
    }
  }

  private @NotNull ProgressWindow createProgressWindow(@NotNull @NlsContexts.ProgressTitle String progressTitle,
                                                       boolean canBeCanceled,
                                                       boolean shouldShowModalWindow,
                                                       @Nullable Project project,
                                                       @Nullable JComponent parentComponent,
                                                       @Nullable @NlsContexts.Button String cancelText) {
    ProgressWindow progress = new ProgressWindow(canBeCanceled, !shouldShowModalWindow, project, parentComponent, cancelText);
    // in case of abrupt application exit when 'ProgressManager.getInstance().runProcess(process, progress)' below
    // does not have a chance to run, and as a result the progress won't be disposed
    Disposer.register(this, progress);
    progress.setTitle(progressTitle);
    return progress;
  }

  /**
   * Used for GUI tests to stop `IdeEventQueue` dispatching when `Application` is already disposed of.
   */
  private static void shutdown() {
    IdeEventQueue.applicationClose();
    ShutDownTracker.getInstance().run();
  }

  private static boolean confirmExitIfNeeded(boolean exitConfirmed) {
    boolean hasUnsafeBgTasks = ProgressManager.getInstance().hasUnsafeProgressIndicator();
    if (exitConfirmed && !hasUnsafeBgTasks) {
      return true;
    }

    DoNotAskOption option = new DoNotAskOption() {
      @Override
      public boolean isToBeShown() {
        return GeneralSettings.getInstance().isConfirmExit() && ProjectManager.getInstance().getOpenProjects().length > 0;
      }

      @Override
      public void setToBeShown(boolean value, int exitCode) {
        GeneralSettings.getInstance().setConfirmExit(value);
      }

      @Override
      public boolean canBeHidden() {
        return !hasUnsafeBgTasks;
      }

      @Override
      public boolean shouldSaveOptionsOnCancel() {
        return false;
      }

      @Override
      public @NotNull String getDoNotShowMessage() {
        return IdeBundle.message("do.not.ask.me.again");
      }
    };

    if (!hasUnsafeBgTasks && !option.isToBeShown()) {
      return true;
    }

    if (hasUnsafeBgTasks && ApplicationManager.getApplication().isHeadlessEnvironment()) {
      getLogger().error("Headless application has been completed but background tasks are still running! Application will be terminated." +
                        "\nThread dump:\n" + ThreadDumper.dumpThreadsToString());
      return true;
    }

    AtomicBoolean alreadyGone = new AtomicBoolean(false);
    if (hasUnsafeBgTasks) {
      Runnable dialogRemover = Messages.createMessageDialogRemover(null);
      Runnable task = new Runnable() {
        @Override
        public void run() {
          if (alreadyGone.get()) return;
          if (!ProgressManager.getInstance().hasUnsafeProgressIndicator()) {
            alreadyGone.set(true);
            dialogRemover.run();
          }
          else {
            AppExecutorUtil.getAppScheduledExecutorService().schedule(this, 1, TimeUnit.SECONDS);
          }
        }
      };
      AppExecutorUtil.getAppScheduledExecutorService().schedule(task, 1, TimeUnit.SECONDS);
    }

    String message = ApplicationBundle.message(hasUnsafeBgTasks ? "exit.confirm.prompt.tasks" : "exit.confirm.prompt");
    exitConfirmed = MessageDialogBuilder.yesNo(ApplicationBundle.message("exit.confirm.title"), message)
      .yesText(ApplicationBundle.message("command.exit"))
      .noText(CommonBundle.getCancelButtonText())
      .doNotAsk(option)
      .guessWindowAndAsk();
    if (alreadyGone.getAndSet(true)) {
      if (!option.isToBeShown()) {
        return true;
      }
      exitConfirmed =
        MessageDialogBuilder.okCancel(ApplicationBundle.message("exit.confirm.title"), ApplicationBundle.message("exit.confirm.prompt"))
          .yesText(ApplicationBundle.message("command.exit"))
          .doNotAsk(option)
          .guessWindowAndAsk();
    }
    return exitConfirmed;
  }

  private boolean canExit() {
    for (ApplicationListener applicationListener : myDispatcher.getListeners()) {
      if (!applicationListener.canExitApplication()) {
        return false;
      }
    }

    ProjectManagerEx projectManager = ProjectManagerEx.getInstanceExIfCreated();
    if (projectManager == null) {
      return true;
    }

    Project[] projects = projectManager.getOpenProjects();
    for (Project project : projects) {
      if (!projectManager.canClose(project)) {
        return false;
      }
    }

    return true;
  }

  @ApiStatus.Internal
  public boolean isCurrentWriteOnEdt() {
    return EDT.isEdt(myLock.writeThread);
  }

  @Override
  public void runIntendedWriteActionOnCurrentThread(@NotNull Runnable action) {
    if (isWriteIntentLockAcquired()) {
      action.run();
    }
    else {
      acquireWriteIntentLock(action.getClass().getName());
      try {
        action.run();
      }
      finally {
        releaseWriteIntentLock();
      }
    }
  }

  @Override
  public <T, E extends Throwable> T runUnlockingIntendedWrite(@NotNull ThrowableComputable<T, E> action) throws E {
    // Do not ever unlock IW in legacy mode (EDT is holding lock at all times)
    if (isWriteIntentLockAcquired() && StartupUtil.isImplicitReadOnEDTDisabled()) {
      releaseWriteIntentLock();
      try {
        return action.compute();
      }
      finally {
        acquireWriteIntentLock(action.getClass().getName());
      }
    }
    else {
      return action.compute();
    }
  }

  @Override
  public void runReadAction(@NotNull Runnable action) {
    ReadMostlyRWLock.Reader status = myLock.startRead();
    try {
      action.run();
    }
    finally {
      myReadActionCacheImpl.clear();
      if (status != null) {
        myLock.endRead(status);
      }
    }
  }

  @Override
  public <T> T runReadAction(@NotNull Computable<T> computation) {
    ReadMostlyRWLock.Reader status = myLock.startRead();
    try {
      return computation.compute();
    }
    finally {
      myReadActionCacheImpl.clear();
      if (status != null) {
        myLock.endRead(status);
      }
    }
  }

  @Override
  public <T, E extends Throwable> T runReadAction(@NotNull ThrowableComputable<T, E> computation) throws E {
    ReadMostlyRWLock.Reader status = myLock.startRead();
    try {
      return computation.compute();
    }
    finally {
      myReadActionCacheImpl.clear();
      if (status != null) {
        myLock.endRead(status);
      }
    }
  }

  @Override
  public boolean acquireWriteIntentLock(@Nullable String ignored) {
    if (myLock.isWriteThread() && (myLock.isWriteIntentLocked() || myLock.isWriteAcquired())) {
      return false;
    }
    myLock.writeIntentLock();
    return true;
  }

  @Override
  public void releaseWriteIntentLock() {
    myLock.writeIntentUnlock();
  }

  @Override
  @ApiStatus.Experimental
  public boolean runWriteActionWithNonCancellableProgressInDispatchThread(@NotNull @NlsContexts.ProgressTitle String title,
                                                                          @Nullable Project project,
                                                                          @Nullable JComponent parentComponent,
                                                                          @NotNull Consumer<? super ProgressIndicator> action) {
    return runEdtProgressWriteAction(title, project, parentComponent, null, action);
  }

  @Override
  @ApiStatus.Experimental
  public boolean runWriteActionWithCancellableProgressInDispatchThread(@NotNull @NlsContexts.ProgressTitle String title,
                                                                       @Nullable Project project,
                                                                       @Nullable JComponent parentComponent,
                                                                       @NotNull java.util.function.Consumer<? super ProgressIndicator> action) {
    return runEdtProgressWriteAction(title, project, parentComponent, IdeBundle.message("action.stop"), action);
  }

  private boolean runEdtProgressWriteAction(@NotNull @NlsContexts.ProgressTitle String title,
                                            @Nullable Project project,
                                            @Nullable JComponent parentComponent,
                                            @Nullable @Nls(capitalization = Nls.Capitalization.Title) String cancelText,
                                            @NotNull java.util.function.Consumer<? super ProgressIndicator> action) {
    return runWriteActionWithClass(action.getClass(), () -> {
      PotemkinProgress indicator = new PotemkinProgress(title, project, parentComponent, cancelText);
      indicator.runInSwingThread(() -> action.accept(indicator));
      return !indicator.isCanceled();
    });
  }

  private <T, E extends Throwable> T runWriteActionWithClass(@NotNull Class<?> clazz, @NotNull ThrowableComputable<T, E> computable) throws E {
    startWrite(clazz);
    try {
      return computable.compute();
    }
    finally {
      endWrite(clazz);
    }
  }

  @Override
  public void runWriteAction(@NotNull Runnable action) {
    Class<? extends Runnable> clazz = action.getClass();
    startWrite(clazz);
    try {
      action.run();
    }
    finally {
      endWrite(clazz);
    }
  }

  @Override
  public <T> T runWriteAction(@NotNull Computable<T> computation) {
    return runWriteActionWithClass(computation.getClass(), () -> computation.compute());
  }

  @Override
  public <T, E extends Throwable> T runWriteAction(@NotNull ThrowableComputable<T, E> computation) throws E {
    return runWriteActionWithClass(computation.getClass(), computation);
  }

  @Override
  public boolean hasWriteAction(@NotNull Class<?> actionClass) {
    assertReadAccessAllowed();

    for (int i = myWriteActionsStack.size() - 1; i >= 0; i--) {
      Class<?> action = myWriteActionsStack.get(i);
      if (actionClass == action || ReflectionUtil.isAssignable(actionClass, action)) {
        return true;
      }
    }
    return false;
  }

  @Override
  public <T, E extends Throwable> T runWriteIntentReadAction(@NotNull ThrowableComputable<T, E> computation) throws E {
    boolean wilock = acquireWriteIntentLock(computation.getClass().getName());
    try {
      return computation.compute();
    }
    finally {
      if (wilock) {
        releaseWriteIntentLock();
      }
    }
  }

  @Override
  public void assertReadAccessAllowed() {
    if (!isReadAccessAllowed()) {
      getLogger().error(createThreadAccessException(MUST_EXECUTE_INSIDE_READ_ACTION));
    }
  }

  @Override
  public void assertReadAccessNotAllowed() {
    if (isReadAccessAllowed()) {
      throwThreadAccessException(MUST_NOT_EXECUTE_INSIDE_READ_ACTION);
    }
  }

  private static @NotNull String describe(@Nullable Thread o) {
    return o == null ? "null" : o + " " + System.identityHashCode(o);
  }

  private static Thread getEventQueueThread() {
    EventQueue eventQueue = Toolkit.getDefaultToolkit().getSystemEventQueue();
    return AWTAccessor.getEventQueueAccessor().getDispatchThread(eventQueue);
  }

  @Override
  public boolean isReadAccessAllowed() {
    return myLock.isReadAllowed();
  }

  @Override
  public void assertIsDispatchThread() {
    if (!isDispatchThread()) {
      throwThreadAccessException(MUST_EXECUTE_UNDER_EDT);
    }
  }

  @Override
  public void assertIsNonDispatchThread() {
    if (isDispatchThread()) {
      throwThreadAccessException(MUST_NOT_EXECUTE_UNDER_EDT);
    }
  }

  private static void throwThreadAccessException(@NotNull @NonNls String message) {
    throw createThreadAccessException(message);
  }

  private static @NotNull RuntimeExceptionWithAttachments createThreadAccessException(@NonNls @NotNull String message) {
    return new RuntimeExceptionWithAttachments(message + DOCUMENTATION_LINK + "\n" + getThreadDetails(),
                                               new Attachment("threadDump.txt", ThreadDumper.dumpThreadsToString()));
  }

  private static @NotNull String getThreadDetails() {
    Thread current = Thread.currentThread();
    Thread edt = getEventQueueThread();
    return "Current thread: " + describe(current) + " (EventQueue.isDispatchThread()=" + EventQueue.isDispatchThread() + ")" +
           "\nSystemEventQueueThread: " + (edt == current ? "(same)" : describe(edt));
  }

  @Override
  public void assertWriteIntentLockAcquired() {
    if (!isWriteIntentLockAcquired()) {
      throwThreadAccessException("Access is allowed from write thread only");
    }
  }

  @Override
  public void assertIsDispatchThread(@Nullable JComponent component) {
    if (component == null) return;

    if (isDispatchThread()) {
      return;
    }

    if (Boolean.TRUE.equals(component.getClientProperty(WAS_EVER_SHOWN))) {
      assertIsDispatchThread();
    }
    else {
      JRootPane root = component.getRootPane();
      if (root != null) {
        component.putClientProperty(WAS_EVER_SHOWN, Boolean.TRUE);
        assertIsDispatchThread();
      }
    }
  }

  @Override
  public void assertTimeConsuming() {
    assertIsNonDispatchThread();
  }

  @Override
  public boolean tryRunReadAction(@NotNull Runnable action) {
    //if we are inside read action, do not try to acquire read lock again since it will deadlock if there is a pending writeAction
    ReadMostlyRWLock.Reader status = myLock.startTryRead();
    if (status != null && !status.readRequested) {
      return false;
    }
    try {
      action.run();
    }
    finally {
      myReadActionCacheImpl.clear();
      if (status != null) {
        myLock.endRead(status);
      }
    }
    return true;
  }

  @Override
  public boolean isActive() {
    if (isHeadlessEnvironment()) {
      return true;
    }

    if (isDisposed()) {
      return false;
    }

    Window activeWindow = KeyboardFocusManager.getCurrentKeyboardFocusManager().getActiveWindow();
    if (activeWindow != null) {
      ApplicationActivationStateManager.updateState(this, activeWindow);
    }

    return ApplicationActivationStateManager.isActive();
  }

  @Override
  public @NotNull AccessToken acquireReadActionLock() {
    PluginException.reportDeprecatedUsage("Application.acquireReadActionLock", "Use `runReadAction()` instead");

    // if we are inside read action, do not try to acquire read lock again since it will deadlock if there is a pending writeAction
    return isWriteIntentLockAcquired() || myLock.isReadLockedByThisThread() ? AccessToken.EMPTY_ACCESS_TOKEN : new ReadAccessToken();
  }

  private volatile boolean myWriteActionPending;

  @Override
  public boolean isWriteActionPending() {
    return myWriteActionPending;
  }

  private void startWrite(@NotNull Class<?> clazz) {
    assertWriteIntentLockAcquired();
    assertNotInsideListener();
    myWriteActionPending = true;
    try {
      ActivityTracker.getInstance().inc();
      fireBeforeWriteActionStart(clazz);

      // otherwise (when myLock is locked) there's a nesting write action:
      // - allow it,
      // - fire listeners for it (somebody can rely on having listeners fired for each write action)
      // - but do not re-acquire any locks because it could be deadlock-level dangerous
      if (!myLock.isWriteAcquired()) {
        int delay = Holder.ourDumpThreadsOnLongWriteActionWaiting;
        Future<?> reportSlowWrite = delay <= 0 ? null :
                                    AppExecutorUtil.getAppScheduledExecutorService()
                                      .scheduleWithFixedDelay(() -> PerformanceWatcher.getInstance().dumpThreads("waiting", true, true),
                                                              delay, delay, TimeUnit.MILLISECONDS);
        long t = getLogger().isDebugEnabled() ? System.currentTimeMillis() : 0;
        myLock.writeLock();
        if (getLogger().isDebugEnabled()) {
          long elapsed = System.currentTimeMillis() - t;
          if (elapsed != 0) {
            getLogger().debug("Write action wait time: " + elapsed);
          }
        }
        if (reportSlowWrite != null) {
          reportSlowWrite.cancel(false);
        }
      }
    }
    finally {
      myWriteActionPending = false;
    }

    myWriteActionsStack.push(clazz);
    fireWriteActionStarted(clazz);
  }

  private void assertNotInsideListener() {
    if (myWriteActionPending) {
      throw new IllegalStateException("Must not start write action from inside write action listener");
    }
  }

  private void endWrite(@NotNull Class<?> clazz) {
    try {
      fireWriteActionFinished(clazz);
      // fire listeners before popping stack because if somebody starts a write-action in a listener,
      // there is a danger of releasing the write-lock before other listeners have been run (since write lock became non-reentrant).
    }
    finally {
      myWriteActionsStack.pop();
      if (myWriteActionsStack.size() == myWriteStackBase) {
        myLock.writeUnlock();
      }
      if (myWriteActionsStack.isEmpty()) {
        fireAfterWriteActionFinished(clazz);
      }
    }
  }

  @Override
  public @NotNull AccessToken acquireWriteActionLock(@NotNull Class<?> clazz) {
    PluginException.reportDeprecatedUsage("Application#acquireWriteActionLock", "Use `runWriteAction()` instead");

    return new WriteAccessToken(clazz);
  }

  private class WriteAccessToken extends AccessToken {
    private final @NotNull Class<?> clazz;

    WriteAccessToken(@NotNull Class<?> clazz) {
      this.clazz = clazz;
      startWrite(clazz);
      markThreadNameInStackTrace();
    }

    @Override
    public void finish() {
      try {
        endWrite(clazz);
      }
      finally {
        unmarkThreadNameInStackTrace();
      }
    }

    private void markThreadNameInStackTrace() {
      String id = id();

      if (id != null) {
        Thread thread = Thread.currentThread();
        thread.setName(thread.getName() + id);
      }
    }

    private void unmarkThreadNameInStackTrace() {
      String id = id();

      if (id != null) {
        Thread thread = Thread.currentThread();
        String name = thread.getName();
        name = StringUtil.replace(name, id, "");
        thread.setName(name);
      }
    }

    private @Nullable String id() {
      Class<?> aClass = getClass();
      String name = aClass.getName();
      name = name.substring(name.lastIndexOf('.') + 1);
      name = name.substring(name.lastIndexOf('$') + 1);
      if (!name.equals("AccessToken")) {
        return " [" + name + "]";
      }
      return null;
    }
  }

  /**
   * @deprecated use {@link #runReadAction(Runnable)} instead
   */
  @Deprecated
  private final class ReadAccessToken extends AccessToken {
    private final ReadMostlyRWLock.Reader myReader;

    private ReadAccessToken() {
      myReader = myLock.startRead();
    }

    @Override
    public void finish() {
      myReadActionCacheImpl.clear();
      myLock.endRead(myReader);
    }
  }

  @Override
  public void assertWriteAccessAllowed() {
    if (!isWriteAccessAllowed()) {
      throwThreadAccessException(MUST_EXECUTE_INSIDE_WRITE_ACTION);
    }
  }

  @Override
  public boolean isWriteAccessAllowed() {
    return myLock.isWriteThread() && myLock.isWriteAcquired();
  }

  @Override
  public boolean isWriteActionInProgress() {
    return myLock.isWriteAcquired();
  }

  /**
   * If called inside a write-action, executes the given code under modal progress with write-lock released (e.g., to allow for read-action parallelization).
   * It's the caller's responsibility to invoke this method only when the model is in an internally consistent state,
   * so that background threads with read actions don't see half-baked PSI/VFS/etc. The runnable may perform write-actions itself;
   * callers should be ready for those.
   */
  public void executeSuspendingWriteAction(@Nullable Project project,
                                           @NotNull @NlsContexts.DialogTitle String title,
                                           @NotNull Runnable runnable) {
    assertWriteIntentLockAcquired();
    if (!myLock.isWriteAcquired()) {
      runModalProgress(project, title, runnable);
      return;
    }

    int prevBase = myWriteStackBase;
    myWriteStackBase = myWriteActionsStack.size();
    try {
      myLock.writeSuspendWhilePumpingIdeEventQueueHopingForTheBest(() -> runModalProgress(project, title, runnable));
    }
    finally {
      myWriteStackBase = prevBase;
    }
  }

  private static void runModalProgress(@Nullable Project project,
                                       @NotNull @NlsContexts.DialogTitle String title,
                                       @NotNull Runnable runnable) {
    ProgressManager.getInstance().run(new Task.Modal(project, title, false) {
      @Override
      public void run(@NotNull ProgressIndicator indicator) {
        runnable.run();
      }
    });
  }

  @Override
  public void addApplicationListener(@NotNull ApplicationListener l) {
    myDispatcher.addListener(l);
  }

  @Override
  public void addApplicationListener(@NotNull ApplicationListener l, @NotNull Disposable parent) {
    myDispatcher.addListener(l, parent);
  }

  @Override
  public void removeApplicationListener(@NotNull ApplicationListener l) {
    myDispatcher.removeListener(l);
  }

  private void fireBeforeWriteActionStart(@NotNull Class<?> action) {
    myDispatcher.getMulticaster().beforeWriteActionStart(action);
  }

  private void fireWriteActionStarted(@NotNull Class<?> action) {
    myDispatcher.getMulticaster().writeActionStarted(action);
  }

  private void fireWriteActionFinished(@NotNull Class<?> action) {
    myDispatcher.getMulticaster().writeActionFinished(action);
  }

  private void fireAfterWriteActionFinished(@NotNull Class<?> action) {
    myDispatcher.getMulticaster().afterWriteActionFinished(action);
  }

  @Override
  public void saveSettings() {
    if (mySaveAllowed) {
      StoreUtil.saveSettings(this, false);
    }
  }

  @Override
  public void saveAll() {
    StoreUtil.saveDocumentsAndProjectsAndApp(false);
  }

  @Override
  public void setSaveAllowed(boolean value) {
    mySaveAllowed = value;
  }

  @Override
  public boolean isSaveAllowed() {
    return mySaveAllowed;
  }

  @Override
  public boolean isRestartCapable() {
    return Restarter.isSupported();
  }

  @Override
  public String toString() {
    boolean writeActionPending = isWriteActionPending();
    boolean writeActionInProgress = isWriteActionInProgress();
    boolean writeAccessAllowed = isWriteAccessAllowed();
    return "Application"
           +(getContainerState().get() == ContainerState.COMPONENT_CREATED ? "" : " (containerState " + getContainerStateName() + ") ")
           + (isUnitTestMode() ? " (unit test)" : "")
           + (isInternal() ? " (internal)" : "")
           + (isHeadlessEnvironment() ? " (headless)" : "")
           + (isCommandLine() ? " (command line)" : "")
           + (writeActionPending || writeActionInProgress || writeAccessAllowed ? " (WA" + (writeActionPending ? " pending" : "") + (writeActionInProgress ? " inProgress" : "") + (writeAccessAllowed ? " allowed" : "") + ")" : "")
           + (isReadAccessAllowed() ? " (RA allowed)" : "")
           + (StartupUtil.isImplicitReadOnEDTDisabled() ? " (IR on EDT disabled)" : "")
           + (isInImpatientReader() ? " (impatient reader)" : "")
           + (isExitInProgress() ? " (exit in progress)" : "")
      ;
  }

  @Override
  public @NotNull String activityNamePrefix() {
    return "app ";
  }

  @Override
  protected @NotNull ContainerDescriptor getContainerDescriptor(@NotNull IdeaPluginDescriptorImpl pluginDescriptor) {
    return pluginDescriptor.appContainerDescriptor;
  }

  @Override
  protected void logMessageBusDelivery(@NotNull Topic<?> topic, @NotNull String messageName, @NotNull Object handler, long duration) {
    super.logMessageBusDelivery(topic, messageName, handler, duration);

    if (topic == ProjectManager.TOPIC) {
      long start = StartUpMeasurer.getCurrentTime() - duration;
      StartUpMeasurer.addCompletedActivity(start, handler.getClass(), ActivityCategory.PROJECT_OPEN_HANDLER, null,
                                           StartUpMeasurer.MEASURE_THRESHOLD);
    }
    else if (topic == VirtualFileManager.VFS_CHANGES) {
      if (TimeUnit.NANOSECONDS.toMillis(duration) > 50) {
        getLogger().info(String.format("LONG VFS PROCESSING. Topic=%s, offender=%s, message=%s, time=%dms",
                                       topic.getDisplayName(), handler.getClass(), messageName, TimeUnit.NANOSECONDS.toMillis(duration)));
      }
    }
  }

  @TestOnly
  void disableEventsUntil(@NotNull Disposable disposable) {
    myDispatcher.neuterMultiCasterWhilePerformanceTestIsRunningUntil(disposable);
  }

  @Override
  public boolean isComponentCreated() {
    return getContainerState().get().compareTo(ContainerState.COMPONENT_CREATED) >= 0;
  }

  @Override
  public void runWithoutImplicitRead(@NotNull Runnable runnable) {
    if (!StartupUtil.isImplicitReadOnEDTDisabled()) {
      runnable.run();
      return;
    }
    runWithDisabledImplicitRead(runnable);
  }

  private void runWithDisabledImplicitRead(@NotNull Runnable runnable) {
    // This method is used to allow easily find stack traces which violate disabled ImplicitRead
    boolean oldVal = myLock.isImplicitReadAllowed();
    try {
      myLock.setAllowImplicitRead(false);
      runnable.run();
    }
    finally {
      myLock.setAllowImplicitRead(oldVal);
    }
  }
}


CoreProgressManager-
// Copyright 2000-2023 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package com.intellij.openapi.progress.impl;

import com.intellij.codeWithMe.ClientId;
import com.intellij.concurrency.ContextAwareRunnable;
import com.intellij.diagnostic.ThreadDumper;
import com.intellij.openapi.Disposable;
import com.intellij.openapi.application.Application;
import com.intellij.openapi.application.ApplicationManager;
import com.intellij.openapi.application.ModalityState;
import com.intellij.openapi.application.ex.ApplicationEx;
import com.intellij.openapi.application.ex.ApplicationManagerEx;
import com.intellij.openapi.application.ex.ApplicationUtil;
import com.intellij.openapi.diagnostic.Attachment;
import com.intellij.openapi.diagnostic.Logger;
import com.intellij.openapi.progress.*;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.util.*;
import com.intellij.openapi.wm.ex.ProgressIndicatorEx;
import com.intellij.util.ExceptionUtil;
import com.intellij.util.SystemProperties;
import com.intellij.util.concurrency.AppExecutorUtil;
import com.intellij.util.containers.ConcurrentLongObjectMap;
import com.intellij.util.containers.ContainerUtil;
import com.intellij.util.ui.EDT;
import org.jetbrains.annotations.*;

import javax.swing.*;
import java.io.StringWriter;
import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.locks.LockSupport;
import java.util.function.Supplier;

import static com.intellij.openapi.application.ModalityKt.currentThreadContextModality;

public class CoreProgressManager extends ProgressManager implements Disposable {
  private static final Logger LOG = Logger.getInstance(CoreProgressManager.class);

  static final int CHECK_CANCELED_DELAY_MILLIS = 10;
  private final AtomicInteger myUnsafeProgressCount = new AtomicInteger(0);

  private ScheduledFuture<?> myCheckCancelledFuture; // guarded by threadsUnderIndicator

  // indicator -> threads which are running under this indicator.
  // THashMap is avoided here because of tombstones overhead
  private static final Map<ProgressIndicator, Set<Thread>> threadsUnderIndicator = new HashMap<>(); // guarded by threadsUnderIndicator
  // the active indicator for the thread id
  private static final ConcurrentLongObjectMap<ProgressIndicator> currentIndicators = ContainerUtil.createConcurrentLongObjectMap();
  // top-level indicators for the thread id
  private static final ConcurrentLongObjectMap<ProgressIndicator> threadTopLevelIndicators = ContainerUtil.createConcurrentLongObjectMap();
  // threads which are running under canceled indicator
  // THashSet is avoided here because of possible tombstones overhead
  static final Set<Thread> threadsUnderCanceledIndicator = new HashSet<>(); // guarded by threadsUnderIndicator

  private static volatile @NotNull CheckCanceledBehavior ourCheckCanceledBehavior = CheckCanceledBehavior.NONE;

  private enum CheckCanceledBehavior {NONE, ONLY_HOOKS, INDICATOR_PLUS_HOOKS}

  /**
   * active (i.e., which have {@link #executeProcessUnderProgress(Runnable, ProgressIndicator)} method running) indicators
   * which are not inherited from {@link StandardProgressIndicator}.
   * for them an extra processing thread (see {@link #myCheckCancelledFuture}) has to be run
   * to call their non-standard {@link ProgressIndicator#checkCanceled()} method periodically.
   * Poor-man Multiset here (instead of a set) is for simplifying add/remove indicators on process-with-progress start/end with possibly identical indicators.
   * ProgressIndicator -> count of this indicator occurrences in this multiset.
   */
  private static final Map<ProgressIndicator, AtomicInteger> nonStandardIndicators = new ConcurrentHashMap<>();

  // must be under threadsUnderIndicator lock
  private void startBackgroundNonStandardIndicatorsPing() {
    if (myCheckCancelledFuture != null) {
      return;
    }

    myCheckCancelledFuture = AppExecutorUtil.getAppScheduledExecutorService().scheduleWithFixedDelay(() -> {
      for (ProgressIndicator indicator : nonStandardIndicators.keySet()) {
        try {
          indicator.checkCanceled();
        }
        catch (ProcessCanceledException e) {
          indicatorCanceled(indicator);
        }
      }
    }, 0, CHECK_CANCELED_DELAY_MILLIS, TimeUnit.MILLISECONDS);
  }

  // must be under threadsUnderIndicator lock
  private void stopBackgroundNonStandardIndicatorsPing() {
    if (myCheckCancelledFuture != null) {
      myCheckCancelledFuture.cancel(true);
      myCheckCancelledFuture = null;
    }
  }

  @Override
  public void dispose() {
    synchronized (threadsUnderIndicator) {
      stopBackgroundNonStandardIndicatorsPing();
    }
  }

  @ApiStatus.Internal
  public static @NotNull List<ProgressIndicator> getCurrentIndicators() {
    synchronized (threadsUnderIndicator) {
      return new ArrayList<>(threadsUnderIndicator.keySet());
    }
  }

  @ApiStatus.Internal
  public boolean runCheckCanceledHooks(@Nullable ProgressIndicator indicator) {
    return false;
  }
  @ApiStatus.Internal
  protected boolean hasCheckCanceledHooks() {
    return false;
  }

  @Override
  protected void doCheckCanceled() throws ProcessCanceledException {
    if (isInNonCancelableSection()) {
      CheckCanceledBehavior behavior = ourCheckCanceledBehavior;
      if (behavior != CheckCanceledBehavior.NONE) {
        ProgressIndicator indicator = behavior == CheckCanceledBehavior.INDICATOR_PLUS_HOOKS ? getProgressIndicator() : null;
        runCheckCanceledHooks(indicator);
      }
      return;
    }

    Cancellation.checkCancelled();

    CheckCanceledBehavior behavior = ourCheckCanceledBehavior;
    if (behavior == CheckCanceledBehavior.NONE) return;

    if (behavior == CheckCanceledBehavior.INDICATOR_PLUS_HOOKS) {
      ProgressIndicator progress = getProgressIndicator();
      if (progress != null) {
        progress.checkCanceled();
      }
    }
    else {
      runCheckCanceledHooks(null);
    }
  }

  @Override
  public boolean hasProgressIndicator() {
    return getProgressIndicator() != null;
  }

  @Override
  public boolean hasUnsafeProgressIndicator() {
    return myUnsafeProgressCount.get() > 0;
  }

  @Override
  public boolean hasModalProgressIndicator() {
    synchronized (threadsUnderIndicator) {
      return ContainerUtil.or(threadsUnderIndicator.keySet(), i -> i.isModal());
    }
  }


  // run in current thread
  @Override
  public void runProcess(@NotNull Runnable process, @Nullable ProgressIndicator progress) {
    if (progress != null) {
      assertNoOtherThreadUnder(progress);
    }
    executeProcessUnderProgress(() -> {
      try {
        try {
          if (progress != null && !progress.isRunning()) {
            progress.start();
          }
        }
        catch (RuntimeException e) {
          throw e;
        }
        catch (Throwable e) {
          throw new RuntimeException(e);
        }
        process.run();
      }
      finally {
        if (progress != null && progress.isRunning()) {
          progress.stop();
          if (progress instanceof ProgressIndicatorEx) {
            ((ProgressIndicatorEx)progress).processFinish();
          }
        }
      }
    }, progress);
  }

  private static void assertNoOtherThreadUnder(@NotNull ProgressIndicator progress) {
    synchronized (threadsUnderIndicator) {
      Collection<Thread> threads = threadsUnderIndicator.get(progress);
      Thread other = threads == null || threads.isEmpty() ? null : threads.iterator().next();
      if (other != null) {
        if (other == Thread.currentThread()) {
          LOG.error("This thread is already running under this indicator, starting/stopping it here might be a data race");
        }
        else {
          StringWriter stackTrace = new StringWriter();
          ThreadDumper.dumpCallStack(other, stackTrace, other.getStackTrace());
          LOG.error("Other (" + other +") is already running under this indicator (" + progress+ ", " + progress.getClass() + "), starting/stopping it here might be a data race.\n" +
                    "Consider using com.intellij.openapi.progress.ProgressManager.executeProcessUnderProgress\n" +
                    "The other stack trace:\n" + stackTrace);
        }
      }
    }
  }

  // run in the current thread (?)
  @Override
  public void executeNonCancelableSection(@NotNull Runnable runnable) {
    computeInNonCancelableSection(() -> {
      runnable.run();
      return null;
    });
  }

  // FROM EDT: bg OR calling if can't
  @Override
  public <T, E extends Exception> T computeInNonCancelableSection(@NotNull ThrowableComputable<T, E> computable) throws E {
    return Cancellation.computeInNonCancelableSection(() -> computeUnderProgress(computable, NonCancelableIndicator.INSTANCE));
  }

  @Override
  public boolean runProcessWithProgressSynchronously(@NotNull Runnable process,
                                                     @NotNull @NlsContexts.DialogTitle String progressTitle,
                                                     boolean canBeCanceled,
                                                     @Nullable Project project) {
    return runProcessWithProgressSynchronously(process, progressTitle, canBeCanceled, project, null);
  }

  @Override
  public <T, E extends Exception> T runProcessWithProgressSynchronously(@NotNull ThrowableComputable<T, E> process,
                                                                        @NotNull @NlsContexts.DialogTitle String progressTitle,
                                                                        boolean canBeCanceled,
                                                                        @Nullable Project project) throws E {
    AtomicReference<T> result = new AtomicReference<>();
    AtomicReference<Throwable> exception = new AtomicReference<>();
    runProcessWithProgressSynchronously(new Task.Modal(project, progressTitle, canBeCanceled) {
      @Override
      public void run(@NotNull ProgressIndicator indicator) {
        try {
          T compute = process.compute();
          result.set(compute);
        }
        catch (Throwable t) {
          exception.set(t);
        }
      }
    });

    Throwable t = exception.get();
    if (t != null) {
      ExceptionUtil.rethrowUnchecked(t);
      @SuppressWarnings("unchecked") E e = (E)t;
      throw e;
    }

    return result.get();
  }

  // FROM EDT: bg OR calling if can't
  @Override
  public boolean runProcessWithProgressSynchronously(@NotNull Runnable process,
                                                     @NotNull @NlsContexts.DialogTitle String progressTitle,
                                                     boolean canBeCanceled,
                                                     @Nullable Project project,
                                                     @Nullable JComponent parentComponent) {
    Task.Modal task = new Task.Modal(project, parentComponent, progressTitle, canBeCanceled) {
      @Override
      public void run(@NotNull ProgressIndicator indicator) {
        process.run();
      }
    };
    return runProcessWithProgressSynchronously(task);
  }

  // bg; runnables on UI/EDT?
  @Override
  public void runProcessWithProgressAsynchronously(@NotNull Project project,
                                                   @NotNull @NlsContexts.ProgressTitle String progressTitle,
                                                   @NotNull Runnable process,
                                                   @Nullable Runnable successRunnable,
                                                   @Nullable Runnable canceledRunnable,
                                                   @NotNull PerformInBackgroundOption option) {
    runProcessWithProgressAsynchronously(new Task.Backgroundable(project, progressTitle, true, option) {
      @Override
      public void run(@NotNull ProgressIndicator indicator) {
        process.run();
      }


      @Override
      public void onCancel() {
        if (canceledRunnable != null) {
          canceledRunnable.run();
        }
      }

      @Override
      public void onSuccess() {
        if (successRunnable != null) {
          successRunnable.run();
        }
      }
    });
  }

  /**
   * Different places in IntelliJ codebase behaves differently in case of headless mode.
   * <p>
   * Often, they're trying to make async parts synchronous to make it more predictable or controllable.
   * E.g., in tests or IntelliJ-based command line tools this is the usual code:
   * <p>
   * ```
   * if (ApplicationManager.getApplication().isHeadless()) {
   * performSyncChange()
   * }
   * else {
   * scheduleAsyncChange()
   * }
   * ```
   * <p>
   * However, sometimes headless application should behave just as regular GUI Application,
   * with all its asynchronous stuff. For that, the application must declare `intellij.progress.task.ignoreHeadless`
   * system property. And clients should modify its pure `isHeadless` condition to something like
   * <p>
   * ```
   * ApplicationManager.getApplication().isHeadless() && !shouldRunHeadlessTasksAsynchronously()
   * ```
   *
   * @return true is asynchronous tasks must remain asynchronous even in headless mode
   */
  @ApiStatus.Internal
  public static boolean shouldKeepTasksAsynchronousInHeadlessMode() {
    return SystemProperties.getBooleanProperty("intellij.progress.task.ignoreHeadless", false);
  }

  @ApiStatus.Internal
  public static boolean shouldKeepTasksAsynchronous() {
    Application application = ApplicationManager.getApplication();
    boolean isHeadless = application.isUnitTestMode() || application.isHeadlessEnvironment();
    return !isHeadless || shouldKeepTasksAsynchronousInHeadlessMode();
  }

  // from any: bg or current if can't
  @Override
  public void run(@NotNull Task task) {
    if (isSynchronousHeadless(task)) {
      if (SwingUtilities.isEventDispatchThread()) {
        runProcessWithProgressSynchronously(task);
      }
      else {
        runProcessWithProgressInCurrentThread(task, new EmptyProgressIndicator(), ModalityState.defaultModalityState());
      }
    }
    else if (task.isModal()) {
      runProcessWithProgressSynchronously(task.asModal());
    }
    else {
      Task.Backgroundable backgroundable = task.asBackgroundable();
      if (isSynchronous(backgroundable)) {
        runProcessWithProgressSynchronously(backgroundable);
      }
      else {
        runAsynchronously(backgroundable);
      }
    }
  }

  private static boolean isSynchronousHeadless(Task task) {
    return task.isHeadless() && !shouldKeepTasksAsynchronousInHeadlessMode();
  }

  private static boolean isSynchronous(Task.Backgroundable backgroundable) {
    return backgroundable.isConditionalModal() && !backgroundable.shouldStartInBackground();
  }

  // from any: bg
  private void runAsynchronously(@NotNull Task.Backgroundable task) {
    if (LOG.isDebugEnabled()) LOG.debug("CoreProgressManager#runAsynchronously, " + task, new Throwable());
    if (ApplicationManager.getApplication().isDispatchThread()) {
      runProcessWithProgressAsynchronously(task);
    }
    else {
      ApplicationManager.getApplication().invokeLater(() -> {
        Project project = task.getProject();
        if (project != null && project.isDisposed()) {
          LOG.info("Task canceled because of project disposal: " + task);
          finishTask(task, true, null);
          return;
        }

        runProcessWithProgressAsynchronously(task);
      }, ModalityState.defaultModalityState());
    }
  }

  protected @NotNull ProgressIndicator createDefaultAsynchronousProgressIndicator(@NotNull Task.Backgroundable task) {
    return new EmptyProgressIndicator();
  }

  // from any: bg
  public @NotNull Future<?> runProcessWithProgressAsynchronously(@NotNull Task.Backgroundable task) {
    return runProcessWithProgressAsynchronously(task, createDefaultAsynchronousProgressIndicator(task), null);
  }

  // from any: bg
  public @NotNull Future<?> runProcessWithProgressAsynchronously(@NotNull Task.Backgroundable task,
                                                        @NotNull ProgressIndicator progressIndicator,
                                                        @Nullable Runnable continuation) {
    return runProcessWithProgressAsynchronously(task, progressIndicator, continuation, progressIndicator.getModalityState());
  }

  @Deprecated
  protected void startTask(@NotNull Task task, @NotNull ProgressIndicator indicator, @Nullable Runnable continuation) {
    try {
      if (LOG.isDebugEnabled()) LOG.debug("Starting task '" + task + "' under progress: " + indicator, new Throwable());
      task.run(indicator);
    }
    finally {
      try {
        if (indicator instanceof ProgressIndicatorEx) {
          ((ProgressIndicatorEx)indicator).finish(task);
        }
      }
      finally {
        if (continuation != null) {
          continuation.run();
        }
      }
    }
  }

  private static class IndicatorDisposable implements Disposable {
    private final @NotNull ProgressIndicator myIndicator;

    IndicatorDisposable(@NotNull ProgressIndicator indicator) {
      myIndicator = indicator;
    }

    @Override
    public void dispose() {
      // do nothing if already disposed
      Disposer.dispose((Disposable)myIndicator, false);
    }
  }

  // from any: bg, task.finish on "UI/EDT"
  public @NotNull Future<?> runProcessWithProgressAsynchronously(@NotNull Task.Backgroundable task,
                                                        @NotNull ProgressIndicator progressIndicator,
                                                        @Nullable Runnable continuation,
                                                        @NotNull ModalityState modalityState) {
    IndicatorDisposable indicatorDisposable;
    if (progressIndicator instanceof Disposable) {
      // use IndicatorDisposable instead of progressIndicator to
      // avoid re-registering progressIndicator if it was registered on some other parent before
      indicatorDisposable = new IndicatorDisposable(progressIndicator);
      Disposer.register(ApplicationManager.getApplication(), indicatorDisposable);
    }
    else {
      indicatorDisposable = null;
    }

    AtomicLong elapsed = new AtomicLong();
    return new ProgressRunner<>(progress -> {
      long start = System.currentTimeMillis();
      try {
        startTask(task, progress, continuation);
      }
      finally {
        elapsed.set(System.currentTimeMillis() - start);
      }
      return null;
    }).onThread(ProgressRunner.ThreadToUse.POOLED)
      .withProgress(progressIndicator)
      .submit()
      .whenComplete(ClientId.decorateBiConsumer((result, err) -> {
        if (!result.isCanceled()) {
          notifyTaskFinished(task, elapsed.get());
        }

        ApplicationUtil.invokeLaterSomewhere(task.whereToRunCallbacks(), modalityState, () -> {
          finishTask(task, result.isCanceled(), result.getThrowable() instanceof ProcessCanceledException ? null : result.getThrowable());
          if (indicatorDisposable != null) {
            Disposer.dispose(indicatorDisposable);
          }
        });
      }));
  }

  void notifyTaskFinished(@NotNull Task.Backgroundable task, long elapsed) {

  }

  // ASSERT IS EDT->UI bg or calling if can't
  // NEW: no assert; bg or calling ...
  protected boolean runProcessWithProgressSynchronously(@NotNull Task task) {
    if (LOG.isDebugEnabled()) LOG.debug("CoreProgressManager#runProcessWithProgressSynchronously, " + task, new Throwable());
    Ref<Throwable> exceptionRef = new Ref<>();
    Runnable taskContainer = () -> {
      try {
        startTask(task, getProgressIndicator(), null);
      }
      catch (ProcessCanceledException e) {
        throw e;
      }
      catch (Throwable e) {
        exceptionRef.set(e);
      }
    };

    ApplicationEx application = ApplicationManagerEx.getApplicationEx();
    boolean result = application.runProcessWithProgressSynchronously(taskContainer,
                                                                     task.getTitle(),
                                                                     task.isCancellable(),
                                                                     shouldEnterModalityState(task),
                                                                     task.getProject(),
                                                                     task.getParentComponent(),
                                                                     task.getCancelText());

    ApplicationUtil.invokeAndWaitSomewhere(task.whereToRunCallbacks(),
                                           application.getDefaultModalityState(),
                                           () -> finishTask(task, !result, exceptionRef.get()));
    return result;
  }

  @ApiStatus.Internal
  @VisibleForTesting
  public static boolean shouldEnterModalityState(@NotNull Task task) {
    return task.isModal() ||
           EDT.isCurrentThreadEdt() &&
           !isSynchronousHeadless(task) &&
           isSynchronous(task.asBackgroundable());
  }

  public void runProcessWithProgressInCurrentThread(@NotNull Task task,
                                                    @NotNull ProgressIndicator progressIndicator,
                                                    @NotNull ModalityState modalityState) {
    if (LOG.isDebugEnabled()) LOG.debug("CoreProgressManager#runProcessWithProgressInCurrentThread, " + task, new Throwable());
    if (progressIndicator instanceof Disposable) {
      Disposer.register(ApplicationManager.getApplication(), (Disposable)progressIndicator);
    }

    boolean processCanceled = false;
    Throwable exception = null;
    try {
      runProcess(() -> startTask(task, progressIndicator, null), progressIndicator);
    }
    catch (ProcessCanceledException e) {
      processCanceled = true;
    }
    catch (Throwable e) {
      exception = e;
    }

    boolean finalCanceled = processCanceled || progressIndicator.isCanceled();
    Throwable finalException = exception;

    ApplicationUtil.invokeAndWaitSomewhere(task.whereToRunCallbacks(), modalityState, () -> finishTask(task, finalCanceled, finalException));
  }

  protected void finishTask(@NotNull Task task, boolean canceled, @Nullable Throwable error) {
    try {
      if (error != null) {
        task.onThrowable(error);
      }
      else if (canceled) {
        task.onCancel();
      }
      else {
        task.onSuccess();
      }
    }
    finally {
      task.onFinished();
    }
  }

  // bg
  @Override
  public void runProcessWithProgressAsynchronously(@NotNull Task.Backgroundable task, @NotNull ProgressIndicator progressIndicator) {
    runProcessWithProgressAsynchronously(task, progressIndicator, null);
  }

  @Override
  public ProgressIndicator getProgressIndicator() {
    return getCurrentIndicator(Thread.currentThread());
  }

  // run in current thread
  @Override
  public void executeProcessUnderProgress(@NotNull Runnable process, ProgressIndicator progress) throws ProcessCanceledException {
    computeUnderProgress(() -> {
      process.run();
      return null;
    }, progress);
  }

  @Override
  public boolean runInReadActionWithWriteActionPriority(@NotNull Runnable action, @Nullable ProgressIndicator indicator) {
    ApplicationManager.getApplication().runReadAction(action);
    return true;
  }

  private <V, E extends Throwable> V computeUnderProgress(@NotNull ThrowableComputable<V, E> process, ProgressIndicator progress) throws E {
    if (progress == null) {
      myUnsafeProgressCount.incrementAndGet();
      try {
        return process.compute();
      }
      finally {
        myUnsafeProgressCount.decrementAndGet();
      }
    }

    ProgressIndicator oldIndicator = getProgressIndicator();
    if (progress == oldIndicator) {
      return process.compute();
    }

    Thread currentThread = Thread.currentThread();
    long threadId = currentThread.getId();
    setCurrentIndicator(threadId, progress);
    try {
      return registerIndicatorAndRun(progress, currentThread, oldIndicator, process);
    }
    finally {
      setCurrentIndicator(threadId, oldIndicator);
    }
  }

  // this thread
  private <V, E extends Throwable> V registerIndicatorAndRun(@NotNull ProgressIndicator indicator,
                                                             @NotNull Thread currentThread,
                                                             ProgressIndicator oldIndicator,
                                                             @NotNull ThrowableComputable<V, E> process) throws E {
    List<Set<Thread>> threadsUnderThisIndicator = new ArrayList<>();
    synchronized (threadsUnderIndicator) {
      boolean oneOfTheIndicatorsIsCanceled = false;

      for (ProgressIndicator thisIndicator = indicator;
           thisIndicator != null;
           thisIndicator = thisIndicator instanceof WrappedProgressIndicator
                           ? ((WrappedProgressIndicator)thisIndicator).getOriginalProgressIndicator()
                           : null) {
        Set<Thread> underIndicator = threadsUnderIndicator.computeIfAbsent(thisIndicator, __ -> new HashSet<>());
        boolean alreadyUnder = !underIndicator.add(currentThread);
        threadsUnderThisIndicator.add(alreadyUnder ? null : underIndicator);

        boolean isStandard = thisIndicator instanceof StandardProgressIndicator;
        if (!isStandard) {
          nonStandardIndicators.compute(thisIndicator, (__, count) -> {
            if (count == null) {
              return new AtomicInteger(1);
            }
            count.incrementAndGet();
            return count;
          });
          startBackgroundNonStandardIndicatorsPing();
        }

        oneOfTheIndicatorsIsCanceled = oneOfTheIndicatorsIsCanceled || thisIndicator.isCanceled();
      }

      updateThreadUnderCanceledIndicator(currentThread, oneOfTheIndicatorsIsCanceled);
    }

    try {
      return process.compute();
    }
    finally {
      synchronized (threadsUnderIndicator) {
        ProgressIndicator thisIndicator = null;
        // order doesn't matter
        for (int i = 0; i < threadsUnderThisIndicator.size(); i++) {
          thisIndicator = i == 0 ? indicator : ((WrappedProgressIndicator)thisIndicator).getOriginalProgressIndicator();
          Set<Thread> underIndicator = threadsUnderThisIndicator.get(i);
          boolean removed = underIndicator != null && underIndicator.remove(currentThread);
          if (removed && underIndicator.isEmpty()) {
            threadsUnderIndicator.remove(thisIndicator);
          }
          boolean isStandard = thisIndicator instanceof StandardProgressIndicator;
          if (!isStandard) {
            AtomicInteger newCount = nonStandardIndicators.compute(thisIndicator, (__, count) -> {
              if (count == null || count.decrementAndGet() == 0) {
                return null;
              }
              return count;
            });
            if (newCount == null) {
              stopBackgroundNonStandardIndicatorsPing();
            }
          }
          // by this time oldIndicator may have been canceled
        }
        updateThreadUnderCanceledIndicator(currentThread, oldIndicator != null && oldIndicator.isCanceled());
      }
    }
  }

  private void updateThreadUnderCanceledIndicator(@NotNull Thread thread, boolean underCanceledIndicator) {
    boolean changed = underCanceledIndicator ? threadsUnderCanceledIndicator.add(thread) : threadsUnderCanceledIndicator.remove(thread);
    if (changed) {
      updateShouldCheckCanceled();
    }
  }

  final void updateShouldCheckCanceled() {
    synchronized (threadsUnderIndicator) {
      boolean hasCanceledIndicator = !threadsUnderCanceledIndicator.isEmpty();
      ourCheckCanceledBehavior = !hasCheckCanceledHooks() && !hasCanceledIndicator ? CheckCanceledBehavior.NONE :
                                 hasCanceledIndicator ? CheckCanceledBehavior.INDICATOR_PLUS_HOOKS :
                                 CheckCanceledBehavior.ONLY_HOOKS;
    }
  }

  @Override
  protected void indicatorCanceled(@NotNull ProgressIndicator indicator) {
    // mark threads running under this indicator as canceled
    synchronized (threadsUnderIndicator) {
      Set<Thread> threads = threadsUnderIndicator.get(indicator);
      if (threads != null) {
        for (Thread thread : threads) {
          boolean underCancelledIndicator = false;
          for (ProgressIndicator currentIndicator = getCurrentIndicator(thread);
               currentIndicator != null;
               currentIndicator = currentIndicator instanceof WrappedProgressIndicator ?
                                  ((WrappedProgressIndicator)currentIndicator).getOriginalProgressIndicator() : null) {
            if (currentIndicator == indicator) {
              underCancelledIndicator = true;
              break;
            }
          }

          if (underCancelledIndicator) {
            threadsUnderCanceledIndicator.add(thread);
            updateShouldCheckCanceled();
          }
        }
      }
    }
  }

  @TestOnly
  public static boolean isCanceledThread(@NotNull Thread thread) {
    synchronized (threadsUnderIndicator) {
      return threadsUnderCanceledIndicator.contains(thread);
    }
  }

  @Override
  public boolean isInNonCancelableSection() {
    return Cancellation.isInNonCancelableSection();
  }

  private static final long MAX_PRIORITIZATION_NANOS = TimeUnit.SECONDS.toNanos(12); // maximum duration of process to run under low priority
  private static final long MIN_PRIORITIZATION_NANOS = TimeUnit.MILLISECONDS.toNanos(5); // minimum duration of process to consider prioritizing it down
  private final Set<Thread> myPrioritizedThreads = ContainerUtil.newConcurrentSet();
  private final AtomicInteger myDeprioritizations = new AtomicInteger();
  private volatile long myPrioritizingStartedNanos;

  @Override
  public <T, E extends Throwable> T computePrioritized(@NotNull ThrowableComputable<T, E> computable) throws E {
    Thread thread = Thread.currentThread();
    boolean prioritize;
    if (isCurrentThreadPrioritized()) {
      prioritize = false;
    }
    else {
      prioritize = true;
      if (myPrioritizedThreads.isEmpty()) {
        myPrioritizingStartedNanos = System.nanoTime();
      }
      changePrioritizing(()->myPrioritizedThreads.add(thread));
    }
    try {
      return computable.compute();
    }
    finally {
      if (prioritize) {
        changePrioritizing(()->myPrioritizedThreads.remove(thread));
      }
    }
  }

  private <T> T changePrioritizing(@NotNull Computable<? extends T> runnable) {
    boolean prevIsEmpty = myDeprioritizations.get() > 0 || myPrioritizedThreads.isEmpty();
    T result = runnable.compute();
    boolean currentIsEmpty = myDeprioritizations.get() > 0 || myPrioritizedThreads.isEmpty();
    if (prevIsEmpty && !currentIsEmpty) {
      prioritizingStarted();
    }
    else if (!prevIsEmpty && currentIsEmpty) {
      prioritizingFinished();
    }
    return result;
  }

  protected void prioritizingStarted() {}

  protected void prioritizingFinished() {}

  @ApiStatus.Internal
  public boolean isCurrentThreadPrioritized() {
    return myPrioritizedThreads.contains(Thread.currentThread());
  }

  @ApiStatus.Internal
  public void suppressPrioritizing() {
    int newDeprioritizations = changePrioritizing(()->myDeprioritizations.incrementAndGet());
    if (newDeprioritizations == 100 + ForkJoinPool.getCommonPoolParallelism() * 2) {
      Attachment attachment = new Attachment("threadDump.txt", ThreadDumper.dumpThreadsToString());
      attachment.setIncluded(true);
      LOG.error("A suspiciously high nesting of suppressPrioritizing, forgot to call restorePrioritizing?", attachment);
    }
  }

  @ApiStatus.Internal
  public void restorePrioritizing() {
    int newDeprioritizations = changePrioritizing(()->myDeprioritizations.decrementAndGet());
    if (newDeprioritizations < 0) {
      changePrioritizing(()->myDeprioritizations.getAndSet(0));
      LOG.error("Unmatched suppressPrioritizing/restorePrioritizing");
    }
  }

  protected boolean sleepIfNeededToGivePriorityToAnotherThread() {
    if (isDeprioritizationEnabled() && !isCurrentThreadEffectivelyPrioritized() && isLowPriorityReallyApplicable()) {
      LockSupport.parkNanos(1_000_000);
      avoidBlockingPrioritizingThread();
      return true;
    }
    return false;
  }

  private boolean isCurrentThreadEffectivelyPrioritized() {
    if (myDeprioritizations.get()>0) {
      return false;
    }
    return isCurrentThreadPrioritized();
  }

  private boolean isLowPriorityReallyApplicable() {
    long time = System.nanoTime() - myPrioritizingStartedNanos;
    if (time < MIN_PRIORITIZATION_NANOS) {
      return false; // don't sleep when activities are very short (e.g., empty processing of mouseMoved events)
    }

    if (avoidBlockingPrioritizingThread()) {
      return false;
    }

    if (ApplicationManager.getApplication().isDispatchThread()) {
      return false; // EDT always has high priority
    }

    if (time > MAX_PRIORITIZATION_NANOS) {
      // Don't wait forever in case someone forgot to stop prioritizing before waiting for other threads to complete
      // wait just for 12 seconds; this will be noticeable (and we'll get 2 thread dumps) but not fatal
      stopAllPrioritization();
      return false;
    }
    return true;
  }

  private boolean avoidBlockingPrioritizingThread() {
    if (isAnyPrioritizedThreadBlocked()) {
      // the current thread could hold a lock that prioritized threads are waiting for
      suppressPrioritizing();
      checkLaterThreadsAreUnblocked();
      return true;
    }
    return false;
  }

  private void checkLaterThreadsAreUnblocked() {
    try {
      AppExecutorUtil.getAppScheduledExecutorService().schedule((ContextAwareRunnable)() -> {
        if (isAnyPrioritizedThreadBlocked()) {
          checkLaterThreadsAreUnblocked();
        }
        else {
          restorePrioritizing();
        }
      }, 5, TimeUnit.MILLISECONDS);
    }
    catch (RejectedExecutionException ignore) {
    }
  }

  private void stopAllPrioritization() {
    changePrioritizing(()->{myPrioritizedThreads.clear(); return null;});
  }

  private boolean isAnyPrioritizedThreadBlocked() {
    if (myDeprioritizations.get()>0) {
      return false;
    }
    for (Thread thread : myPrioritizedThreads) {
      Thread.State state = thread.getState();
      if (state == Thread.State.WAITING || state == Thread.State.TIMED_WAITING || state == Thread.State.BLOCKED) {
        return true;
      }
    }
    return false;
  }

  private boolean isDeprioritizationEnabled() {
    return myDeprioritizations.get() < 1_000_000;
  }
  @TestOnly
  @ApiStatus.Internal
  public <T,E extends Throwable> T suppressAllDeprioritizationsDuringLongTestsExecutionIn(@NotNull ThrowableComputable<T, E> runnable) throws E {
    myDeprioritizations.addAndGet(1_000_000);
    try {
      return runnable.compute();
    }
    finally {
      myDeprioritizations.addAndGet(-1_000_000);
    }
  }

  public static @NotNull ModalityState getCurrentThreadProgressModality() {
    ModalityState contextModality = currentThreadContextModality();
    if (contextModality != null) {
      return contextModality;
    }
    ModalityState progressModality = ProgressManager.getInstance().getCurrentProgressModality();
    return progressModality != null ? progressModality : ModalityState.nonModal();
  }

  private static void setCurrentIndicator(long threadId, ProgressIndicator indicator) {
    if (indicator == null) {
      currentIndicators.remove(threadId);
      threadTopLevelIndicators.remove(threadId);
    }
    else {
      currentIndicators.put(threadId, indicator);
      threadTopLevelIndicators.putIfAbsent(threadId, indicator);
    }
  }

  private static ProgressIndicator getCurrentIndicator(@NotNull Thread thread) {
    return currentIndicators.get(thread.getId());
  }

  @Override
  public <X> X silenceGlobalIndicator(@NotNull Supplier<? extends X> computable) {
    long id = Thread.currentThread().getId();
    ProgressIndicator topLevelIndicator = threadTopLevelIndicators.remove(id);
    ProgressIndicator currentIndicator = currentIndicators.remove(id);
    try {
      return computable.get();
    }
    finally {
      if (currentIndicator != null) {
        currentIndicators.put(id, currentIndicator);
      }
      if (topLevelIndicator != null) {
        threadTopLevelIndicators.put(id, topLevelIndicator);
      }
    }
  }

  @Override
  public @Nullable ModalityState getCurrentProgressModality() {
    ProgressIndicator indicator = threadTopLevelIndicators.get(Thread.currentThread().getId());
    return indicator == null ? null : indicator.getModalityState();
  }

  @FunctionalInterface
  interface CheckCanceledHook {
    CheckCanceledHook[] EMPTY_ARRAY = new CheckCanceledHook[0];
    /**
     * @param indicator the indicator whose {@link ProgressIndicator#checkCanceled()} was called,
     *                  or null if {@link ProgressManager#checkCanceled()} was called (even on a thread with indicator)
     * @return true if the hook has done anything that might take some time.
     */
    boolean runHook(@Nullable ProgressIndicator indicator);
  }

  public static void assertUnderProgress(@NotNull ProgressIndicator indicator) {
    synchronized (threadsUnderIndicator) {
      Set<Thread> threads = threadsUnderIndicator.get(indicator);
      if (threads == null || !threads.contains(Thread.currentThread())) {
        LOG.error("Must be executed under progress indicator: " + indicator + ". Please see e.g. ProgressManager.runProcess()");
      }
    }
  }
}


EventDispatchThread-
/*
 * Copyright (c) 1996, 2022, Oracle and/or its affiliates. All rights reserved.
 * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */

package java.awt;

import java.awt.event.MouseEvent;
import java.awt.event.ActionEvent;
import java.awt.event.WindowEvent;

import java.util.ArrayList;

import sun.util.logging.PlatformLogger;

import sun.awt.dnd.SunDragSourceContextPeer;

/**
 * EventDispatchThread is a package-private AWT class which takes
 * events off the EventQueue and dispatches them to the appropriate
 * AWT components.
 *
 * The Thread starts a "permanent" event pump with a call to
 * pumpEvents(Conditional) in its run() method. Event handlers can choose to
 * block this event pump at any time, but should start a new pump (<b>not</b>
 * a new EventDispatchThread) by again calling pumpEvents(Conditional). This
 * secondary event pump will exit automatically as soon as the Conditional
 * evaluate()s to false and an additional Event is pumped and dispatched.
 *
 * @author Tom Ball
 * @author Amy Fowler
 * @author Fred Ecks
 * @author David Mendenhall
 *
 * @since 1.1
 */
class EventDispatchThread extends Thread {

    private static final PlatformLogger eventLog = PlatformLogger.getLogger("java.awt.event.EventDispatchThread");

    private EventQueue theQueue;
    private volatile boolean doDispatch = true;

    private static final int ANY_EVENT = -1;

    private ArrayList<EventFilter> eventFilters = new ArrayList<EventFilter>();

   /**
    * Must always call 5 args super-class constructor passing false
    * to indicate not to inherit locals.
    */
    private EventDispatchThread() {
        throw new UnsupportedOperationException("Must erase locals");
    }

    EventDispatchThread(ThreadGroup group, String name, EventQueue queue) {
        super(group, null, name, 0, false);
        setEventQueue(queue);
    }

    /*
     * Must be called on EDT only, that's why no synchronization
     */
    public void stopDispatching() {
        doDispatch = false;
    }

    public void run() {
        try {
            pumpEvents(new Conditional() {
                public boolean evaluate() {
                    return true;
                }
            });
        } finally {
            getEventQueue().detachDispatchThread(this);
        }
    }

    void pumpEvents(Conditional cond) {
        pumpEvents(ANY_EVENT, cond);
    }

    void pumpEventsForHierarchy(Conditional cond, Component modalComponent) {
        pumpEventsForHierarchy(ANY_EVENT, cond, modalComponent);
    }

    void pumpEvents(int id, Conditional cond) {
        pumpEventsForHierarchy(id, cond, null);
    }

    void pumpEventsForHierarchy(int id, Conditional cond, Component modalComponent) {
        pumpEventsForFilter(id, cond, new HierarchyEventFilter(modalComponent));
    }

    void pumpEventsForFilter(Conditional cond, EventFilter filter) {
        pumpEventsForFilter(ANY_EVENT, cond, filter);
    }

    void pumpEventsForFilter(int id, Conditional cond, EventFilter filter) {
        addEventFilter(filter);
        doDispatch = true;
        while (doDispatch && !isInterrupted() && cond.evaluate()) {
            pumpOneEventForFilters(id);
        }
        removeEventFilter(filter);
    }

    void addEventFilter(EventFilter filter) {
        if (eventLog.isLoggable(PlatformLogger.Level.FINEST)) {
            eventLog.finest("adding the event filter: " + filter);
        }
        synchronized (eventFilters) {
            if (!eventFilters.contains(filter)) {
                if (filter instanceof ModalEventFilter) {
                    ModalEventFilter newFilter = (ModalEventFilter)filter;
                    int k = 0;
                    for (k = 0; k < eventFilters.size(); k++) {
                        EventFilter f = eventFilters.get(k);
                        if (f instanceof ModalEventFilter) {
                            ModalEventFilter cf = (ModalEventFilter)f;
                            if (cf.compareTo(newFilter) > 0) {
                                break;
                            }
                        }
                    }
                    eventFilters.add(k, filter);
                } else {
                    eventFilters.add(filter);
                }
            }
        }
    }

    void removeEventFilter(EventFilter filter) {
        if (eventLog.isLoggable(PlatformLogger.Level.FINEST)) {
            eventLog.finest("removing the event filter: " + filter);
        }
        synchronized (eventFilters) {
            eventFilters.remove(filter);
        }
    }

    boolean filterAndCheckEvent(AWTEvent event) {
        boolean eventOK = true;
        synchronized (eventFilters) {
            for (int i = eventFilters.size() - 1; i >= 0; i--) {
                EventFilter f = eventFilters.get(i);
                EventFilter.FilterAction accept = f.acceptEvent(event);
                if (accept == EventFilter.FilterAction.REJECT) {
                    eventOK = false;
                    break;
                } else if (accept == EventFilter.FilterAction.ACCEPT_IMMEDIATELY) {
                    break;
                }
            }
        }
        return eventOK && SunDragSourceContextPeer.checkEvent(event);
    }

    void pumpOneEventForFilters(int id) {
        AWTEvent event = null;
        boolean eventOK = false;
        try {
            EventQueue eq = null;
            do {
                // EventQueue may change during the dispatching
                eq = getEventQueue();

                event = (id == ANY_EVENT) ? eq.getNextEvent() : eq.getNextEvent(id);

                eventOK = filterAndCheckEvent(event);
                if (!eventOK) {
                    event.consume();
                }
            }
            while (eventOK == false);

            if (eventLog.isLoggable(PlatformLogger.Level.FINEST)) {
                eventLog.finest("Dispatching: " + event);
            }

            eq.dispatchEvent(event);
        }
        catch (InterruptedException interruptedException) {
            doDispatch = false; // AppContext.dispose() interrupts all
                                // Threads in the AppContext
        }
        catch (Throwable e) {
            processException(e);
        }
    }

    private void processException(Throwable e) {
        if (eventLog.isLoggable(PlatformLogger.Level.FINE)) {
            eventLog.fine("Processing exception: " + e);
        }
        getUncaughtExceptionHandler().uncaughtException(this, e);
    }

    public synchronized EventQueue getEventQueue() {
        return theQueue;
    }
    public synchronized void setEventQueue(EventQueue eq) {
        theQueue = eq;
    }

    private static class HierarchyEventFilter implements EventFilter {
        private Component modalComponent;
        public HierarchyEventFilter(Component modalComponent) {
            this.modalComponent = modalComponent;
        }
        public FilterAction acceptEvent(AWTEvent event) {
            if (modalComponent != null) {
                int eventID = event.getID();
                boolean mouseEvent = (eventID >= MouseEvent.MOUSE_FIRST) &&
                                     (eventID <= MouseEvent.MOUSE_LAST);
                boolean actionEvent = (eventID >= ActionEvent.ACTION_FIRST) &&
                                      (eventID <= ActionEvent.ACTION_LAST);
                boolean windowClosingEvent = (eventID == WindowEvent.WINDOW_CLOSING);
                /*
                 * filter out MouseEvent and ActionEvent that's outside
                 * the modalComponent hierarchy.
                 * KeyEvent is handled by using enqueueKeyEvent
                 * in Dialog.show
                 */
                if (Component.isInstanceOf(modalComponent, "javax.swing.JInternalFrame")) {
                    /*
                     * Modal internal frames are handled separately. If event is
                     * for some component from another heavyweight than modalComp,
                     * it is accepted. If heavyweight is the same - we still accept
                     * event and perform further filtering in LightweightDispatcher
                     */
                    return windowClosingEvent ? FilterAction.REJECT : FilterAction.ACCEPT;
                }
                if (mouseEvent || actionEvent || windowClosingEvent) {
                    Object o = event.getSource();
                    if (o instanceof sun.awt.ModalExclude) {
                        // Exclude this object from modality and
                        // continue to pump it's events.
                        return FilterAction.ACCEPT;
                    } else if (o instanceof Component) {
                        Component c = (Component) o;
                        // 5.0u3 modal exclusion
                        boolean modalExcluded = false;
                        if (modalComponent instanceof Container) {
                            while (c != modalComponent && c != null) {
                                if ((c instanceof Window) &&
                                    (sun.awt.SunToolkit.isModalExcluded((Window)c))) {
                                    // Exclude this window and all its children from
                                    //  modality and continue to pump it's events.
                                    modalExcluded = true;
                                    break;
                                }
                                c = c.getParent();
                            }
                        }
                        if (!modalExcluded && (c != modalComponent)) {
                            return FilterAction.REJECT;
                        }
                    }
                }
            }
            return FilterAction.ACCEPT;
        }
    }
}


Now Tell me whats exactly happening here briefly

After an actionperformed method of a plugin ends the following stack is performed-
actionPerformed:59, RunChangeTrackingAction (com.your.projectroot)
doPerformActionOrShowPopup:339, ActionUtil (com.intellij.openapi.actionSystem.ex)
lambda$performActionDumbAwareWithCallbacks$4:313, ActionUtil (com.intellij.openapi.actionSystem.ex)
run:-1, ActionUtil$$Lambda$4603/0x000000080215e658 (com.intellij.openapi.actionSystem.ex)
performDumbAwareWithCallbacks:362, ActionUtil (com.intellij.openapi.actionSystem.ex)
performActionDumbAwareWithCallbacks:313, ActionUtil (com.intellij.openapi.actionSystem.ex)
lambda$performAction$5:300, ActionMenuItem (com.intellij.openapi.actionSystem.impl)
run:-1, ActionMenuItem$$Lambda$4602/0x000000080215e408 (com.intellij.openapi.actionSystem.impl)
runOnOwnContext:226, FocusManagerImpl (com.intellij.openapi.wm.impl)
performAction:293, ActionMenuItem (com.intellij.openapi.actionSystem.impl)
lambda$new$1:82, ActionMenuItem (com.intellij.openapi.actionSystem.impl)
run:-1, ActionMenuItem$$Lambda$4601/0x000000080215e1b8 (com.intellij.openapi.actionSystem.impl)
performActivity:113, TransactionGuardImpl (com.intellij.openapi.application)
performUserActivity:94, TransactionGuardImpl (com.intellij.openapi.application)
lambda$new$2:82, ActionMenuItem (com.intellij.openapi.actionSystem.impl)
run:-1, ActionMenuItem$$Lambda$4600/0x000000080215df68 (com.intellij.openapi.actionSystem.impl)
dispatch:318, InvocationEvent (java.awt.event)
dispatchEventImpl:792, EventQueue (java.awt)
run:739, EventQueue$3 (java.awt)
run:733, EventQueue$3 (java.awt)
executePrivileged:776, AccessController (java.security)
doPrivileged:399, AccessController (java.security)
doIntersectionPrivilege:86, ProtectionDomain$JavaSecurityAccessImpl (java.security)
dispatchEvent:761, EventQueue (java.awt)
defaultDispatchEvent:690, IdeEventQueue (com.intellij.ide)
_dispatchEvent$lambda$10:593, IdeEventQueue (com.intellij.ide)
run:-1, IdeEventQueue$$Lambda$401/0x00000008004b9168 (com.intellij.ide)
runWithoutImplicitRead:1485, ApplicationImpl (com.intellij.openapi.application.impl)
_dispatchEvent:593, IdeEventQueue (com.intellij.ide)
access$_dispatchEvent:67, IdeEventQueue (com.intellij.ide)
compute:369, IdeEventQueue$dispatchEvent$processEventRunnable$1$1$1 (com.intellij.ide)
compute:368, IdeEventQueue$dispatchEvent$processEventRunnable$1$1$1 (com.intellij.ide)
computePrioritized:787, CoreProgressManager (com.intellij.openapi.progress.impl)
invoke:368, IdeEventQueue$dispatchEvent$processEventRunnable$1$1 (com.intellij.ide)
invoke:363, IdeEventQueue$dispatchEvent$processEventRunnable$1$1 (com.intellij.ide)
performActivity$lambda$1:997, IdeEventQueueKt (com.intellij.ide)
run:-1, IdeEventQueueKt$$Lambda$395/0x00000008004a7bd8 (com.intellij.ide)
performActivity:105, TransactionGuardImpl (com.intellij.openapi.application)
performActivity:997, IdeEventQueueKt (com.intellij.ide)
dispatchEvent$lambda$7:363, IdeEventQueue (com.intellij.ide)
run:-1, IdeEventQueue$$Lambda$392/0x00000008004a5218 (com.intellij.ide)
runIntendedWriteActionOnCurrentThread:861, ApplicationImpl (com.intellij.openapi.application.impl)
dispatchEvent:405, IdeEventQueue (com.intellij.ide)
pumpOneEventForFilters:207, EventDispatchThread (java.awt)
pumpEventsForFilter:128, EventDispatchThread (java.awt)
pumpEventsForHierarchy:117, EventDispatchThread (java.awt)
pumpEvents:113, EventDispatchThread (java.awt)
pumpEvents:105, EventDispatchThread (java.awt)
run:92, EventDispatchThread (java.awt)