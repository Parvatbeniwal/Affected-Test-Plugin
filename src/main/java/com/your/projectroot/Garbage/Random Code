//package com.your.projectroot;
//
//import com.github.javaparser.JavaParser;
//import com.github.javaparser.ParseException;
//import com.github.javaparser.ast.CompilationUnit;
//import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;
//import com.github.javaparser.ast.body.MethodDeclaration;
//import com.github.javaparser.ast.visitor.VoidVisitorAdapter;
//import com.intellij.openapi.components.Service;
//import com.intellij.openapi.diagnostic.Logger;
//import com.intellij.openapi.project.Project;
//import com.intellij.openapi.vcs.changes.Change;
//import com.intellij.openapi.vcs.changes.ChangeListManager;
//import com.intellij.openapi.vcs.changes.LocalChangeList;
//import com.intellij.openapi.vfs.VirtualFile;
//import org.eclipse.jgit.api.Git;
//import org.eclipse.jgit.lib.ObjectId;
//import org.eclipse.jgit.lib.ObjectReader;
//import org.eclipse.jgit.lib.Repository;
//import org.eclipse.jgit.revwalk.RevCommit;
//import org.eclipse.jgit.revwalk.RevWalk;
//import org.eclipse.jgit.treewalk.TreeWalk;
//import org.eclipse.jgit.treewalk.filter.PathFilter;
//
//import java.io.ByteArrayInputStream;
//import java.io.ByteArrayOutputStream;
//import java.io.File;
//import java.io.IOException;
//import java.nio.charset.StandardCharsets;
//import java.util.ArrayList;
//import java.util.HashMap;
//import java.util.List;
//import java.util.Map;
//
//@Service(Service.Level.PROJECT)
//public final class ChangeTrackingService {
//
//    private static final Logger logger = Logger.getInstance(ChangeTrackingService.class);
//    private final Project project;
//    public static List<String> changes = new ArrayList<>();
//    public ChangeTrackingService(Project project) {
//        this.project = project;
//    }
//
//    public void trackChangesAndRunTests() {
//        System.out.println("Beginning: ");
//        ChangeListManager changeListManager = ChangeListManager.getInstance(project);
//
//        // Get the list of local changes
//        List<LocalChangeList> changes = changeListManager.getChangeLists();
//
//        // Iterate over changes and process them
//        for (LocalChangeList changeList : changes) {
//            for (Change change : changeList.getChanges()) {
//                VirtualFile file = change.getVirtualFile();
//
//                if (file != null) {
//                    // Process each changed file to determine affected unit tests
//                    String sourceFilePath = file.getPath();
//                    System.out.println("Changed Class: " + sourceFilePath);
//                    // Get old and new content of the file
//                    String oldContent = null;
//                    try {
//                        oldContent = getOldFileContent(file);
//                    } catch (IOException e) {
//                        e.printStackTrace();
//                    }
//                    String newContent = getNewFileContent(file);
//                    if (oldContent != null && newContent != null) {
//                        // Parse old and new contents
//                        CompilationUnit oldCompilationUnit = null;
//                        try {
//                            oldCompilationUnit = JavaParser.parse(new ByteArrayInputStream(oldContent.getBytes()));
//                        } catch (ParseException e) {
//                            throw new RuntimeException(e);
//                        }
//                        CompilationUnit newCompilationUnit = null;
//                        try {
//                            newCompilationUnit = JavaParser.parse(new ByteArrayInputStream(newContent.getBytes()));
//                        } catch (ParseException e) {
//                            throw new RuntimeException(e);
//                        }
//
//                        // Compare methods
//                        compareMethods(oldCompilationUnit, newCompilationUnit);
//                    }
//                } else {
//                    System.out.println("File is null");
//                }
//            }
//        }
//    }
//
//    private String getOldFileContent(VirtualFile file) throws IOException {
//        String projectBasePath = project.getBasePath();
//        File repoDir = new File(projectBasePath);
//        String absoluteFilePath = file.getPath();
//        String relativeFilePath = absoluteFilePath.substring(projectBasePath.length() + 1); // Convert to relative path
////        System.out.println("Relative file path: " + relativeFilePath);
//
//        try (Git git = Git.open(repoDir)) {
//            Repository repository = git.getRepository();
//
//            // Get the head commit
//            ObjectId headId = repository.resolve("HEAD");
//            if (headId == null) {
//                throw new IOException("Couldn't resolve HEAD");
//            }
//
//            // Walk the commit history to get the second most recent commit
//            try (RevWalk revWalk = new RevWalk(repository)) {
//                RevCommit headCommit = revWalk.parseCommit(headId);
//                revWalk.markStart(headCommit);
//
//                RevCommit previousCommit = null;
//                int count = 0;
//                for (RevCommit commit : revWalk) {
//                    count++;
//                    if (count == 2) {
//                        previousCommit = commit;
//                        break;
//                    }
//                }
//
//                if (previousCommit == null) {
//                    throw new IOException("No previous commit found");
//                }
//
//                // Get the tree of the previous commit
//                ObjectId treeId = previousCommit.getTree().getId();
//
//                // Find the specified file in the tree
//                try (TreeWalk treeWalk = new TreeWalk(repository)) {
//                    treeWalk.addTree(treeId);
//                    treeWalk.setRecursive(true);
//                    treeWalk.setFilter(PathFilter.create(relativeFilePath));
//
//                    while (treeWalk.next()) {
//                        String path = treeWalk.getPathString();
//                        if (path.equals(relativeFilePath)) {
//                            // Get the file content
//                            ObjectId objectId = treeWalk.getObjectId(0);
//                            try (ObjectReader objectReader = repository.newObjectReader()) {
//                                ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
//                                objectReader.open(objectId).copyTo(outputStream);
//                                return outputStream.toString(StandardCharsets.UTF_8.name());
//                            }
//                        }
//                    }
//
//                    throw new IOException("File not found in the previous commit: " + relativeFilePath);
//                }
//            }
//        }
//    }
//
//    private String getNewFileContent(VirtualFile file) {
//        try {
//            byte[] content = file.contentsToByteArray();
//            return new String(content);
//        } catch (IOException e) {
//            throw new RuntimeException("Error reading new file content", e);
//        }
//    }
//
//    private void compareMethods(CompilationUnit oldCompilationUnit, CompilationUnit newCompilationUnit) {
//        List<MethodDeclaration> oldMethods = new ArrayList<>();
//        List<MethodDeclaration> newMethods = new ArrayList<>();
//        oldCompilationUnit.accept(new MethodVisitor(), oldMethods);
//        newCompilationUnit.accept(new MethodVisitor(), newMethods);
//
//        //Commented out code to print all the methods (New and Old)
////        for (MethodDeclaration m1 : oldMethods) System.out.println(m1.getName());
////        for (MethodDeclaration m2 : newMethods) System.out.println(m2.getName());
//
//        Map<String, MethodDeclaration> oldMethodsMap = new HashMap<>();
//        for (MethodDeclaration method : oldMethods) {
//            oldMethodsMap.put(method.getName(), method);
//        }
//
//        for (MethodDeclaration newMethod : newMethods) {
//            //String methodName = newMethod.getName();
//            if (!oldMethodsMap.containsKey(newMethod.getName())) {
//                System.out.println("Method added: " + newMethod.getName());
//                changes.add(newMethod.getName());
//            } else {
//                MethodDeclaration oldMethod = oldMethodsMap.get(newMethod.getName());
//                if (!oldMethod.getBody().equals(newMethod.getBody())) {
//                    System.out.println("Method changed: " + newMethod.getName());
//                    changes.add(newMethod.getName());
//                }
//                oldMethodsMap.remove(newMethod.getName());
//            }
//        }
//
//        for (String removedMethodName : oldMethodsMap.keySet()) {
//            System.out.println("Method removed: " + removedMethodName);
//            changes.add(removedMethodName);
//        }
//    }
//
//    private static class MethodVisitor extends VoidVisitorAdapter<List<MethodDeclaration>> {
//        @Override
//        public void visit(ClassOrInterfaceDeclaration classOrInterfaceDeclaration, List<MethodDeclaration> collector) {
//            super.visit(classOrInterfaceDeclaration, collector);
//            classOrInterfaceDeclaration.getMembers().forEach(member -> {
//                if (member instanceof MethodDeclaration) {
//                    MethodDeclaration method = (MethodDeclaration) member;
//                    collector.add(method);
//                }
//            });
//        }
//    }
//
//    private void runAffectedTests(Project project, VirtualFile file) {
//        // Placeholder method to run affected tests
//        // Implement logic to determine and run affected tests
//        logger.info("Running affected tests for: " + file.getPath());
//
//        // Example: Execute tests (this part needs implementation based on your testing framework)
//        // For instance, if using JUnit:
//        // TestExecutor.executeTests(file);
//    }
//}



//package com.your.projectroot;
//
//import com.github.javaparser.JavaParser;
//import com.github.javaparser.ast.CompilationUnit;
//import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;
//import com.github.javaparser.ast.body.MethodDeclaration;
//import com.github.javaparser.ast.visitor.VoidVisitorAdapter;
//import com.intellij.openapi.components.Service;
//import com.intellij.openapi.diagnostic.Logger;
//import com.intellij.openapi.project.Project;
//import com.intellij.openapi.vcs.changes.Change;
//import com.intellij.openapi.vcs.changes.ChangeListManager;
//import com.intellij.openapi.vcs.changes.LocalChangeList;
//import com.intellij.openapi.vfs.VirtualFile;
//import com.intellij.psi.PsiElement;
//import com.intellij.psi.PsiMethod;
//import com.intellij.psi.PsiParameter;
//import com.intellij.psi.PsiReference;
//import com.intellij.psi.search.GlobalSearchScope;
//import com.intellij.psi.search.PsiShortNamesCache;
//import com.intellij.psi.search.searches.ReferencesSearch;
//import com.intellij.psi.util.PsiTreeUtil;
//import org.eclipse.jgit.api.Git;
//import org.eclipse.jgit.lib.ObjectId;
//import org.eclipse.jgit.lib.ObjectReader;
//import org.eclipse.jgit.lib.Repository;
//import org.eclipse.jgit.revwalk.RevCommit;
//import org.eclipse.jgit.revwalk.RevWalk;
//import org.eclipse.jgit.treewalk.TreeWalk;
//import org.eclipse.jgit.treewalk.filter.PathFilter;
//
//import java.io.ByteArrayInputStream;
//import java.io.ByteArrayOutputStream;
//import java.io.File;
//import java.io.IOException;
//import java.nio.charset.StandardCharsets;
//import java.util.*;
//
//@Service(Service.Level.PROJECT)
//public final class ChangeTrackingService {
//
//    private static final Logger logger = Logger.getInstance(ChangeTrackingService.class);
//    private final Project project;
//    public static List<String> changes = new ArrayList<>();
//    private final Set<String> affectedMethods = new HashSet<>();
//
//    public ChangeTrackingService(Project project) {
//        this.project = project;
//    }
//
//    public void trackChangesAndRunTests(int maxDepth) {
//        System.out.println("Beginning: " + maxDepth);
//        ChangeListManager changeListManager = ChangeListManager.getInstance(project);
//
//        // Get the list of local changes
//        List<LocalChangeList> changes = changeListManager.getChangeLists();
//
//        // Iterate over changes and process them
//        for (LocalChangeList changeList : changes) {
//            for (Change change : changeList.getChanges()) {
//                VirtualFile file = change.getVirtualFile();
//
//                if (file != null) {
//                    // Process each changed file to determine affected unit tests
//                    String sourceFilePath = file.getPath();
//                    System.out.println("Changed Class: " + sourceFilePath);
//                    // Get old and new content of the file
//                    String oldContent = null;
//                    try {
//                        oldContent = getOldFileContent(file);
//                    } catch (IOException e) {
//                        e.printStackTrace();
//                    }
//                    String newContent = getNewFileContent(file);
//                    if (oldContent != null && newContent != null) {
//                        // Parse old and new contents
//                        JavaParser parser = new JavaParser();
//                        CompilationUnit oldCompilationUnit;
//                        oldCompilationUnit = parser.parse(new ByteArrayInputStream(oldContent.getBytes())).getResult().orElse(null);
//                        CompilationUnit newCompilationUnit;
//                        newCompilationUnit = parser.parse(new ByteArrayInputStream(newContent.getBytes())).getResult().orElse(null);
//
//                        // Compare methods
//                        compareMethods(oldCompilationUnit, newCompilationUnit);
//                    }
//                } else {
//                    System.out.println("File is null");
//                }
//            }
//        }
//        identifyAffectedMethods();
//        runAssociatedTests(maxDepth);
//    }
//
//    private String getOldFileContent(VirtualFile file) throws IOException {
//        String projectBasePath = project.getBasePath();
//        File repoDir = new File(projectBasePath);
//        String absoluteFilePath = file.getPath();
//        String relativeFilePath = absoluteFilePath.substring(projectBasePath.length() + 1); // Convert to relative path
//
//        try (Git git = Git.open(repoDir)) {
//            Repository repository = git.getRepository();
//
//            // Get the head commit
//            ObjectId headId = repository.resolve("HEAD");
//            if (headId == null) {
//                throw new IOException("Couldn't resolve HEAD");
//            }
//
//            // Get the tree of the head commit
//            try (RevWalk revWalk = new RevWalk(repository)) {
//                RevCommit headCommit = revWalk.parseCommit(headId);
//                ObjectId treeId = headCommit.getTree().getId();
//
//                // Find the specified file in the tree
//                try (TreeWalk treeWalk = new TreeWalk(repository)) {
//                    treeWalk.addTree(treeId);
//                    treeWalk.setRecursive(true);
//                    treeWalk.setFilter(PathFilter.create(relativeFilePath));
//
//                    while (treeWalk.next()) {
//                        String path = treeWalk.getPathString();
//                        if (path.equals(relativeFilePath)) {
//                            // Get the file content
//                            ObjectId objectId = treeWalk.getObjectId(0);
//                            try (ObjectReader objectReader = repository.newObjectReader()) {
//                                ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
//                                objectReader.open(objectId).copyTo(outputStream);
//                                return outputStream.toString(StandardCharsets.UTF_8.name());
//                            }
//                        }
//                    }
//
//                    throw new IOException("File not found in the HEAD commit: " + relativeFilePath);
//                }
//            }
//        }
//    }
//
//    private String getNewFileContent(VirtualFile file) {
//        try {
//            byte[] content = file.contentsToByteArray();
//            return new String(content);
//        } catch (IOException e) {
//            throw new RuntimeException("Error reading new file content", e);
//        }
//    }
//
//    private void compareMethods(CompilationUnit oldCompilationUnit, CompilationUnit newCompilationUnit) {
//        List<MethodDeclaration> oldMethods = new ArrayList<>();
//        List<MethodDeclaration> newMethods = new ArrayList<>();
//        oldCompilationUnit.accept(new MethodVisitor(), oldMethods);
//        newCompilationUnit.accept(new MethodVisitor(), newMethods);
//
//        Map<String, MethodDeclaration> oldMethodsMap = new HashMap<>();
//        for (MethodDeclaration method : oldMethods) {
//            oldMethodsMap.put(getMethodSignature(method), method);
//        }
//
//        for (MethodDeclaration newMethod : newMethods) {
//            String newMethodSignature = getMethodSignature(newMethod);
//            if (!oldMethodsMap.containsKey(newMethodSignature)) {
//                System.out.println("Method added: " + newMethod.getName());
//                changes.add(newMethodSignature);
//            } else {
//                MethodDeclaration oldMethod = oldMethodsMap.get(newMethodSignature);
//                if (!oldMethod.getBody().equals(newMethod.getBody())) {
//                    System.out.println("Method changed: " + newMethod.getName());
//                    changes.add(newMethodSignature);
//                }
//                oldMethodsMap.remove(newMethodSignature);
//            }
//        }
//
//        for (String removedMethodName : oldMethodsMap.keySet()) {
//            System.out.println("Method removed: " + removedMethodName);
//            changes.add(removedMethodName);
//        }
//    }
//
//    private void identifyAffectedMethods() {
//        Set<String> visited = new HashSet<>();
//        Queue<String> queue = new LinkedList<>(changes);
//        while (!queue.isEmpty()) {
//            String method = queue.poll();
//            if (!visited.contains(method)) {
//                visited.add(method);
//                affectedMethods.add(method);
//            }
//        }
//        for (String i : affectedMethods) {
//            System.out.println(i);
//        }
//    }
//
//    private void runAssociatedTests(int maxDepth) {
//        Set<PsiMethod> psiMethods = new HashSet<>();
//        for (String methodSignature : affectedMethods) {
//            psiMethods.add(findPsiMethod(methodSignature));
//        }
//
//        TestMethodFinder testMethodFinder = new TestMethodFinder(project);
//        Set<PsiMethod> testMethods = testMethodFinder.findAssociatedTestMethods(psiMethods);
//
//        TestRunner testRunner = new TestRunner(project);
//        testRunner.runTestMethods(testMethods);
//    }
//
//    private PsiMethod findPsiMethod(String methodSignature) {
//        GlobalSearchScope scope = GlobalSearchScope.projectScope(project);
//        PsiShortNamesCache shortNamesCache = PsiShortNamesCache.getInstance(project);
//        String methodName = extractMethodName(methodSignature);
//        String[] parameterTypes = extractParameterTypes(methodSignature);
//        PsiMethod[] methods = shortNamesCache.getMethodsByName(methodName, scope);
//
//        for (PsiMethod method : methods) {
//            if (isMatchingParameters(method, parameterTypes)) {
//                return method;
//            }
//        }
//        return null;
//    }
//
//    private String getMethodSignature(MethodDeclaration method) {
//        StringBuilder signatureBuilder = new StringBuilder();
//        signatureBuilder.append(method.getName()).append('(');
//        List<com.github.javaparser.ast.body.Parameter> parameters = method.getParameters();
//        for (int i = 0; i < parameters.size(); i++) {
//            signatureBuilder.append(parameters.get(i).getType());
//            if (i < parameters.size() - 1) {
//                signatureBuilder.append(", ");
//            }
//        }
//        signatureBuilder.append(')');
//        return signatureBuilder.toString();
//    }
//
//    private String getMethodSignature(PsiMethod method) {
//        StringBuilder signatureBuilder = new StringBuilder();
//        signatureBuilder.append(method.getName()).append('(');
//        PsiParameter[] parameters = method.getParameterList().getParameters();
//        for (int i = 0; i < parameters.length; i++) {
//            signatureBuilder.append(parameters[i].getType().getPresentableText());
//            if (i < parameters.length - 1) {
//                signatureBuilder.append(", ");
//            }
//        }
//        signatureBuilder.append(')');
//        return signatureBuilder.toString();
//    }
//
//    private String extractMethodName(String methodSignature) {
//        int startIndex = methodSignature.indexOf('(');
//        if (startIndex != -1) {
//            return methodSignature.substring(0, startIndex);
//        }
//        return methodSignature; // Fallback to the whole signature if parsing fails
//    }
//
//    private String[] extractParameterTypes(String methodSignature) {
//        // Assuming the format "methodName(parameters)"
//        int startIndex = methodSignature.indexOf('(');
//        int endIndex = methodSignature.indexOf(')');
//        if (startIndex != -1 && endIndex != -1) {
//            String params = methodSignature.substring(startIndex + 1, endIndex);
//            return params.isEmpty() ? new String[0] : params.split(",\\s*");
//        }
//        return new String[0]; // Fallback to no parameters if parsing fails
//    }
//
//    private boolean isMatchingParameters(PsiMethod method, String[] parameterTypes) {
//        PsiParameter[] parameters = method.getParameterList().getParameters();
//        if (parameters.length != parameterTypes.length) {
//            return false;
//        }
//        for (int i = 0; i < parameters.length; i++) {
//            if (!parameters[i].getType().getPresentableText().equals(parameterTypes[i])) {
//                return false;
//            }
//        }
//        return true;
//    }
//
//    private static class MethodVisitor extends VoidVisitorAdapter<List<MethodDeclaration>> {
//        @Override
//        public void visit(ClassOrInterfaceDeclaration classOrInterfaceDeclaration, List<MethodDeclaration> collector) {
//            super.visit(classOrInterfaceDeclaration, collector);
//            classOrInterfaceDeclaration.getMembers().forEach(member -> {
//                if (member instanceof MethodDeclaration) {
//                    MethodDeclaration method = (MethodDeclaration) member;
//                    collector.add(method);
//                }
//            });
//        }
//    }
//
//    private void runAffectedTests(Project project, VirtualFile file) {
//        // Placeholder method to run affected tests
//        // Implement logic to determine and run affected tests
//        logger.info("Running affected tests for: " + file.getPath());
//
//        // Example: Execute tests (this part needs implementation based on your testing framework)
//        // For instance, if using JUnit:
//        // TestExecutor.executeTests(file);
//    }
//}



//package com.your.projectroot;
//
//import com.github.javaparser.JavaParser;
//import com.github.javaparser.ast.CompilationUnit;
//import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;
//import com.github.javaparser.ast.body.MethodDeclaration;
//import com.github.javaparser.ast.visitor.VoidVisitorAdapter;
//import com.intellij.openapi.components.Service;
//import com.intellij.openapi.diagnostic.Logger;
//import com.intellij.openapi.project.Project;
//import com.intellij.openapi.vcs.changes.Change;
//import com.intellij.openapi.vcs.changes.ChangeListManager;
//import com.intellij.openapi.vcs.changes.LocalChangeList;
//import com.intellij.openapi.vfs.VirtualFile;
//import com.intellij.psi.*;
//import com.intellij.psi.search.GlobalSearchScope;
//import com.intellij.psi.search.PsiShortNamesCache;
//import com.intellij.psi.search.searches.ReferencesSearch;
//import com.intellij.psi.util.PsiTreeUtil;
//import org.eclipse.jgit.api.Git;
//import org.eclipse.jgit.lib.ObjectId;
//import org.eclipse.jgit.lib.ObjectReader;
//import org.eclipse.jgit.lib.Repository;
//import org.eclipse.jgit.revwalk.RevCommit;
//import org.eclipse.jgit.revwalk.RevWalk;
//import org.eclipse.jgit.treewalk.TreeWalk;
//import org.eclipse.jgit.treewalk.filter.PathFilter;
//
//import java.io.ByteArrayInputStream;
//import java.io.ByteArrayOutputStream;
//import java.io.File;
//import java.io.IOException;
//import java.nio.charset.StandardCharsets;
//import java.util.*;
//
//@Service(Service.Level.PROJECT)
//public final class ChangeTrackingService {
//
//    private static final Logger logger = Logger.getInstance(ChangeTrackingService.class);
//    private final Project project;
//    public static List<String> changes = new ArrayList<>();
//    private final Set<String> affectedMethods = new HashSet<>();
//
//    public ChangeTrackingService(Project project) {
//        this.project = project;
//    }
//
//    public void trackChangesAndRunTests(int maxDepth) {
//        System.out.println("Beginning: ");
//        ChangeListManager changeListManager = ChangeListManager.getInstance(project);
//
//        // Get the list of local changes
//        List<LocalChangeList> changes = changeListManager.getChangeLists();
//
//        // Iterate over changes and process them
//        for (LocalChangeList changeList : changes) {
//            for (Change change : changeList.getChanges()) {
//                VirtualFile file = change.getVirtualFile();
//
//                if (file != null) {
//                    // Process each changed file to determine affected unit tests
//                    String sourceFilePath = file.getPath();
//                    System.out.println("Changed Class: " + sourceFilePath);
//                    // Get old and new content of the file
//                    String oldContent = null;
//                    try {
//                        oldContent = getOldFileContent(file);
//                    } catch (IOException e) {
//                        e.printStackTrace();
//                    }
//                    String newContent = getNewFileContent(file);
//                    if (oldContent != null && newContent != null) {
//                        // Parse old and new contents
//                        JavaParser parser = new JavaParser();
//                        CompilationUnit oldCompilationUnit;
//                        oldCompilationUnit = parser.parse(new ByteArrayInputStream(oldContent.getBytes())).getResult().orElse(null);
//                        CompilationUnit newCompilationUnit;
//                        newCompilationUnit = parser.parse(new ByteArrayInputStream(newContent.getBytes())).getResult().orElse(null);
//
//                        // Compare methods
//                        compareMethods(oldCompilationUnit, newCompilationUnit);
//                    }
//                } else {
//                    System.out.println("File is null");
//                }
//            }
//        }
//        identifyAffectedMethods(maxDepth);
//        printAffectedMethods();
//    }
//
//    private void identifyAffectedMethods(int maxDepth) {
//        Set<String> visitedMethods = new HashSet<>();
//        Queue<String> methodQueue = new LinkedList<>(changes);
//
//        while (!methodQueue.isEmpty()) {
//            String methodSignature = methodQueue.poll();
//            if (!visitedMethods.contains(methodSignature)) {
//                visitedMethods.add(methodSignature);
//                affectedMethods.add(methodSignature);
//                performDFSTraversal(methodSignature, maxDepth, 0, visitedMethods);
//            }
//        }
//    }
//
//    private void performDFSTraversal(String methodSignature, int maxDepth, int currentDepth, Set<String> visitedMethods) {
//        if (currentDepth > maxDepth) {
//            return;
//        }
//
//        GlobalSearchScope scope = GlobalSearchScope.projectScope(project);
//        PsiShortNamesCache shortNamesCache = PsiShortNamesCache.getInstance(project);
//        String methodName = extractMethodName(methodSignature);
//        String[] parameterTypes = extractParameterTypes(methodSignature);
//        PsiMethod[] methods = shortNamesCache.getMethodsByName(methodName, scope);
//
//        for (PsiMethod method : methods) {
//            if (isMatchingParameters(method, parameterTypes)) {
//                Collection<PsiReference> references = ReferencesSearch.search(method, scope).findAll();
//                for (PsiReference reference : references) {
//                    System.out.println("Method " + methodName + " is used in: " + reference.getElement().getContainingFile().getVirtualFile().getPath());
//
//                    PsiElement element = reference.getElement();
//                    PsiMethod containingMethod = PsiTreeUtil.getParentOfType(element, PsiMethod.class);
//                    if (containingMethod != null) {
//                        String containingMethodSignature = getMethodSignature(containingMethod);
//                        if (!visitedMethods.contains(containingMethodSignature)) {
//                            visitedMethods.add(containingMethodSignature);
//                            performDFSTraversal(containingMethodSignature, maxDepth, currentDepth + 1, visitedMethods);
//                        }
//                    }
//                }
//            }
//        }
//    }
//
//    private void printAffectedMethods() {
//        for (String method : affectedMethods) {
//            System.out.println(method);
//        }
//    }
//
//    private String getOldFileContent(VirtualFile file) throws IOException {
//        String projectBasePath = project.getBasePath();
//        File repoDir = new File(projectBasePath);
//        String absoluteFilePath = file.getPath();
//        String relativeFilePath = absoluteFilePath.substring(projectBasePath.length() + 1); // Convert to relative path
//
//        try (Git git = Git.open(repoDir)) {
//            Repository repository = git.getRepository();
//            ObjectId headId = repository.resolve("HEAD");
//            if (headId == null) {
//                throw new IOException("Couldn't resolve HEAD");
//            }
//
//            try (RevWalk revWalk = new RevWalk(repository)) {
//                RevCommit headCommit = revWalk.parseCommit(headId);
//                revWalk.markStart(headCommit);
//
//                RevCommit previousCommit = null;
//                int count = 0;
//                for (RevCommit commit : revWalk) {
//                    count++;
//                    if (count == 2) {
//                        previousCommit = commit;
//                        break;
//                    }
//                }
//
//                if (previousCommit == null) {
//                    throw new IOException("No previous commit found");
//                }
//
//                ObjectId treeId = previousCommit.getTree().getId();
//                try (TreeWalk treeWalk = new TreeWalk(repository)) {
//                    treeWalk.addTree(treeId);
//                    treeWalk.setRecursive(true);
//                    treeWalk.setFilter(PathFilter.create(relativeFilePath));
//
//                    while (treeWalk.next()) {
//                        if (treeWalk.getPathString().equals(relativeFilePath)) {
//                            ObjectId objectId = treeWalk.getObjectId(0);
//                            try (ObjectReader objectReader = repository.newObjectReader()) {
//                                ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
//                                objectReader.open(objectId).copyTo(outputStream);
//                                return outputStream.toString(StandardCharsets.UTF_8.name());
//                            }
//                        }
//                    }
//                }
//            }
//        }
//        return null;
//    }
//
//    private String getNewFileContent(VirtualFile file) {
//        try {
//            byte[] content = file.contentsToByteArray();
//            return new String(content);
//        } catch (IOException e) {
//            throw new RuntimeException("Error reading new file content", e);
//        }
//    }
//
//    private void compareMethods(CompilationUnit oldCompilationUnit, CompilationUnit newCompilationUnit) {
//        List<MethodDeclaration> oldMethods = new ArrayList<>();
//        List<MethodDeclaration> newMethods = new ArrayList<>();
//        oldCompilationUnit.accept(new MethodVisitor(), oldMethods);
//        newCompilationUnit.accept(new MethodVisitor(), newMethods);
//
//        Map<String, MethodDeclaration> oldMethodsMap = new HashMap<>();
//        for (MethodDeclaration method : oldMethods) {
//            oldMethodsMap.put(method.getName().asString(), method);
//        }
//
//        for (MethodDeclaration newMethod : newMethods) {
//            if (!oldMethodsMap.containsKey(newMethod.getName().asString())) {
//                System.out.println("Method added: " + newMethod.getName());
//                changes.add(newMethod.getSignature().asString());
//            } else {
//                MethodDeclaration oldMethod = oldMethodsMap.get(newMethod.getName().asString());
//                if (!oldMethod.getBody().equals(newMethod.getBody())) {
//                    System.out.println("Method changed: " + newMethod.getName().asString());
//                    changes.add(newMethod.getSignature().asString());
//                }
//                oldMethodsMap.remove(newMethod.getName().asString());
//            }
//        }
//
//        for (String removedMethodName : oldMethodsMap.keySet()) {
//            System.out.println("Method removed: " + removedMethodName);
//            changes.add(oldMethodsMap.get(removedMethodName).getSignature().asString());
//        }
//    }
//
//    private String getMethodSignature(PsiMethod method) {
//        StringBuilder signatureBuilder = new StringBuilder();
//        signatureBuilder.append(method.getName()).append('(');
//        PsiParameter[] parameters = method.getParameterList().getParameters();
//        for (int i = 0; i < parameters.length; i++) {
//            signatureBuilder.append(parameters[i].getType().getPresentableText());
//            if (i < parameters.length - 1) {
//                signatureBuilder.append(", ");
//            }
//        }
//        signatureBuilder.append(')');
//        return signatureBuilder.toString();
//    }
//
//    private String extractMethodName(String methodSignature) {
//        int startIndex = methodSignature.indexOf('(');
//        if (startIndex != -1) {
//            return methodSignature.substring(0, startIndex);
//        }
//        return methodSignature;
//    }
//
//    private String[] extractParameterTypes(String methodSignature) {
//        int startIndex = methodSignature.indexOf('(');
//        int endIndex = methodSignature.indexOf(')');
//        if (startIndex != -1 && endIndex != -1) {
//            String params = methodSignature.substring(startIndex + 1, endIndex);
//            return params.isEmpty() ? new String[0] : params.split(",\\s*");
//        }
//        return new String[0];
//    }
//
//    private boolean isMatchingParameters(PsiMethod method, String[] parameterTypes) {
//        PsiParameter[] parameters = method.getParameterList().getParameters();
//        if (parameters.length != parameterTypes.length) {
//            return false;
//        }
//        for (int i = 0; i < parameters.length; i++) {
//            if (!parameters[i].getType().getPresentableText().equals(parameterTypes[i])) {
//                return false;
//            }
//        }
//        return true;
//    }
//
//    private static class MethodVisitor extends VoidVisitorAdapter<List<MethodDeclaration>> {
//        @Override
//        public void visit(ClassOrInterfaceDeclaration classOrInterfaceDeclaration, List<MethodDeclaration> collector) {
//            super.visit(classOrInterfaceDeclaration, collector);
//            classOrInterfaceDeclaration.getMembers().forEach(member -> {
//                if (member instanceof MethodDeclaration) {
//                    MethodDeclaration method = (MethodDeclaration) member;
//                    collector.add(method);
//                }
//            });
//        }
//    }
//}


//plugins {
//    id("java")
//    id("org.jetbrains.intellij") version "1.17.3"
//}
//
//group = "com.your"
//version = "1.0-SNAPSHOT"
//
//repositories {
//    mavenCentral()
//}
//
//dependencies {
//    implementation("org.jetbrains:annotations:24.0.1")
//    testImplementation("org.junit.jupiter:junit-jupiter-api:5.7.1")
//    testRuntimeOnly("org.junit.jupiter:junit-jupiter-engine:5.7.1")
//}
//
//intellij {
//    version.set("2023.1")
//    plugins.set(listOf("java"))
//}
//
//tasks.withType<JavaCompile> {
//    options.encoding = "UTF-8"
//}
//
//tasks.test {
//    useJUnitPlatform()
//}
//
//tasks.named("buildSearchableOptions").configure {
//    enabled = false
//}
//
//tasks {
//    runIde {
//        jvmArgs("-Xmx1024m")
//    }
//}




//plugins {
//    id("java")
//    id("org.jetbrains.intellij") version "1.17.3"
//}
//
//group = "com.your"
//version = "1.0-SNAPSHOT"
//
//repositories {
//    mavenCentral()
//    maven {
//        url = uri("https://jitpack.io")
//    }
//}
//
//dependencies{
//    implementation ("com.github.javaparser:javaparser-core:3.25.10")
//}
//
//intellij {
//    version.set("2023.2.6")
//    type.set("IC") // Target IDE Platform
//
//    plugins.set(listOf("java"))
//}
//
//tasks {
//    // Set the JVM compatibility versions
//    withType<JavaCompile> {
//        sourceCompatibility = "17"
//        targetCompatibility = "17"
//    }
//
//    patchPluginXml {
//        sinceBuild.set("232")
//        untilBuild.set("242.*")
//    }
//
//    signPlugin {
//        certificateChain.set(System.getenv("CERTIFICATE_CHAIN"))
//        privateKey.set(System.getenv("PRIVATE_KEY"))
//        password.set(System.getenv("PRIVATE_KEY_PASSWORD"))
//    }
//
//    publishPlugin {
//        token.set(System.getenv("PUBLISH_TOKEN"))
//    }
//}



Signature Method -
private String getMethodSignature(MethodDeclaration method) {
        StringBuilder signatureBuilder = new StringBuilder();
        signatureBuilder.append(method.getName()).append('(');
        List<Parameter> parameters = method.getParameters();
        for (int i = 0; i < parameters.size(); i++) {
            signatureBuilder.append(parameters.get(i).getType());
            if (i < parameters.size() - 1) {
                signatureBuilder.append(", ");
            }
        }
        signatureBuilder.append(')');
        return signatureBuilder.toString();
    }



Code for Invoke -
//        Set<PsiMethod> testMethodsUsingPrivateMethods = new HashSet<>();
//        PsiSearchHelper searchHelper = PsiSearchHelper.getInstance(project);
//        GlobalSearchScope searchScope = GlobalSearchScope.projectScope(project);
//
//        searchHelper.processAllFilesWithWord("@Test", searchScope, psifile -> {
//            System.out.println(psifile);
//            psifile.accept(new JavaRecursiveElementVisitor() {
//                @Override
//                public void visitMethod(@NotNull PsiMethod method) {
//                    super.visitMethod(method);
//                    if (CustomUtil.isTestMethod(method) &&
//                            usesReflectionToAccessPrivateMethods(method) &&
//                            checkForPrivateMethod(method, privateMethods)) {
//                        testMethodsUsingPrivateMethods.add(method);
//                    }
//                }
//            });
//            return true;
//        },true);
//
//        return testMethodsUsingPrivateMethods;



private static boolean usesReflectionToAccessPrivateMethods(PsiMethod method, Set<PsiMethod> privateMethods) {
        Set<String> privateMethodNames = new HashSet<>();
        for (PsiMethod privateMethod : privateMethods) {
            privateMethodNames.add(privateMethod.getName());
        }

        final boolean[] usesReflection = {false};

        method.accept(new JavaRecursiveElementWalkingVisitor() {
            @Override
            public void visitMethodCallExpression(@NotNull PsiMethodCallExpression expression) {

                super.visitMethodCallExpression(expression);
                PsiMethod resolvedMethod = expression.resolveMethod();
                if (resolvedMethod != null) {
                    String methodName = resolvedMethod.getName();
                    if ("invoke".equals(methodName)) {
                        System.out.println("here1");
                        // Check if the method being invoked is among the private methods
                        PsiExpression[] arguments = expression.getArgumentList().getExpressions();
                        if (arguments.length > 0 && arguments[0] instanceof PsiReferenceExpression refExpression) {
                            PsiElement resolvedElement = refExpression.resolve();
                            if (resolvedElement instanceof PsiVariable variable) {
                                PsiElement initializer = variable.getInitializer();
                                PsiMethodCallExpression callExpression = PsiTreeUtil.getChildOfType(initializer, PsiMethodCallExpression.class);
                                PsiMethod calledMethod = callExpression != null ? callExpression.resolveMethod() : null;
                                String calledMethodName = calledMethod != null ? calledMethod.getName() : null;
                                if (privateMethodNames.contains(calledMethodName)) {
                                    usesReflection[0] = true;
                                }
                            }
                        }
                    }
                    else if ("setAccessible".equals(methodName)) {
                        System.out.println("here2");
                        PsiExpression[] arguments = expression.getArgumentList().getExpressions();
                        if (arguments.length == 1 && arguments[0] instanceof PsiLiteralExpression literalExpression) {
                            Object value = literalExpression.getValue();
                            if (value instanceof Boolean) {
                                usesReflection[0] = true;
                            }
                        }
                    }
                }
            }
        });

        System.out.println(usesReflection[0]);
        return usesReflection[0];
    }




IMPORTANT!!!!Code For Reflection -

//package com.your.projectroot;
//
//import com.intellij.openapi.project.Project;
//import com.intellij.psi.*;
//import com.intellij.psi.search.GlobalSearchScope;
//import com.intellij.psi.search.PsiSearchHelper;
//import org.jetbrains.annotations.NotNull;
//
//import java.util.HashMap;
//import java.util.HashSet;
//import java.util.Set;
//
//public class PrivateMethodUsageFinder {
//
//    public static Set<PsiMethod> findPrivateMethodUsages(Project project,Set<PsiMethod> privateMethods) {
////        Set<PsiMethod> testMethodsUsingPrivateMethods = new HashSet<>();
////        GlobalSearchScope searchScope = GlobalSearchScope.projectScope(project);
////
////        PsiClass testAnnotation = JavaPsiFacade.getInstance(project).findClass("org.junit.jupiter.api.Test", GlobalSearchScope.allScope(project));
////
////        if (testAnnotation == null) {
////            return testMethodsUsingPrivateMethods; // No @Test annotation found in the project
////        }
////
////        AnnotatedElementsSearch.searchPsiMethods(testAnnotation, searchScope).forEach(method -> {
////
////            if (usesReflectionToAccessPrivateMethods(method) && checkForPrivateMethod(method, privateMethods)) {
////                System.out.println(method);
////                System.out.println(testAnnotation);
////                testMethodsUsingPrivateMethods.add(method);
////            }
////            return true;
////        });
////
////        return testMethodsUsingPrivateMethods;
//
//        Set<PsiMethod> testMethodsUsingPrivateMethods = new HashSet<>();
//        PsiSearchHelper searchHelper = PsiSearchHelper.getInstance(project);
//        GlobalSearchScope searchScope = GlobalSearchScope.projectScope(project);
//
//        Set<String> privateMethodNames = new HashSet<>();
//        for (PsiMethod privateMethod : privateMethods) {
//            privateMethodNames.add(privateMethod.getName());
//        }
//
//        for (String methodName : privateMethodNames) {
//            searchHelper.processAllFilesWithWord(methodName, searchScope, psifile -> {
//                System.out.println(psifile+methodName);
//                psifile.accept(new JavaRecursiveElementVisitor() {
//                    @Override
//                    public void visitMethod(@NotNull PsiMethod method) {
//                        super.visitMethod(method);
//                        System.out.println("Here1");
//                        if (CustomUtil.isTestMethod(method) &&
//                                usesReflectionToAccessPrivateMethods(method) &&
//                                checkForPrivateMethod(method, privateMethods)) {
//                            testMethodsUsingPrivateMethods.add(method);
//                        }
//                    }
//                });
//                return true;
//            }, true);
//        }
//
//        return testMethodsUsingPrivateMethods;
//    }
//
//    private static boolean usesReflectionToAccessPrivateMethods(PsiMethod method) {
//        final boolean[] usesReflection = {false};
//
//        method.accept(new JavaRecursiveElementWalkingVisitor() {
//            @Override
//            public void visitMethodCallExpression(@NotNull PsiMethodCallExpression expression) {
//                super.visitMethodCallExpression(expression);
//                PsiMethod resolvedMethod = expression.resolveMethod();
//                String methodName = resolvedMethod != null ? resolvedMethod.getName() : null;
//                if ("setAccessible".equals(methodName)) {
//                    PsiExpression[] arguments = expression.getArgumentList().getExpressions();
//                    if (arguments.length == 1 && arguments[0] instanceof PsiLiteralExpression literalExpression) {
//                        Object value = literalExpression.getValue();
//                        if (value instanceof Boolean) {
//                            usesReflection[0]=true;
//                        }
//                    }
//                }
//                else if("getDeclaredMethod".equals(methodName)){
//                    PsiExpression[] arguments = expression.getArgumentList().getExpressions();
//                    if (arguments.length == 1 && arguments[0] instanceof PsiLiteralExpression literalExpression) {
//                        Object value = literalExpression.getValue();
//                        if (value instanceof String) {
//                            usesReflection[0]=true;
//                        }
//                    }
//                }
//                else if("getDeclaredMethods".equals(methodName)){
//                    PsiExpression[] arguments = expression.getArgumentList().getExpressions();
//                    if (arguments.length == 0) {
//                        usesReflection[0]=true;
//                    }
//                }
//            }
//        });
//
//        return usesReflection[0];
//    }
//
//    private static boolean checkForPrivateMethod(PsiMethod method, Set<PsiMethod> privateMethods) {
//        HashMap<PsiMethod,String> privateMethodNames = new HashMap<>();
//        for (PsiMethod privateMethod : privateMethods) {
//            privateMethodNames.put(privateMethod,privateMethod.getName());
//        }
//        final boolean[] usesMethod = {false};
//
//        method.accept(new JavaRecursiveElementWalkingVisitor() {
//            @Override
//            public void visitMethodCallExpression(@NotNull PsiMethodCallExpression expression) {
//                super.visitMethodCallExpression(expression);
//                PsiMethod resolvedMethod = expression.resolveMethod();
//                String methodName = resolvedMethod != null ? resolvedMethod.getName() : null;
//                if("equals".equals(methodName)){
//                    PsiExpression[] arguments = expression.getArgumentList().getExpressions();
//                    if(arguments[0].textContains('"')){
//                        String privateMethod = CustomUtil.getCallingMethodName(arguments[0].getText());
//                        if(privateMethodNames.containsValue(privateMethod)){
//                            usesMethod[0] = true;
//                        }
//                    }
//                    else{
//                        String qualifiedName = expression.getMethodExpression().getQualifiedName();
//                        String privateMethod = CustomUtil.getCallingMethodName(qualifiedName);
//                        if(privateMethodNames.containsValue(privateMethod)){
//                            usesMethod[0] = true;
//                        }
//                    }
//                }else if("getDeclaredMethod".equals(methodName)){
//                    PsiExpression[] arguments = expression.getArgumentList().getExpressions();
//                    String privateMethod = CustomUtil.getCallingMethodName(arguments[0].getText());
//                    if(privateMethodNames.containsValue(privateMethod)){
//                        usesMethod[0] = true;
//                    }
//                }
//            }
//        });
//        return usesMethod[0];
//    }
//}

//package com.your.projectroot;
//
//import com.intellij.openapi.project.Project;
//import com.intellij.psi.*;
//import com.intellij.psi.search.GlobalSearchScope;
//import com.intellij.psi.search.PsiSearchHelper;
//import com.intellij.psi.search.TextOccurenceProcessor;
//import com.intellij.psi.search.UsageSearchContext;
//import org.jetbrains.annotations.NotNull;
//
//import java.util.HashMap;
//import java.util.HashSet;
//import java.util.Set;

//public class PrivateMethodUsageFinder {
//
//    public static Set<PsiMethod> findPrivateMethodUsages(Project project, Set<PsiMethod> privateMethods) {
//        Set<PsiMethod> testMethodsUsingPrivateMethods = new HashSet<>();
//        PsiSearchHelper searchHelper = PsiSearchHelper.getInstance(project);
//        GlobalSearchScope searchScope = GlobalSearchScope.projectScope(project);
//
//        HashMap<String,PsiMethod> privateMethodNames = new HashMap<>();
//        for (PsiMethod privateMethod : privateMethods) {
//            privateMethodNames.put(privateMethod.getName(),privateMethod);
//        }
//
//        for (String methodName : privateMethodNames.keySet()) {
//            //searchHelper.processAllFilesWithWordInLiterals(methodName, searchScope, psifile -> {
//                //GlobalSearchScope newScope = GlobalSearchScope.fileScope(psifile);
////                psifile.accept(new JavaRecursiveElementVisitor() {
////                    @Override
////                    public void visitMethod(@NotNull PsiMethod method) {
////                        super.visitMethod(method);
////                        if (CustomUtil.isTestMethod(method)) {
////                            if (usesReflectionToAccessPrivateMethods(method)) {
////                                if (checkForPrivateMethod(method, privateMethods)) {
////                                    testMethodsUsingPrivateMethods.add(method);
////                                }
////                            }
////                        }
////                    }
////                });
//                //GlobalSearchScope scope = GlobalSearchScope.fileScope(psifile);
//                TextOccurenceProcessor processor = (element, offsetInElement) -> {
//
//                    if (element.getText().contains(methodName)) {
//                        PsiElement parent = element.getParent();
//                        if (parent instanceof PsiMethod psiMethod && CustomUtil.isTestMethod(psiMethod)) {
//                            System.out.println("Found string '" + methodName + "' in method: " + psiMethod.getName() +
//                                        " in file: " + psiMethod.getContainingFile().getName() + " at offset: " + element.getTextRange().getStartOffset());
//                            testMethodsUsingPrivateMethods.add(psiMethod);
//                        } else {
//                            System.out.println("Found string '" + methodName + "' in file: " +
//                                    element.getContainingFile().getName() + " at offset: " + element.getTextRange().getStartOffset());
//                        }
//                    }
//                    return true; // Continue searching
//                };
//
//                searchHelper.processElementsWithWord(processor, searchScope, methodName, UsageSearchContext.IN_STRINGS, true);
//                //return true;
//            //});
//        }
//
//        return testMethodsUsingPrivateMethods;
//    }

//    private static boolean usesReflectionToAccessPrivateMethods(PsiMethod method) {
//        final boolean[] usesReflection = {false};
//
//        method.accept(new JavaRecursiveElementWalkingVisitor() {
//            @Override
//            public void visitMethodCallExpression(@NotNull PsiMethodCallExpression expression) {
//                super.visitMethodCallExpression(expression);
//                PsiMethod resolvedMethod = expression.resolveMethod();
//                String methodName = resolvedMethod != null ? resolvedMethod.getName() : null;
//                if ("setAccessible".equals(methodName) || "getDeclaredMethod".equals(methodName) || "getDeclaredMethods".equals(methodName)) {
//                    usesReflection[0] = true;
//                }
//            }
//        });
//
//        System.out.println("Method " + method.getName() + " uses reflection: " + usesReflection[0]);
//        return usesReflection[0];
//    }
//
//    private static boolean checkForPrivateMethod(PsiMethod method, Set<PsiMethod> privateMethods) {
//        HashMap<PsiMethod,String> privateMethodNames = new HashMap<>();
//        for (PsiMethod privateMethod : privateMethods) {
//            privateMethodNames.put(privateMethod,privateMethod.getName());
//        }
//        final boolean[] usesMethod = {false};
//
//        method.accept(new JavaRecursiveElementWalkingVisitor() {
//            @Override
//            public void visitMethodCallExpression(@NotNull PsiMethodCallExpression expression) {
//                super.visitMethodCallExpression(expression);
//                PsiMethod resolvedMethod = expression.resolveMethod();
//                String methodName = resolvedMethod != null ? resolvedMethod.getName() : null;
//                if("equals".equals(methodName)){
//                    PsiExpression[] arguments = expression.getArgumentList().getExpressions();
//                    if(arguments[0].textContains('"')){
//                        String privateMethod = CustomUtil.getCallingMethodName(arguments[0].getText());
//                        if(privateMethodNames.containsValue(privateMethod)){
//                            usesMethod[0] = true;
//                        }
//                    }
//                    else{
//                        String qualifiedName = expression.getMethodExpression().getQualifiedName();
//                        String privateMethod = CustomUtil.getCallingMethodName(qualifiedName);
//                        if(privateMethodNames.containsValue(privateMethod)){
//                            usesMethod[0] = true;
//                        }
//                    }
//                }else if("getDeclaredMethod".equals(methodName)){
//                    PsiExpression[] arguments = expression.getArgumentList().getExpressions();
//                    String privateMethod = CustomUtil.getCallingMethodName(arguments[0].getText());
//                    if(privateMethodNames.containsValue(privateMethod)){
//                        usesMethod[0] = true;
//                    }
//                }
//            }
//        });
//        return usesMethod[0];
//    }
//}




Junit Run-
private void runTests(List<PsiMethod> testMethods) {
//        List<DiscoverySelector> selectors = new ArrayList<>();
//
//        for (PsiMethod method : testMethods) {
//            PsiClass containingClass = method.getContainingClass();
//            if (containingClass != null) {
//                String className = containingClass.getQualifiedName();
//                String methodName = method.getName();
//
//                if (className != null) {
//                    selectors.add(DiscoverySelectors.selectMethod(className, methodName));
//                }
//            }
//        }
//
//        LauncherDiscoveryRequest request = LauncherDiscoveryRequestBuilder.request()
//                .selectors(selectors)
//                .build();
//
//        Launcher launcher = LauncherFactory.create();
//        SummaryGeneratingListener listener = new SummaryGeneratingListener();
//        launcher.registerTestExecutionListeners(listener);
//        launcher.execute(request);
//
//        TestExecutionSummary summary = listener.getSummary();
//        summary.printTo(new java.io.PrintWriter(System.out));
//    }

    //Below Part need to be made

//    public void runAffectedTests() {
//        Set<String> affectedMethodsSignatures = AFFECTED_METHODS.keySet();
//        Set<PsiMethod> affectedMethods = getAffectedMethods(affectedMethodsSignatures);
//
////        Set<PsiMethod> publicMethodTests = CheckPublicMethodTest.findTestsForPublicMethods(affectedMethods);
////        for(PsiMethod m: publicMethodTests){
////            System.out.println(m.getName());
////        }
//        Set<PsiMethod> privateMethodTests = CheckPrivateMethods.findTestsForPrivateMethods(affectedMethods,project);
//        for(PsiMethod m: privateMethodTests){
//            System.out.println(m.getName());
//        }
//        Set<PsiMethod> allTests = new HashSet<>();
//        //allTests.addAll(publicMethodTests);
//        allTests.addAll(privateMethodTests);
//
//        for(PsiMethod m: allTests){
//            System.out.println(m.getName());
//        }
//        //runTests(allTests);
//    }
//
//    private Set<PsiMethod> getAffectedMethods(Set<String> affectedMethodsSignatures) {
//        Set<PsiMethod> affectedMethods = new HashSet<>();
//        for (String methodSignature : affectedMethodsSignatures) {
//            PsiMethod psiMethod = CustomUtil.convertSignatureToPsiMethod(methodSignature,project);
//            if (psiMethod != null) {
//                affectedMethods.add(psiMethod);
//            }
//        }
//        for(PsiMethod m: affectedMethods){
//            System.out.println(m);
//        }
//        return affectedMethods;
//    }
//
//
//    public void runTests(Set<PsiMethod> testMethods) {
//        Launcher launcher = LauncherFactory.create();
//        System.out.println("Available Test Engines: " + launcher);
//
//        SummaryGeneratingListener listener = new SummaryGeneratingListener();
//
//        for (PsiMethod method : testMethods) {
//            String className = method.getContainingClass().getQualifiedName();
//            String methodName = method.getName();
//
//            LauncherDiscoveryRequest request = LauncherDiscoveryRequestBuilder.request()
//                    .selectors(selectMethod(className, methodName))
//                    .build();
//
//            launcher.execute(request, listener);
//        }
//
//        listener.getSummary().printTo(new PrintWriter(System.out));
//    }



CustomUtil Not Used Code -
public static String extractMethodNameForClass(String methodSignature) {
        int lastDotIndex = methodSignature.lastIndexOf('.');
        if (lastDotIndex != -1) {
            int methodStartIndex = methodSignature.lastIndexOf('.', lastDotIndex - 1);
            if (methodStartIndex != -1) {
                return methodSignature.substring(methodStartIndex + 1, lastDotIndex);
            }
        }
        return "";
    }



    public static PsiMethod convertSignatureToPsiMethod(String methodSignature,Project project) {
        String className = extractClassName(methodSignature);
        String methodName = extractMethodName(methodSignature);
        String[] parameterTypes = extractParameterTypes(methodSignature);

        PsiShortNamesCache shortNamesCache = PsiShortNamesCache.getInstance(project);
        GlobalSearchScope scope = GlobalSearchScope.projectScope(project);
        PsiClass[] classes = shortNamesCache.getClassesByName(className, scope);

        for (PsiClass psiClass : classes) {
            for (PsiMethod method : psiClass.findMethodsByName(methodName, false)) {
                if (isMatchingParameters(method, parameterTypes)) {
                    return method;
                }
            }
        }
        return null;
    }

    public static String getCallingMethodName(String expression){
        int startIndex=expression.indexOf('"');
        int lastIndex=expression.lastIndexOf('"');
        return expression.substring(startIndex + 1, lastIndex);
    }


IMPORTANT!!! IntellijTestRunnerCode -


//package com.your.projectroot;
//
//import com.intellij.execution.RunManager;
//import com.intellij.execution.RunnerAndConfigurationSettings;
//import com.intellij.execution.configurations.ConfigurationFactory;
//import com.intellij.execution.configurations.ConfigurationType;
//import com.intellij.execution.configurations.ConfigurationTypeUtil;
//import com.intellij.execution.executors.DefaultRunExecutor;
//import com.intellij.execution.junit.JUnitConfiguration;
//import com.intellij.execution.junit.JUnitConfigurationType;
//import com.intellij.execution.runners.ExecutionUtil;
//import com.intellij.openapi.project.Project;
//import com.intellij.psi.PsiMethod;
//
//import java.util.Set;
//
//public class IntelliJTestRunner {
//
//    public static void runTests(Project project, Set<PsiMethod> testMethods) {
//        RunManager runManager = RunManager.getInstance(project);
//
//        ConfigurationType junitConfigType = ConfigurationTypeUtil.findConfigurationType(JUnitConfigurationType.class);
//        ConfigurationFactory junitConfigFactory = junitConfigType.getConfigurationFactories()[0];
//
//        RunnerAndConfigurationSettings settings = runManager.getSelectedConfiguration();
//        JUnitConfiguration configuration = (JUnitConfiguration) settings;
//
//
//        for (PsiMethod testMethod : testMethods) {
//            JUnitConfiguration.Data data = configuration.getPersistentData();
//            data.TEST_OBJECT = JUnitConfiguration.TEST_METHOD;
//            data.METHOD_NAME = testMethod.getName();
//            data.setMainClass(testMethod.getContainingClass());
//
//            runManager.addConfiguration(settings);
//            runManager.setSelectedConfiguration(settings);
//            ExecutionUtil.runConfiguration(settings, DefaultRunExecutor.getRunExecutorInstance());
//        }
//    }
//}

